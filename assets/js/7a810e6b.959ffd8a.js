"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7712],{7415:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>de,default:()=>he,frontMatter:()=>pe,metadata:()=>ce,toc:()=>ge});var i=n(7896),a=n(7294),s=n(3905),r=n(3873),l=n(3217),o=n(2927),u=n(6716),m=function(e,t){return m=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])},m(e,t)};function p(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Class extends value "+String(t)+" is not a constructor or null");function n(){this.constructor=e}m(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)}var d=function(){return d=Object.assign||function(e){for(var t,n=1,i=arguments.length;n<i;n++)for(var a in t=arguments[n])Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a]);return e},d.apply(this,arguments)};var c={onContentError:"contentError",onRenderComplete:"renderComplete",onRequestAppend:"requestAppend",onRequestPrepend:"requestPrepend",onChangeScroll:"changeScroll"},g=[];for(var y in c)g.push(y);var h=function(e,t,n){if(n||2===arguments.length)for(var i,a=0,s=t.length;a<s;a++)!i&&a in t||(i||(i=Array.prototype.slice.call(t,0,a)),i[a]=t[a]);return e.concat(i||Array.prototype.slice.call(t))}(["tag","placeholder","status","useFirstRender","loading","itemBy","groupBy"],g,!0);function f(e){return"function"==typeof e}var v=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t._wrapperRef=(0,o.createRef)(),t._containerRef=(0,o.createRef)(),t}p(t,e);var n=t.prototype;return n.render=function(){var e={},t=this.props,n=this.constructor.GridClass.defaultOptions,i=t.tag||"div";for(var a in t)a in n||h.indexOf(a)>-1||(e[a]=t[a]);return(0,o.createElement)(i,d({ref:this._wrapperRef},e),this._renderContainer())},n.componentDidMount=function(){var e=this,t=this.constructor.GridClass,n=t.defaultOptions,i={},a=this.props,s=this._containerRef.current;for(var r in n)r in a&&(i[r]=a[r]);s&&(i.container=s),this._renderer=new u.Th,i.renderer=this._renderer;var l=new t(this._wrapperRef.current,i),o=function(t){var n=c[t];l.on(n,(function(n){var i=e.props[t];i&&i(n)}))};for(var m in c)o(m);this._grid=l,this._renderer.on("update",(function(){e.setState({})})),(0,u.FK)(this._getItemInfos(),{grid:l,useFirstRender:a.useFirstRender,useLoading:a.loading,usePlaceholder:a.placeholder,horizontal:a.horizontal,status:a.status}),this._renderer.updated()},n.componentDidUpdate=function(){var e=this.constructor.GridClass.propertyTypes,t=this.props,n=this._grid;for(var i in e)i in t&&(n[i]=t[i]);this._renderer.updated()},n.componentWillUnmount=function(){this._grid.destroy()},n._getItemInfos=function(){var e=this.props,t=o.Children.toArray(e.children),n=e.attributePrefix||u.ZP.defaultOptions.attributePrefix,i=e.itemBy||function(e){return e.key},a=e.groupBy||function(e){return e.props["".concat(n,"groupkey")]};return t.map((function(e,t){return{groupKey:a(e,t),key:i(e,t),data:{jsx:e}}}))},n._renderContainer=function(){var e=this.props,t=this._getVisibleChildren(),n=e.container,i=e.containerTag||"div";return!0===n?(0,o.createElement)(i,{ref:this._containerRef},t):t},n._getVisibleChildren=function(){var e=this.props,t=e.placeholder,n=e.loading;return(0,u.dw)(this._getItemInfos(),{grid:this._grid,status:e.status,horizontal:e.horizontal,useFirstRender:e.useFirstRender,useLoading:e.loading,usePlaceholder:e.placeholder}).map((function(e){return e.type===u.Z$.VIRTUAL?(0,o.cloneElement)(f(t)?t(e):t,{key:e.key}):e.type===u.Z$.LOADING?(0,o.cloneElement)(f(n)?n(e):n,{key:e.key}):e.data.jsx}))},function(e,t,n,i){var a,s=arguments.length,r=s<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,n):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)r=Reflect.decorate(e,t,n,i);else for(var l=e.length-1;l>=0;l--)(a=e[l])&&(r=(s<3?a(r):s>3?a(t,n,r):a(t,n))||r);s>3&&r&&Object.defineProperty(t,n,r)}([u.zc],t.prototype,"_grid",void 0),t}(o.Component),k=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return p(t,e),t.GridClass=u.L2,t}(v),x=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return p(t,e),t.GridClass=u.vK,t}(v),I=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return p(t,e),t.GridClass=u.rr,t}(v),N=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return p(t,e),t.GridClass=u.Mh,t}(v);function T(e,t){const n=[],i=e*t;for(let a=0;a<t;++a)n.push({groupKey:e,key:i+a});return n}const K=e=>{let{num:t}=e;return a.createElement("div",{className:"item",style:{width:"250px"}},a.createElement("div",{className:"thumbnail"},a.createElement("img",{src:`https://naver.github.io/egjs-infinitegrid/assets/image/${t%33+1}.jpg`,alt:"egjs"})),a.createElement("div",{className:"info"},`egjs ${t}`))};function b(){const[e,t]=a.useState((()=>T(0,10)));return a.createElement(k,{className:"container",style:{height:"500px"},container:!0,gap:5,align:"center",onRequestAppend:n=>{const i=(+n.groupKey||0)+1;t([...e,...T(i,10)])}},e.map((e=>a.createElement(K,{"data-grid-groupkey":e.groupKey,key:e.key,num:e.key}))))}function G(e,t){const n=[],i=e*t;for(let a=0;a<t;++a)n.push({groupKey:e,key:i+a});return n}const j=e=>{let{num:t}=e;return a.createElement("div",{className:"item",style:{width:"250px"}},a.createElement("div",{className:"thumbnail"},a.createElement("img",{src:`https://naver.github.io/egjs-infinitegrid/assets/image/${t%33+1}.jpg`,"data-grid-maintained-target":"true",alt:"egjs"})),a.createElement("div",{className:"info"},`egjs ${t}`))};function E(){const[e,t]=a.useState((()=>G(0,10)));return a.createElement(x,{className:"container",style:{height:"500px"},container:!0,gap:5,onRequestAppend:n=>{const i=(+n.groupKey||0)+1;t([...e,...G(i,10)])}},e.map((e=>a.createElement(j,{"data-grid-groupkey":e.groupKey,key:e.key,num:e.key}))))}function R(e,t){const n=[],i=e*t;for(let a=0;a<t;++a)n.push({groupKey:e,key:i+a});return n}const C=e=>{let{num:t}=e;return a.createElement("div",{className:"item",style:{width:"250px"}},a.createElement("img",{src:`https://naver.github.io/egjs-infinitegrid/assets/image/${t%33+1}.jpg`,alt:"egjs",style:{width:"100%",height:"100%"}}))};function A(){const[e,t]=a.useState((()=>R(0,10)));return a.createElement(I,{className:"container",frame:[[1,1,2,3,3],[1,1,4,4,5]],style:{height:"500px"},container:!0,gap:5,onRequestAppend:n=>{const i=(+n.groupKey||0)+1;t([...e,...R(i,10)])}},e.map((e=>a.createElement(C,{"data-grid-groupkey":e.groupKey,key:e.key,num:e.key}))))}function w(e,t){const n=[],i=e*t;for(let a=0;a<t;++a)n.push({groupKey:e,key:i+a});return n}const S=e=>{let{num:t}=e;return a.createElement("div",{className:"item",style:{width:"250px"}},a.createElement("img",{src:`https://naver.github.io/egjs-infinitegrid/assets/image/${t%33+1}.jpg`,alt:"egjs",style:{width:"100%",height:"100%"}}))};function M(){const[e,t]=a.useState((()=>w(0,10)));return a.createElement(N,{className:"container",style:{height:"500px"},container:!0,gap:5,onRequestAppend:n=>{const i=(+n.groupKey||0)+1;t([...e,...w(i,10)])}},e.map((e=>a.createElement(S,{"data-grid-groupkey":e.groupKey,key:e.key,num:e.key}))))}function q(e,t){const n=[],i=e*t;for(let a=0;a<t;++a)n.push({groupKey:e,key:i+a});return n}const P=e=>{let{num:t}=e;return a.createElement("div",{className:"item",style:{width:"250px"}},a.createElement("div",{className:"thumbnail"},a.createElement("img",{src:`https://naver.github.io/egjs-infinitegrid/assets/image/${t%33+1}.jpg`,alt:"egjs"})),a.createElement("div",{className:"info"},`egjs ${t}`))};function _(){const[e,t]=a.useState((()=>q(0,10)));return a.createElement(k,{className:"container",style:{height:"500px"},container:!0,gap:5,align:"center",onRequestAppend:n=>{const i=(+n.groupKey||0)+1;n.wait(),setTimeout((()=>{n.ready(),t([...e,...q(i,10)])}),1e3)}},e.map((e=>a.createElement(P,{"data-grid-groupkey":e.groupKey,key:e.key,num:e.key}))))}function B(e,t){const n=[],i=e*t;for(let a=0;a<t;++a)n.push({groupKey:e,key:i+a});return n}const V=e=>{let{num:t}=e;return a.createElement("div",{className:"item",style:{width:"250px"}},a.createElement("div",{className:"thumbnail"},a.createElement("img",{src:`https://naver.github.io/egjs-infinitegrid/assets/image/${t%33+1}.jpg`,alt:"egjs"})),a.createElement("div",{className:"info"},`egjs ${t}`))};function O(){const[e,t]=a.useState((()=>B(0,10)));return a.createElement(k,{className:"container",style:{height:"500px"},container:!0,gap:5,align:"center",placeholder:a.createElement("div",{className:"placeholder"}),onRequestAppend:n=>{const i=(+n.groupKey||0)+1;n.wait(),n.currentTarget.appendPlaceholders(5,i),setTimeout((()=>{n.ready(),t([...e,...B(i,10)])}),1e3)}},e.map((e=>a.createElement(V,{"data-grid-groupkey":e.groupKey,key:e.key,num:e.key}))))}function Z(e,t){const n=[],i=e*t;for(let a=0;a<t;++a)n.push({groupKey:e,key:i+a});return n}const $=e=>{let{num:t}=e;return a.createElement("div",{className:"item",style:{width:"250px"}},a.createElement("div",{className:"thumbnail"},a.createElement("img",{src:`https://naver.github.io/egjs-infinitegrid/assets/image/${t%33+1}.jpg`,alt:"egjs"})),a.createElement("div",{className:"info"},`egjs ${t}`))};function Y(){const[e,t]=a.useState((()=>Z(0,10)));return a.createElement(k,{className:"container",style:{height:"500px"},container:!0,gap:5,align:"center",loading:a.createElement("div",{className:"loading"},"Loading..."),onRequestAppend:n=>{const i=(+n.groupKey||0)+1;n.wait(),setTimeout((()=>{n.ready(),t([...e,...Z(i,10)])}),1e3)}},e.map((e=>a.createElement($,{"data-grid-groupkey":e.groupKey,key:e.key,num:e.key}))))}function L(e,t){const n=[],i=e*t;for(let a=0;a<t;++a)n.push({groupKey:e,key:i+a});return n}const U=e=>{let{num:t}=e;return a.createElement("div",{className:"item",style:{width:"250px"}},a.createElement("div",{className:"thumbnail"},a.createElement("img",{src:`https://naver.github.io/egjs-infinitegrid/assets/image/${t%33+1}.jpg`,alt:"egjs"})),a.createElement("div",{className:"info"},`egjs ${t}`))};function D(){const e=a.useRef(),t=a.useRef(),[n,i]=a.useState((()=>L(0,10))),[s,r]=a.useState([]),[l,o]=a.useState(null),[u,m]=a.useState([]);return a.createElement("div",{className:"root"},a.createElement("div",{style:{textAlign:"center",padding:"10px"}},a.createElement("button",{className:"button",onClick:()=>{o(e.current.getStatus()),m(n)}},"Get Status")),a.createElement(k,{ref:e,className:"container",style:{height:"500px"},container:!0,gap:5,align:"center",onRequestAppend:e=>{const t=(+e.groupKey||0)+1;e.wait(),setTimeout((()=>{e.ready(),i([...n,...L(t,10)])}),100)}},n.map((e=>a.createElement(U,{"data-grid-groupkey":e.groupKey,key:e.key,num:e.key})))),a.createElement("div",{style:{textAlign:"center",padding:"10px"}},a.createElement("button",{className:"button",onClick:()=>{r(u),setTimeout((()=>{l&&t.current.setStatus(l)}))}},"Restore Status")),a.createElement(k,{className:"container",style:{height:"500px"},container:!0,gap:5,align:"center",ref:t},s.map((e=>a.createElement(U,{"data-grid-groupkey":e.groupKey,key:e.key,num:e.key})))))}var F=n(8880);function J(e,t){const n=[],i=e*t;for(let a=0;a<t;++a)n.push({groupKey:e,key:i+a});return n}const z=e=>{let{num:t}=e;return a.createElement("div",{className:"item",style:{width:"250px"}},a.createElement("div",{className:"thumbnail"},a.createElement("img",{src:`https://naver.github.io/egjs-infinitegrid/assets/image/${t%33+1}.jpg`,alt:"egjs"})),a.createElement("div",{className:"info"},`egjs ${t}`))};function W(){const e=a.useRef(),t=a.useRef(),[n,i]=a.useState((()=>J(0,10))),[s,r]=a.useState([]),[l,o]=a.useState(null),[u,m]=a.useState([]);return a.createElement("div",{className:"root"},a.createElement("div",{style:{textAlign:"center",padding:"10px"}},a.createElement("button",{className:"button",onClick:()=>{const t=e.current.getStatus(F.Z2.MINIMIZE_INVISIBLE_ITEMS),[i,a]=t.groupManager.itemCursors;o(t),m(n.slice(i,a+1))}},"Get Status")),a.createElement(k,{ref:e,className:"container",style:{height:"500px"},container:!0,gap:5,align:"center",onRequestAppend:e=>{const t=(+e.groupKey||0)+1;e.wait(),setTimeout((()=>{e.ready(),i([...n,...J(t,10)])}),100)}},n.map((e=>a.createElement(z,{"data-grid-groupkey":e.groupKey,key:e.key,num:e.key})))),a.createElement("div",{style:{textAlign:"center",padding:"10px"}},a.createElement("button",{className:"button",onClick:()=>{r(u),setTimeout((()=>{l&&t.current.setStatus(l)}))}},"Restore Status")),a.createElement(k,{className:"container",style:{height:"500px"},container:!0,gap:5,align:"center",ref:t,placeholder:a.createElement("div",{className:"placeholder"}),onRequestPrepend:e=>{e.isVirtual&&(e.wait(),setTimeout((()=>{e.ready(),r([...J(e.nextGroupKey,10),...s])}),200))},onRequestAppend:e=>{e.isVirtual&&(e.wait(),setTimeout((()=>{e.ready(),r([...s,...J(e.nextGroupKey,10)])}),200))}},s.map((e=>a.createElement(z,{"data-grid-groupkey":e.groupKey,key:e.key,num:e.key})))))}function H(e,t){const n=[],i=e*t;for(let a=0;a<t;++a)n.push({groupKey:e,key:i+a});return n}const X=e=>{let{num:t}=e;return a.createElement("div",{className:"item",style:{width:"250px"}},a.createElement("div",{className:"thumbnail"},a.createElement("img",{src:`https://naver.github.io/egjs-infinitegrid/assets/image/${t%33+1}.jpg`,alt:"egjs"})),a.createElement("div",{className:"info"},`egjs ${t}`))};function Q(){const e=a.useRef(),t=a.useRef(),[n,i]=a.useState((()=>H(0,10))),[s,r]=a.useState([]),[l,o]=a.useState(null),[u,m]=a.useState([]);return a.createElement("div",{className:"root"},a.createElement("div",{style:{textAlign:"center",padding:"10px"}},a.createElement("button",{className:"button",onClick:()=>{const t=e.current.getStatus(F.Z2.MINIMIZE_INVISIBLE_ITEMS),[i,a]=t.groupManager.itemCursors;o(t),m(n.slice(i,a+1))}},"Get Status")),a.createElement(k,{ref:e,className:"container",style:{height:"500px"},container:!0,gap:5,align:"center",onRequestAppend:e=>{const t=(+e.groupKey||0)+1;e.wait(),setTimeout((()=>{e.ready(),i([...n,...H(t,10)])}),100)}},n.map((e=>a.createElement(X,{"data-grid-groupkey":e.groupKey,key:e.key,num:e.key})))),a.createElement("div",{style:{textAlign:"center",padding:"10px"}},a.createElement("button",{className:"button",onClick:()=>{r(u),setTimeout((()=>{l&&t.current.setStatus(l)}))}},"Restore Status"),"\xa0",a.createElement("button",{className:"button",onClick:()=>{t.current.getScrollContainerElement().scrollTop=0}},"Scroll 0")),a.createElement(k,{className:"container",style:{height:"500px"},container:!0,gap:5,align:"center",ref:t,placeholder:a.createElement("div",{className:"placeholder"}),onRequestPrepend:e=>{e.isVirtual&&(e.wait(),setTimeout((()=>{e.ready(),r([...e.nextGroupKeys.map((e=>H(e,10))).flat(),...s])}),200))},onRequestAppend:e=>{e.isVirtual&&(e.wait(),setTimeout((()=>{e.ready(),r([...s,...e.nextGroupKeys.map((e=>H(e,10))).flat()])}),200))}},s.map((e=>a.createElement(X,{"data-grid-groupkey":e.groupKey,key:e.key,num:e.key})))))}var ee=n(9454);function te(e,t,n){return e.replace(/#ClassName/g,t).replace(/#DeClassName/g,n)}function ne(e,t,n){const i=[];for(const a in t)i.push(n(a,t[a]));return e.replace(/#Options/,i.join("\n"))}function ie(e,t){return e.replace(/#Maintained/,t?'data-grid-maintained-target="true"':"")}const ae=e=>{const t=e.className,n=e.hasMaintained,i=e.options||{gap:5},s=` ${t}`.replace(/([a-z ])([A-Z])/g,((e,t,n)=>`${t}-${n.toLowerCase()}`)).substr(2);const o=e.htmlCode,u=e.angularComponentCode;let m=te(e.jsCode,t,s),p=te(e.reactCode,t,s),d=te(e.vueCode,t,s),c=te(e.angularHTMLCode,t,s),g=te(e.svelteCode,t,s);return m=ne(m,i,((e,t)=>`  ${e}: ${JSON.stringify(t)},`)),p=ne(p,i,((e,t)=>`    ${e}={${JSON.stringify(t)}}`)),d=ne(d,i,((e,t)=>`    v-bind:${e}="${JSON.stringify(t)}"`)),c=ne(c,i,((e,t)=>`  [${e}]="${JSON.stringify(t)}"`)),g=ne(g,i,((e,t)=>`  ${e}={${JSON.stringify(t)}}`)),m=ie(m,n),p=ie(p,n),d=ie(d,n),c=ie(c,n),g=ie(g,n),a.createElement(r.Z,{groupId:"cfc",defaultValue:"js",values:[{label:"JavaScript",value:"js"},{label:"React",value:"react"},{label:"Vue@2",value:"vue"},{label:"Vue@3",value:"vue3"},{label:"Angular",value:"angular"},{label:"Svelte",value:"svelte"}]},a.createElement(l.Z,{value:"js"},a.createElement(ee.Z,{className:"language-html"},o),a.createElement(ee.Z,{className:"language-js"},m)),a.createElement(l.Z,{value:"react"},a.createElement(ee.Z,{className:"language-jsx"},p)),a.createElement(l.Z,{value:"vue"},a.createElement(ee.Z,{className:"language-html"},d)),a.createElement(l.Z,{value:"vue3"},a.createElement(ee.Z,{className:"language-html"},d.replace("vue-infinitegrid","vue3-infinitegrid"))),a.createElement(l.Z,{value:"angular"},a.createElement(ee.Z,{className:"language-html"},c),a.createElement(ee.Z,{className:"language-ts"},u)),a.createElement(l.Z,{value:"svelte"},a.createElement(ee.Z,{className:"language-html"},g)))},se=e=>a.createElement(ae,(0,i.Z)({htmlCode:'<div class="container"></div>\n',reactCode:'import * as React from "react";\nimport { #ClassName } from "@egjs/react-infinitegrid";\n\nfunction getItems(nextGroupKey: number, count: number) {\n  const nextItems = [];\n  const nextKey = nextGroupKey * count;\n\n  for (let i = 0; i < count; ++i) {\n    nextItems.push({ groupKey: nextGroupKey, key: nextKey + i });\n  }\n  return nextItems;\n}\n\nconst Item = ({ num }: any) => <div className="item" style={{\n  width: "250px",\n}}>\n  <div className="thumbnail">\n    <img\n      src={`https://naver.github.io/egjs-infinitegrid/assets/image/${(num % 33) + 1}.jpg`}\n      alt="egjs" #Maintained\n    />\n  </div>\n  <div className="info">{`egjs ${num}`}</div>\n</div>;\n\nexport default function App() {\n  const [items, setItems] = React.useState(() => getItems(0, 10));\n\n  return <#ClassName\n    className="container"\n#Options\n    onRequestAppend={(e) => {\n      const nextGroupKey = (+e.groupKey! || 0) + 1;\n\n      setItems([\n        ...items,\n        ...getItems(nextGroupKey, 10),\n      ]);\n    }}\n  >\n    {items.map((item) => <Item data-grid-groupkey={item.groupKey} key={item.key} num={item.key} />)}\n  </#ClassName>;\n}\n',jsCode:'import { #ClassName } from "@egjs/infinitegrid";\n\nfunction getItems(nextGroupKey, count) {\n  const nextItems = [];\n\n  for (let i = 0; i < count; ++i) {\n    const num = nextGroupKey * count + i;\n    nextItems.push(`<div class="item">\n  <div class="thumbnail">\n      <img src="https://naver.github.io/egjs-infinitegrid/assets/image/${(num % 33) + 1}.jpg" alt="egjs" #Maintained/>\n  </div>\n  <div class="info">egjs ${num}</div>\n</div>`);\n  }\n  return nextItems;\n}\nconst ig = new #ClassName(".container", {\n#Options\n});\n\nig.on("requestAppend", (e) => {\n  const nextGroupKey = (+e.groupKey || 0) + 1;\n\n  ig.append(getItems(nextGroupKey, 10), nextGroupKey);\n});\nig.renderItems();\n',vueCode:'<template>\n  <#DeClassName\n    class="container"\n#Options\n    v-on:request-append="onRequestAppend"\n  >\n    <div\n      class="item"\n      v-for="item in items"\n      :key="item.key"\n      :data-grid-groupkey="item.groupKey"\n    >\n      <div class="thumbnail">\n        <img\n          v-bind:src="\n            \'https://naver.github.io/egjs-infinitegrid/assets/image/\' +\n            ((item.key % 33) + 1) +\n            \'.jpg\'\n          "\n          alt="egjs" #Maintained\n        />\n      </div>\n      <div class="info">egjs {{ item.key }}</div>\n    </div>\n  </#DeClassName>\n</template>\n<script lang="ts">\nimport { #ClassName } from "@egjs/vue-infinitegrid";\n\nexport default {\n  components: {\n    #ClassName,\n  },\n  data() {\n    return {\n      items: this.getItems(0, 10),\n    };\n  },\n  methods: {\n    getItems(nextGroupKey: number, count: number) {\n      const nextItems: any[] = [];\n\n      for (let i = 0; i < count; ++i) {\n        const nextKey = nextGroupKey * count + i;\n\n        nextItems.push({ groupKey: nextGroupKey, key: nextKey });\n      }\n      return nextItems;\n    },\n    onRequestAppend(e) {\n      const nextGroupKey = (+e.groupKey! || 0) + 1;\n\n      this.items = [...this.items, ...this.getItems(nextGroupKey, 10)];\n    },\n  },\n};\n<\/script>\n',angularHTMLCode:'<div Ngx#ClassName\n  class="container"\n#Options\n  [items]="items"\n  [trackBy]="trackBy"\n  [groupBy]="groupBy"\n  (requestAppend)="onRequestAppend($event)"\n  *ngFor="let item of [0]; trackBy: randomTrackBy;"\n  #ig\n  >\n  <div class="item" *ngFor ="let item of ig.visibleItems; trackBy: trackBy;">\n    <div class="thumbnail">\n        <img [src]="\'https://naver.github.io/egjs-infinitegrid/assets/image/\' + (item.data.key % 33 + 1) + \'.jpg\'" alt="egjs" #Maintained/>\n    </div>\n    <div class="info">egjs {{item.data.key}}</div>\n  </div>\n</div>\n',angularComponentCode:"import { Component, Input } from '@angular/core';\nimport { OnRequestAppend } from '@egjs/infinitegrid';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n})\nexport class AppComponent {\n  items = this.getItems(0, 10);\n  getItems(nextGroupKey: number, count: number) {\n    const nextItems = [];\n    const nextKey = nextGroupKey * count;\n\n    for (let i = 0; i < count; ++i) {\n      nextItems.push({ groupKey: nextGroupKey, key: nextKey + i });\n    }\n    return nextItems;\n  }\n  groupBy(_: any, item: any) {\n    return item.groupKey;\n  }\n  trackBy(_: any, item: any) {\n    return item.key;\n  }\n  onRequestAppend(e: OnRequestAppend) {\n    const nextGroupKey = (+e.groupKey! || 0) + 1;\n\n    this.items = [\n      ...this.items,\n      ...this.getItems(nextGroupKey, 10),\n    ];\n  }\n}\n",svelteCode:'<script>\n  import { #ClassName } from "@egjs/svelte-infinitegrid";\n\n  let items = getItems(0, 10);\n\n  function getItems(nextGroupKey, count) {\n    const nextItems = [];\n\n    for (let i = 0; i < count; ++i) {\n      const nextKey = nextGroupKey * count + i;\n\n      nextItems.push({ groupKey: nextGroupKey, key: nextKey });\n    }\n    return nextItems;\n  }\n<\/script>\n\n<#ClassName\n  class="container"\n#Options\n  {items}\n  on:requestAppend={({ detail: e }) => {\n    const nextGroupKey = (+e.groupKey || 0) + 1;\n\n    items = [...items, ...getItems(nextGroupKey, 10)];\n  }}\n  let:visibleItems\n>\n  {#each visibleItems as item (item.key)}\n    <div class="item">\n      <div class="thumbnail">\n        <img\n          src={`https://naver.github.io/egjs-infinitegrid/assets/image/${\n            (item.key % 33) + 1\n          }.jpg`}\n          alt="egjs" #Maintained\n        />\n      </div>\n      <div class="info">{`egjs ${item.key}`}</div>\n    </div>\n  {/each}\n</#ClassName>\n'},e)),re=e=>a.createElement(ae,(0,i.Z)({htmlCode:'<div class="container"></div>\n',reactCode:'import * as React from "react";\nimport { #ClassName } from "@egjs/react-infinitegrid";\n\nfunction getItems(nextGroupKey: number, count: number) {\n  const nextItems = [];\n  const nextKey = nextGroupKey * count;\n\n  for (let i = 0; i < count; ++i) {\n    nextItems.push({ groupKey: nextGroupKey, key: nextKey + i });\n  }\n  return nextItems;\n}\n\nconst Item = ({ num }: any) => <div className="item" style={{\n  width: "250px",\n}}>\n  <div className="thumbnail">\n    <img\n      src={`https://naver.github.io/egjs-infinitegrid/assets/image/${(num % 33) + 1}.jpg`}\n      alt="egjs" #Maintained\n    />\n  </div>\n  <div className="info">{`egjs ${num}`}</div>\n</div>;\n\nexport default function App() {\n  const [items, setItems] = React.useState(() => getItems(0, 10));\n\n  return <#ClassName\n    className="container"\n#Options\n    placeholder={<div className="placeholder"></div>}\n    onRequestPrepend={(e) => {\n      if (e.isVirtual) {\n        e.wait();\n        setTimeout(() => {\n          e.ready();\n          setItems([\n            ...getItems(e.nextGroupKey, 10),\n            ...items,\n          ]);\n        }, 200);\n      }\n    }}\n    onRequestAppend={(e) => {\n      if (e.isVirtual) {\n        e.wait();\n        setTimeout(() => {\n          e.ready();\n          setItems([\n            ...items,\n            ...getItems(e.nextGroupKey, 10),\n          ]);\n        }, 200);\n      }\n    }}\n  >\n    {items.map((item) => <Item data-grid-groupkey={item.groupKey} key={item.key} num={item.key} />)}\n  </#ClassName>;\n}\n',jsCode:'import { #ClassName } from "@egjs/infinitegrid";\n\nfunction getItems(nextGroupKey, count) {\n  const nextItems = [];\n\n  for (let i = 0; i < count; ++i) {\n    const num = nextGroupKey * count + i;\n    nextItems.push(`<div class="item">\n  <div class="thumbnail">\n      <img src="https://naver.github.io/egjs-infinitegrid/assets/image/${(num % 33) + 1}.jpg" alt="egjs" #Maintained/>\n  </div>\n  <div class="info">egjs ${num}</div>\n</div>`);\n  }\n  return nextItems;\n}\nconst ig = new #ClassName(".container", {\n#Options\n});\n\nig.setPlaceholder({\n  html: `<div class="placeholder"></div>`,\n});\n\n\nig.on("requestPrepend", e => {\n  if (e.isVirtual) {\n    e.wait();\n    setTimeout(() => {\n      e.ready();\n      ig.prepend(getItems(nextGroupKey, 10), nextGroupKey);\n    }, 200);\n  }\n});\nig.on("requestAppend", e => {\n  if (e.isVirtual) {\n    e.wait();\n    e.currentTarget.appendPlaceholders(5, nextGroupKey);\n    setTimeout(() => {\n      e.ready();\n      ig.append(getItems(nextGroupKey, 10), nextGroupKey);\n    }, 200);\n  }\n});\nig.renderItems();\n',vueCode:'<template>\n  <#DeClassName\n    class="container"\n#Options\n    v-on:request-append="onRequestAppend"\n    v-on:request-prepend="onRequestPrepend"\n  >\n    <div\n      class="item"\n      v-for="item in items"\n      :key="item.key"\n      :data-grid-groupkey="item.groupKey"\n    >\n      <div class="thumbnail">\n        <img\n          v-bind:src="\n            \'https://naver.github.io/egjs-infinitegrid/assets/image/\' +\n            ((item.key % 33) + 1) +\n            \'.jpg\'\n          "\n          alt="egjs" #Maintained\n        />\n      </div>\n      <div class="info">egjs {{ item.key }}</div>\n    </div>\n    <template v-slot:placeholder="{ item }">\n    <div\n      class="placeholder"\n      :key="item.key"\n      :data-grid-groupkey="item.groupKey"\n    ></div>\n  </template>\n  </#DeClassName>\n</template>\n<script lang="ts">\nimport { #ClassName } from "@egjs/vue-infinitegrid";\n\nexport default {\n  components: {\n    #ClassName,\n  },\n  data() {\n    return {\n      items: this.getItems(0, 10),\n    };\n  },\n  methods: {\n    getItems(nextGroupKey: number, count: number) {\n      const nextItems: any[] = [];\n\n      for (let i = 0; i < count; ++i) {\n        const nextKey = nextGroupKey * count + i;\n\n        nextItems.push({ groupKey: nextGroupKey, key: nextKey });\n      }\n      return nextItems;\n    },\n    onRequestPrepend(e: OnRequestPrepend) {\n    if (e.isVirtual) {\n      e.wait();\n      setTimeout(() => {\n        e.ready();\n        this.items = [\n          ...this.getItems(e.nextGroupKey, 10),\n          ...this.items,\n        ];\n      }, 200);\n    }\n  },\n  onRequestAppend(e: OnRequestAppend) {\n    if (e.isVirtual) {\n      e.wait();\n      setTimeout(() => {\n        e.ready();\n        this.items = [\n          ...this.items,\n          ...this.getItems(e.nextGroupKey, 10),\n        ];\n      }, 200);\n    }\n  },\n};\n<\/script>\n',angularHTMLCode:'<div Ngx#ClassName\n  class="container"\n#Options\n  [items]="items"\n  [usePlaceholder]="true"\n  [trackBy]="trackBy"\n  [groupBy]="groupBy"\n  (requestAppend)="onRequestAppend($event)"\n  (requestPrepend)="onRequestPrepend($event)"\n  *ngFor="let item of [0]; trackBy: randomTrackBy;"\n  #ig\n  >\n  <ng-container *ngFor ="let item of ig.visibleItems; trackBy: trackBy;">\n    <div class="item" *ngIf="item.type === ITEM_TYPE.NORMAL">\n      <div class="thumbnail">\n          <img [src]="\'https://naver.github.io/egjs-infinitegrid/assets/image/\' + (item.data.key % 33 + 1) + \'.jpg\'" alt="egjs" #Maintained/>\n      </div>\n      <div class="info">egjs {{item.data.key}}</div>\n    </div>\n    <div class="placeholder" *ngIf="item.type === ITEM_TYPE.VIRTUAL"></div>\n  </ng-contianer>\n</div>\n',angularComponentCode:"import { Component, Input } from '@angular/core';\nimport { ITEM_TYPE, OnRequestPrepend, OnRequestAppend } from '@egjs/infinitegrid';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n})\nexport class AppComponent {\n  ITEM_TYPE = ITEM_TYPE;\n  items = this.getItems(0, 10);\n  getItems(nextGroupKey: number, count: number) {\n    const nextItems = [];\n    const nextKey = nextGroupKey * count;\n\n    for (let i = 0; i < count; ++i) {\n      nextItems.push({ groupKey: nextGroupKey, key: nextKey + i });\n    }\n    return nextItems;\n  }\n  onRequestPrepend(e: OnRequestPrepend) {\n    if (e.isVirtual) {\n      e.wait();\n      setTimeout(() => {\n        e.ready();\n        this.items = [\n          ...this.getItems(e.nextGroupKey, 10),\n          ...this.items,\n        ];\n      }, 200);\n    }\n  }\n  onRequestAppend(e: OnRequestAppend) {\n    if (e.isVirtual) {\n      e.wait();\n      setTimeout(() => {\n        e.ready();\n        this.items = [\n          ...this.items,\n          ...this.getItems(e.nextGroupKey, 10),\n        ];\n      }, 200);\n    }\n  }\n}\n",svelteCode:'<script>\n  import { #ClassName } from "@egjs/svelte-infinitegrid";\n  import { ITEM_TYPE } from "@egjs/infinitegrid";\n\n  let items = getItems(0, 10);\n\n  function getItems(nextGroupKey, count) {\n    const nextItems = [];\n\n    for (let i = 0; i < count; ++i) {\n      const nextKey = nextGroupKey * count + i;\n\n      nextItems.push({ groupKey: nextGroupKey, key: nextKey });\n    }\n    return nextItems;\n  }\n<\/script>\n\n<#ClassName\n  class="container"\n#Options\n  {items}\n  usePlaceholder={true}\n  on:requestPrepend={({ detail: e }) => {\n      if (e.isVirtual) {\n        e.wait();\n        setTimeout(() => {\n          e.ready();\n          items = [\n            ...getItems(e.nextGroupKey, 10),\n            ...items,\n          ];\n        }, 200);\n      }\n    }}\n    on:requestAppend={({ detail: e }) => {\n      if (e.isVirtual) {\n        e.wait();\n        setTimeout(() => {\n          e.ready();\n          items =[\n            ...items,\n            ...getItems(e.nextGroupKey, 10),\n          ];\n        }, 200);\n      }\n    }}\n  let:visibleItems\n>\n  {#each visibleItems as item (item.key)}\n    {#if item.type === ITEM_TYPE.NORMAL}\n      <div class="item">\n        <div class="thumbnail">\n          <img\n            src={`https://naver.github.io/egjs-infinitegrid/assets/image/${\n              (item.key % 33) + 1\n            }.jpg`}\n            alt="egjs" #Maintained\n          />\n        </div>\n        <div class="info">{`egjs ${item.key}`}</div>\n      </div>\n    {:else if item.type === ITEM_TYPE.VIRTUAL}\n      <div class="placeholder" />\n    {/if}\n  {/each}\n</#ClassName>\n'},e)),le=e=>a.createElement(ae,(0,i.Z)({htmlCode:'<div class="container"></div>\n',reactCode:'import * as React from "react";\nimport { #ClassName } from "@egjs/react-infinitegrid";\n\nfunction getItems(nextGroupKey: number, count: number) {\n  const nextItems = [];\n  const nextKey = nextGroupKey * count;\n\n  for (let i = 0; i < count; ++i) {\n    nextItems.push({ groupKey: nextGroupKey, key: nextKey + i });\n  }\n  return nextItems;\n}\n\nconst Item = ({ num }: any) => <div className="item" style={{\n  width: "250px",\n}}>\n  <div className="thumbnail">\n    <img\n      src={`https://naver.github.io/egjs-infinitegrid/assets/image/${(num % 33) + 1}.jpg`}\n      alt="egjs" #Maintained\n    />\n  </div>\n  <div className="info">{`egjs ${num}`}</div>\n</div>;\n\nexport default function App() {\n  const [items, setItems] = React.useState(() => getItems(0, 10));\n\n  return <#ClassName\n    className="container"\n#Options\n    placeholder={<div className="placeholder"></div>}\n    onRequestPrepend={(e) => {\n      if (e.isVirtual) {\n        e.wait();\n        setTimeout(() => {\n          e.ready();\n          setItems([\n            ...e.nextGroupKeys.map(key => getItems(key as number, 10)).flat(),\n            ...items,\n          ]);\n        }, 200);\n      }\n    }}\n    onRequestAppend={(e) => {\n      if (e.isVirtual) {\n        e.wait();\n        setTimeout(() => {\n          e.ready();\n          setItems([\n            ...items,\n            ...e.nextGroupKeys.map(key => getItems(key as number, 10)).flat(),\n          ]);\n        }, 200);\n      }\n    }}\n  >\n    {items.map((item) => <Item data-grid-groupkey={item.groupKey} key={item.key} num={item.key} />)}\n  </#ClassName>;\n}\n',jsCode:'import { #ClassName } from "@egjs/infinitegrid";\n\nfunction getItems(nextGroupKey, count) {\n  const nextItems = [];\n\n  for (let i = 0; i < count; ++i) {\n    const num = nextGroupKey * count + i;\n    nextItems.push({\n      groupKey: nextGroupKey,\n      key: num,\n      html: `<div class="item">\n  <div class="thumbnail">\n      <img src="https://naver.github.io/egjs-infinitegrid/assets/image/${(num % 33) + 1}.jpg" alt="egjs" #Maintained/>\n  </div>\n  <div class="info">egjs ${num}</div>\n</div>`,\n    });\n  }\n  return nextItems;\n}\nconst ig = new #ClassName(".container", {\n#Options\n});\n\nig.setPlaceholder({\n  html: `<div class="placeholder"></div>`,\n});\n\n\nig.on("requestPrepend", e => {\n  if (e.isVirtual) {\n    e.wait();\n    setTimeout(() => {\n      e.ready();\n      ig.prepend(e.nextGroupKeys.map(key => getItems(key, 10)).flat());\n    }, 200);\n  }\n});\nig.on("requestAppend", e => {\n  if (e.isVirtual) {\n    e.wait();\n    e.currentTarget.appendPlaceholders(5, nextGroupKey);\n    setTimeout(() => {\n      e.ready();\n      ig.append(e.nextGroupKeys.map(key => getItems(key, 10)).flat());\n    }, 200);\n  }\n});\nig.renderItems();\n',vueCode:'<template>\n  <#DeClassName\n    class="container"\n#Options\n    v-on:request-append="onRequestAppend"\n    v-on:request-prepend="onRequestPrepend"\n  >\n    <div\n      class="item"\n      v-for="item in items"\n      :key="item.key"\n      :data-grid-groupkey="item.groupKey"\n    >\n      <div class="thumbnail">\n        <img\n          v-bind:src="\n            \'https://naver.github.io/egjs-infinitegrid/assets/image/\' +\n            ((item.key % 33) + 1) +\n            \'.jpg\'\n          "\n          alt="egjs" #Maintained\n        />\n      </div>\n      <div class="info">egjs {{ item.key }}</div>\n    </div>\n    <template v-slot:placeholder="{ item }">\n    <div\n      class="placeholder"\n      :key="item.key"\n      :data-grid-groupkey="item.groupKey"\n    ></div>\n  </template>\n  </#DeClassName>\n</template>\n<script lang="ts">\nimport { #ClassName } from "@egjs/vue-infinitegrid";\n\nexport default {\n  components: {\n    #ClassName,\n  },\n  data() {\n    return {\n      items: this.getItems(0, 10),\n    };\n  },\n  methods: {\n    getItems(nextGroupKey: number, count: number) {\n      const nextItems: any[] = [];\n\n      for (let i = 0; i < count; ++i) {\n        const nextKey = nextGroupKey * count + i;\n\n        nextItems.push({ groupKey: nextGroupKey, key: nextKey });\n      }\n      return nextItems;\n    },\n    onRequestPrepend(e: OnRequestPrepend) {\n    if (e.isVirtual) {\n      e.wait();\n      setTimeout(() => {\n        e.ready();\n        this.items = [\n          ...e.nextGroupKeys.map(key => this.getItems(key, 10)).flat(),\n          ...this.items,\n        ];\n      }, 200);\n    }\n  },\n  onRequestAppend(e: OnRequestAppend) {\n    if (e.isVirtual) {\n      e.wait();\n      setTimeout(() => {\n        e.ready();\n        this.items = [\n          ...this.items,\n          ...e.nextGroupKeys.map(key => this.getItems(key, 10)).flat(),\n        ];\n      }, 200);\n    }\n  },\n};\n<\/script>\n',angularHTMLCode:'<div Ngx#ClassName\n  class="container"\n#Options\n  [items]="items"\n  [usePlaceholder]="true"\n  [trackBy]="trackBy"\n  [groupBy]="groupBy"\n  (requestAppend)="onRequestAppend($event)"\n  (requestPrepend)="onRequestPrepend($event)"\n  *ngFor="let item of [0]; trackBy: randomTrackBy;"\n  #ig\n  >\n  <ng-container *ngFor ="let item of ig.visibleItems; trackBy: trackBy;">\n    <div class="item" *ngIf="item.type === ITEM_TYPE.NORMAL">\n      <div class="thumbnail">\n          <img [src]="\'https://naver.github.io/egjs-infinitegrid/assets/image/\' + (item.data.key % 33 + 1) + \'.jpg\'" alt="egjs" #Maintained/>\n      </div>\n      <div class="info">egjs {{item.data.key}}</div>\n    </div>\n    <div class="placeholder" *ngIf="item.type === ITEM_TYPE.VIRTUAL"></div>\n  </ng-contianer>\n</div>\n',angularComponentCode:"import { Component, Input } from '@angular/core';\nimport { ITEM_TYPE, OnRequestPrepend, OnRequestAppend } from '@egjs/infinitegrid';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n})\nexport class AppComponent {\n  ITEM_TYPE = ITEM_TYPE;\n  items = this.getItems(0, 10);\n  getItems(nextGroupKey: number, count: number) {\n    const nextItems = [];\n    const nextKey = nextGroupKey * count;\n\n    for (let i = 0; i < count; ++i) {\n      nextItems.push({ groupKey: nextGroupKey, key: nextKey + i });\n    }\n    return nextItems;\n  }\n  onRequestPrepend(e: OnRequestPrepend) {\n    if (e.isVirtual) {\n      e.wait();\n      setTimeout(() => {\n        e.ready();\n        this.items = [\n          ...e.nextGroupKeys.map(key => this.getItems(key as number, 10)).flat(),\n          ...this.items,\n        ];\n      }, 200);\n    }\n  }\n  onRequestAppend(e: OnRequestAppend) {\n    if (e.isVirtual) {\n      e.wait();\n      setTimeout(() => {\n        e.ready();\n        this.items = [\n          ...this.items,\n          ...e.nextGroupKeys.map(key => this.getItems(key as number, 10)).flat(),\n        ];\n      }, 200);\n    }\n  }\n}\n",svelteCode:'<script>\n  import { #ClassName } from "@egjs/svelte-infinitegrid";\n  import { ITEM_TYPE } from "@egjs/infinitegrid";\n\n  let items = getItems(0, 10);\n\n  function getItems(nextGroupKey, count) {\n    const nextItems = [];\n\n    for (let i = 0; i < count; ++i) {\n      const nextKey = nextGroupKey * count + i;\n\n      nextItems.push({ groupKey: nextGroupKey, key: nextKey });\n    }\n    return nextItems;\n  }\n<\/script>\n\n<#ClassName\n  class="container"\n#Options\n  {items}\n  usePlaceholder={true}\n  on:requestPrepend={({ detail: e }) => {\n      if (e.isVirtual) {\n        e.wait();\n        setTimeout(() => {\n          e.ready();\n          items = [\n            ...e.nextGroupKeys.map(key => getItems(key, 10)).flat(),\n            ...items,\n          ];\n        }, 200);\n      }\n    }}\n    on:requestAppend={({ detail: e }) => {\n      if (e.isVirtual) {\n        e.wait();\n        setTimeout(() => {\n          e.ready();\n          items =[\n            ...items,\n            ...e.nextGroupKeys.map(key => getItems(key, 10)).flat(),\n          ];\n        }, 200);\n      }\n    }}\n  let:visibleItems\n>\n  {#each visibleItems as item (item.key)}\n    {#if item.type === ITEM_TYPE.NORMAL}\n      <div class="item">\n        <div class="thumbnail">\n          <img\n            src={`https://naver.github.io/egjs-infinitegrid/assets/image/${\n              (item.key % 33) + 1\n            }.jpg`}\n            alt="egjs" #Maintained\n          />\n        </div>\n        <div class="info">{`egjs ${item.key}`}</div>\n      </div>\n    {:else if item.type === ITEM_TYPE.VIRTUAL}\n      <div class="placeholder" />\n    {/if}\n  {/each}\n</#ClassName>\n'},e));function oe(e,t){const n=[],i=e*t;for(let a=0;a<t;++a)n.push({groupKey:e,key:i+a});return n}const ue=e=>{let{num:t}=e;return a.createElement("div",{className:"item",style:{width:"250px"}},a.createElement("div",{className:"thumbnail"},a.createElement("img",{src:`https://naver.github.io/egjs-infinitegrid/assets/image/${t%33+1}.jpg`,alt:"egjs"})),a.createElement("div",{className:"info"},`egjs ${t}`))};function me(){const[e,t]=a.useState((()=>oe(0,10)));return a.createElement(k,{className:"container transition",style:{height:"500px"},container:!0,gap:5,align:"center",onRequestAppend:n=>{const i=(+n.groupKey||0)+1;n.wait(),setTimeout((()=>{n.ready(),t([...e,...oe(i,10)])}),1e3)}},e.map((e=>a.createElement(ue,{"data-grid-groupkey":e.groupKey,key:e.key,num:e.key}))))}const pe={title:"Guides",custom_edit_url:null},de="Guides",ce={type:"mdx",permalink:"/egjs-infinitegrid/Guides",source:"@site/src/pages/Guides.mdx",title:"Guides",description:"Grid Types",frontMatter:{title:"Guides",custom_edit_url:null}},ge=[{value:"Grid Types",id:"grid-types",level:2},{value:"MasonryInfiniteGrid",id:"masonryinfinitegrid",level:3},{value:"JustifiedInfiniteGrid",id:"justifiedinfinitegrid",level:3},{value:"FrameInfiniteGrid",id:"frameinfinitegrid",level:3},{value:"PackingInfiniteGrid",id:"packinginfinitegrid",level:3},{value:"Insert Data",id:"insert-data",level:2},{value:"Wait Data Loading",id:"wait-data-loading",level:2},{value:"Use wait &amp; ready",id:"use-wait--ready",level:3},{value:"Use Placeholder",id:"use-placeholder",level:3},{value:"Use loading",id:"use-loading",level:3},{value:"Restore Status",id:"restore-status",level:2},{value:"Get Status &amp; Restore Status",id:"get-status--restore-status",level:3},{value:"Restore Visible Status",id:"restore-visible-status",level:3},{value:"Restore Visible Status with virtual items",id:"restore-visible-status-with-virtual-items",level:3},{value:"Restore Visible Status with virtual items and scroll 0",id:"restore-visible-status-with-virtual-items-and-scroll-0",level:3},{value:"Use Transition",id:"use-transition",level:2}],ye={toc:ge};function he(e){let{components:t,...n}=e;return(0,s.kt)("wrapper",(0,i.Z)({},ye,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"guides"},"Guides"),(0,s.kt)("h2",{id:"grid-types"},"Grid Types"),(0,s.kt)("h3",{id:"masonryinfinitegrid"},"MasonryInfiniteGrid"),(0,s.kt)("p",null,"MasonryInfiniteGrid is a grid that stacks items with the same width as a stack of bricks. Adjust the width of all images to the same size, find the lowest height column, and insert a new item."),(0,s.kt)(b,{mdxType:"MasonryInfiniteGrid"}),(0,s.kt)(se,{className:"MasonryInfiniteGrid",mdxType:"InfiniteGridDefaultCode"}),(0,s.kt)("h3",{id:"justifiedinfinitegrid"},"JustifiedInfiniteGrid"),(0,s.kt)("p",null,"'justified' is a printing term with the meaning that 'it fits in one row wide'. JustifiedGrid is a grid that the item is filled up on the basis of a line given a size."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"If 'data-grid-inline-offset' or 'data-grid-content-offset' are set for item element, the ratio is maintained except for the offset value."),(0,s.kt)("li",{parentName:"ul"},"If 'data-grid-maintained-target' is set for an element whose ratio is to be maintained, the item is rendered while maintaining the ratio of the element.")),(0,s.kt)(E,{mdxType:"JustifiedInfiniteGrid"}),(0,s.kt)(se,{className:"JustifiedInfiniteGrid",hasMaintained:!0,mdxType:"InfiniteGridDefaultCode"}),(0,s.kt)("h3",{id:"frameinfinitegrid"},"FrameInfiniteGrid"),(0,s.kt)("p",null,"'Frame' is a printing term with the meaning that 'it fits in one row wide'. FrameGrid is a grid that the item is filled up on the basis of a line given a size."),(0,s.kt)(A,{mdxType:"FrameInfiniteGrid"}),(0,s.kt)(se,{className:"FrameInfiniteGrid",options:{gap:5,frame:[[1,1,2,3,3],[1,1,4,4,5]]},mdxType:"InfiniteGridDefaultCode"}),(0,s.kt)("h3",{id:"packinginfinitegrid"},"PackingInfiniteGrid"),(0,s.kt)("p",null,"The PackingGrid is a grid that shows the important items bigger without sacrificing the weight of the items."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Rows and columns are separated so that items are dynamically placed within the horizontal and vertical space rather than arranged in an orderly fashion."),(0,s.kt)("li",{parentName:"ul"},"If ",(0,s.kt)("inlineCode",{parentName:"li"},"sizeWeight")," is higher than ",(0,s.kt)("inlineCode",{parentName:"li"},"ratioWeight"),", the size of items is preserved as much as possible."),(0,s.kt)("li",{parentName:"ul"},"Conversely, if ",(0,s.kt)("inlineCode",{parentName:"li"},"ratioWeight")," is higher than ",(0,s.kt)("inlineCode",{parentName:"li"},"sizeWeight"),", the ratio of items is preserved as much as possible.")),(0,s.kt)(M,{mdxType:"PackingInfiniteGrid"}),(0,s.kt)(se,{className:"PackingInfiniteGrid",mdxType:"InfiniteGridDefaultCode"}),(0,s.kt)("h2",{id:"insert-data"},"Insert Data"),(0,s.kt)("p",null,"Through scrolling, when the scroll reaches the end, the ",(0,s.kt)("inlineCode",{parentName:"p"},"requestAppend")," event is raised, and when it reaches the start, the ",(0,s.kt)("inlineCode",{parentName:"p"},"requestPrepend")," event is raised. You can add data within this event."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"You can set the key of an item through ",(0,s.kt)("inlineCode",{parentName:"li"},"itemBy")," prop."),(0,s.kt)("li",{parentName:"ul"},"You can set the group's key through ",(0,s.kt)("inlineCode",{parentName:"li"},"groupBy")," prop.")),(0,s.kt)(b,{mdxType:"MasonryInfiniteGrid"}),(0,s.kt)(r.Z,{groupId:"cfc",defaultValue:"js",values:[{label:"JavaScript",value:"js"},{label:"React",value:"react"},{label:"Vue@2",value:"vue"},{label:"Vue@3",value:"vue3"},{label:"Angular",value:"angular"},{label:"Svelte",value:"svelte"}],mdxType:"Tabs"},(0,s.kt)(l.Z,{value:"js",mdxType:"TabItem"},(0,s.kt)("p",null,"If the ",(0,s.kt)("inlineCode",{parentName:"p"},"append")," method or ",(0,s.kt)("inlineCode",{parentName:"p"},"prepend")," method is used, there is no need to use a separate key. You can set the groupKey through the second argument."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'ig.on("requestAppend", e => {\n  const nextGroupKey = (+e.groupKey || 0) + 1;\n\n  ig.append(getItems(nextGroupKey, 10), nextGroupKey);\n});\n'))),(0,s.kt)(l.Z,{value:"react",mdxType:"TabItem"},(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"React's groupBy default is jsx's ",(0,s.kt)("inlineCode",{parentName:"li"},"data-grid-groupkey")," prop. (attributePrefix: data-grid-)"),(0,s.kt)("li",{parentName:"ul"},"React's itemBy default is jsx's key.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},'const [items, setItems] = React.useState([]);\n\n<MasonryInfiniteGrid\n  groupBy={(jsx) => jsx.props["data-grid-groupkey"]}\n  itemBy={(jsx) => jsx.key}\n  onRequestAppend={(e) => {\n    const nextGroupKey = (+e.groupKey! || 0) + 1;\n\n    setItems([\n      ...items,\n      ...getItems(nextGroupKey, 10),\n    ]);\n  }}>\n  {items.map((item) => <Item data-grid-groupkey={item.groupKey} key={item.key} num={item.key} />)}\n</MasonryInfiniteGrid>\n'))),(0,s.kt)(l.Z,{value:"vue",mdxType:"TabItem"},(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Vue's groupBy default is jsx's ",(0,s.kt)("inlineCode",{parentName:"li"},"data-grid-groupkey")," prop. (attributePrefix: data-grid-)"),(0,s.kt)("li",{parentName:"ul"},"Vue's itemBy default is jsx's key.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<masonry-infinite-grid\n  :itemBy="itemBy"\n  :groupBy="groupBy"\n  @request-append="onRequestAppend">\n  <div\n    class="item"\n    v-for="item in items"\n    :key="item.key"\n    :data-grid-groupkey="item.groupKey"\n  >\n    ...\n  </div>\n</masonry-infinite-grid>\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"export default {\n  data() {\n    return {\n      items: [],\n    },\n  },\n  methods: {\n    itemBy(jsx) {\n      const key = jsx.key;\n\n      return key == null ? i : key;\n    },\n    groupBy(jsx) {\n      const props = jsx.props || jsx.data?.attrs;\n\n      return props ? props[`data-grid-groupkey`] : undefined;\n    },\n    onRequestAppend(e) {\n      const nextGroupKey = (+e.groupKey! || 0) + 1;\n\n      this.items = [\n        ...this.items,\n        ...getItems(nextGroupKey, 10),\n      ];\n  },\n};\n"))),(0,s.kt)(l.Z,{value:"vue3",mdxType:"TabItem"},(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Vue's groupBy default is jsx's ",(0,s.kt)("inlineCode",{parentName:"li"},"data-grid-groupkey")," prop. (attributePrefix: data-grid-)"),(0,s.kt)("li",{parentName:"ul"},"Vue's itemBy default is jsx's key.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<masonry-infinite-grid\n  :itemBy="itemBy"\n  :groupBy="groupBy"\n  @request-append="onRequestAppend">\n  <div\n    class="item"\n    v-for="item in items"\n    :key="item.key"\n    :data-grid-groupkey="item.groupKey"\n  >\n    ...\n  </div>\n</masonry-infinite-grid>\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"export default {\n  data() {\n    return {\n      items: [],\n    },\n  },\n  methods: {\n    itemBy(jsx) {\n      const key = jsx.key;\n\n      return key == null ? i : key;\n    },\n    groupBy(jsx) {\n      const props = jsx.props || jsx.data?.attrs;\n\n      return props ? props[`${attributePrefix}groupkey`] : undefined;\n    },\n    onRequestAppend(e) {\n      const nextGroupKey = (+e.groupKey! || 0) + 1;\n\n      this.items = [\n        ...this.items,\n        ...getItems(nextGroupKey, 10),\n      ];\n  },\n};\n"))),(0,s.kt)(l.Z,{value:"angular",mdxType:"TabItem"},"* Angular uses `trackBy` instead of `itemBy`. * Angular's `groupBy` default is item's `groupKey`. * Angular's `trackBy` default is items's `key`.",(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<div NgxMasonryInfiniteGrid\n  class="container"\n  [items]="items"\n  [trackBy]="trackBy"\n  [groupBy]="groupBy"\n  [useLoading]="true"\n  (requestAppend)="onRequestAppend($event)"\n  #ig\n  >\n  <div class="item" *ngFor ="let item of ig.visibleItems; trackBy: trackBy;">\n    ...\n  </div>\n</div>\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"export default class App {\n  items = [];\n  groupBy(_: any, item: any) {\n    return item.groupKey;\n  }\n  trackBy(_: any, item: any) {\n    return item.key;\n  }\n  onRequestAppend(e) {\n    const nextGroupKey = (+e.groupKey! || 0) + 1;\n\n    this.items = [\n      ...this.items,\n      ...getItems(nextGroupKey, 10),\n    ];\n  }\n};\n"))),(0,s.kt)(l.Z,{value:"svelte",mdxType:"TabItem"},(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Svelte's ",(0,s.kt)("inlineCode",{parentName:"li"},"groupBy")," default is item's ",(0,s.kt)("inlineCode",{parentName:"li"},"groupKey"),"."),(0,s.kt)("li",{parentName:"ul"},"Svelte's ",(0,s.kt)("inlineCode",{parentName:"li"},"itemBy")," default is items's ",(0,s.kt)("inlineCode",{parentName:"li"},"key"),".")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<script>\nlet items = [];\n<\/script>\n<MasonryInfiniteGrid\n  items={items}\n  groupBy={(item) => item.groupKey}\n  itemBy={(item) => item.key}\n  on:requestAppend={({ detail: e }) => {\n    items = [\n      ...items,\n      ...getItems(nextGroupKey, 10),\n    ];\n  }}>\n  {#each visibleItems as item (item.key)}\n    <div class="item"></div>\n  {/each}\n</MasonryInfiniteGrid>\n')))),(0,s.kt)("h2",{id:"wait-data-loading"},"Wait Data Loading"),(0,s.kt)("h3",{id:"use-wait--ready"},"Use wait & ready"),(0,s.kt)("p",null,"If you want to add items asynchronously, call the ",(0,s.kt)("inlineCode",{parentName:"p"},"e.wait")," function and when the data is ready call the ",(0,s.kt)("inlineCode",{parentName:"p"},"e.ready")," function."),(0,s.kt)(_,{mdxType:"WaitReady"}),(0,s.kt)(r.Z,{groupId:"cfc",defaultValue:"js",values:[{label:"JavaScript",value:"js"},{label:"React",value:"react"},{label:"Vue@2",value:"vue"},{label:"Vue@3",value:"vue3"},{label:"Angular",value:"angular"},{label:"Svelte",value:"svelte"}],mdxType:"Tabs"},(0,s.kt)(l.Z,{value:"js",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'ig.on("requestAppend", e => {\n  const nextGroupKey = (+e.groupKey || 0) + 1;\n\n  e.wait();\n\n  setTimeout(() => {\n    e.ready();\n    ig.append(getItems(nextGroupKey, 10), nextGroupKey);\n  }, 1000);\n});\n'))),(0,s.kt)(l.Z,{value:"react",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"const [items, setItems] = React.useState([]);\n\n<MasonryInfiniteGrid\n  onRequestAppend={(e) => {\n    const nextGroupKey = (+e.groupKey! || 0) + 1;\n\n    e.wait();\n    setTimeout(() => {\n      e.ready();\n      setItems([\n        ...items,\n        ...getItems(nextGroupKey, 10),\n      ]);\n    }, 1000);\n  }}>\n  {items.map((item) => <Item data-grid-groupkey={item.groupKey} key={item.key} num={item.key} />)}\n</MasonryInfiniteGrid>\n"))),(0,s.kt)(l.Z,{value:"vue",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"export default {\n  data() {\n    return {\n      items: [],\n    },\n  },\n  methods: {\n    onRequestAppend(e) {\n      const nextGroupKey = (+e.groupKey! || 0) + 1;\n\n      e.wait();\n      setTimeout(() => {\n        e.ready();\n        this.items = [\n          ...this.items,\n          ...getItems(nextGroupKey, 10),\n        ];\n      }, 1000);\n  },\n};\n"))),(0,s.kt)(l.Z,{value:"vue3",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"export default {\n  data() {\n    return {\n      items: [],\n    },\n  },\n  methods: {\n    onRequestAppend(e) {\n      const nextGroupKey = (+e.groupKey! || 0) + 1;\n\n      e.wait();\n      setTimeout(() => {\n        e.ready();\n        this.items = [\n          ...this.items,\n          ...getItems(nextGroupKey, 10),\n        ];\n      }, 1000);\n  },\n};\n"))),(0,s.kt)(l.Z,{value:"angular",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"export default class App {\n  items = [];\n  onRequestAppend(e) {\n    const nextGroupKey = (+e.groupKey! || 0) + 1;\n\n    e.wait();\n    setTimeout(() => {\n      e.ready();\n      this.items = [\n        ...this.items,\n        ...getItems(nextGroupKey, 10),\n      ];\n    }, 1000);\n  }\n};\n"))),(0,s.kt)(l.Z,{value:"svelte",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},"<script>\nlet items = [];\n<\/script>\n<MasonryInfiniteGrid\n  on:requestAppend={({ detail: e }) => {\n    e.wait();\n    setTimeout(() => {\n      e.ready();\n      items = [\n        ...items,\n        ...getItems(nextGroupKey, 10),\n      ];\n    }, 1000);\n  }}>\n  {items.map((item) => <Item data-grid-groupkey={item.groupKey} key={item.key} num={item.key} />)}\n</MasonryInfiniteGrid>\n")))),(0,s.kt)("h3",{id:"use-placeholder"},"Use Placeholder"),(0,s.kt)("p",null,"You can add placeholders to show instead while data is being loaded/added. The placeholder is placed on the grid instead of the actual item and can be maintained until the actual item is added."),(0,s.kt)(O,{mdxType:"Placeholder"}),(0,s.kt)(r.Z,{groupId:"cfc",defaultValue:"js",values:[{label:"JavaScript",value:"js"},{label:"React",value:"react"},{label:"Vue@2",value:"vue"},{label:"Vue@3",value:"vue3"},{label:"Angular",value:"angular"},{label:"Svelte",value:"svelte"}],mdxType:"Tabs"},(0,s.kt)(l.Z,{value:"js",mdxType:"TabItem"},(0,s.kt)("p",null,"You can set a placeholder through the ",(0,s.kt)("inlineCode",{parentName:"p"},"ig.setPlaceholder")," method."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'ig.setPlaceholder({\n  html: `<div class="placeholder"></div>`,\n});\n\nig.on("requestAppend", e => {\n  const nextGroupKey = (+e.groupKey || 0) + 1;\n\n  e.wait();\n  e.currentTarget.appendPlaceholders(5, nextGroupKey);\n  setTimeout(() => {\n    e.ready();\n    ig.append(getItems(nextGroupKey, 10), nextGroupKey);\n  }, 1000);\n});\n'))),(0,s.kt)(l.Z,{value:"react",mdxType:"TabItem"},(0,s.kt)("p",null,"You can set the placeholder via the placeholder prop."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},'const [items, setItems] = React.useState([]);\n\n<MasonryInfiniteGrid\n  placeholder={<div className="placeholder"></div>}\n  onRequestAppend={(e) => {\n    const nextGroupKey = (+e.groupKey! || 0) + 1;\n\n    e.wait();\n    e.currentTarget.appendPlaceholders(5, nextGroupKey);\n    setTimeout(() => {\n      e.ready();\n      setItems([\n        ...items,\n        ...getItems(nextGroupKey, 10),\n      ]);\n    }, 1000);\n  }}>\n  {items.map((item) => <Item data-grid-groupkey={item.groupKey} key={item.key} num={item.key} />)}\n</MasonryInfiniteGrid>\n'))),(0,s.kt)(l.Z,{value:"vue",mdxType:"TabItem"},(0,s.kt)("p",null,"A placeholder can be set via a placeholder slot."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<masonry-infinite-grid\n  @request-append="onRequestAppend">\n  <div\n    class="item"\n    v-for="item in items"\n    :key="item.key"\n    :data-grid-groupkey="item.groupKey"\n  ></div>\n  <template v-slot:placeholder="{ item }">\n    <div\n      class="placeholder"\n      :key="item.key"\n      :data-grid-groupkey="item.groupKey"\n    ></div>\n  </template>\n</masonry-infinite-grid>\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"export default {\n  data() {\n    return {\n      items: [],\n    },\n  },\n  methods: {\n    onRequestAppend(e) {\n      const nextGroupKey = (+e.groupKey! || 0) + 1;\n\n      e.wait();\n      e.currentTarget.appendPlaceholders(5, nextGroupKey);\n\n      setTimeout(() => {\n        e.ready();\n        this.items = [\n          ...this.items,\n          ...getItems(nextGroupKey, 10),\n        ];\n      }, 1000);\n  },\n};\n"))),(0,s.kt)(l.Z,{value:"vue3",mdxType:"TabItem"},(0,s.kt)("p",null,"A placeholder can be set via a placeholder slot."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<masonry-infinite-grid\n  @request-append="onRequestAppend">\n  <div\n    class="item"\n    v-for="item in items"\n    :key="item.key"\n    :data-grid-groupkey="item.groupKey"\n  ></div>\n  <template v-slot:placeholder="{ item }">\n    <div\n      class="placeholder"\n      :key="item.key"\n      :data-grid-groupkey="item.groupKey"\n    ></div>\n  </template>\n</masonry-infinite-grid>\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"export default {\n  data() {\n    return {\n      items: [],\n    },\n  },\n  methods: {\n    onRequestAppend(e) {\n      const nextGroupKey = (+e.groupKey! || 0) + 1;\n\n      e.wait();\n      e.currentTarget.appendPlaceholders(5, nextGroupKey);\n\n      setTimeout(() => {\n        e.ready();\n        this.items = [\n          ...this.items,\n          ...getItems(nextGroupKey, 10),\n        ];\n      }, 1000);\n  },\n};\n"))),(0,s.kt)(l.Z,{value:"angular",mdxType:"TabItem"},(0,s.kt)("p",null,"You can set the placeholder via usePlaceholder(true)."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<div NgxMasonryInfiniteGrid\n  class="container"\n  [usePlaceholder]="true"\n  (requestAppend)="onRequestAppend($event)"\n  #ig\n  >\n  <ng-container *ngFor ="let item of ig.visibleItems; trackBy: trackBy;">\n    <div class="item" *ngIf="item.type === ITEM_TYPE.NORMAL"></div>\n    <div class="placeholder" *ngIf="item.type === ITEM_TYPE.VIRTUAL"></div>\n  </ng-container>\n</div>\n\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},'import { ITEM_TYPE } from "@egjs/infinitegrid";\n\nexport default class App {\n  ITEM_TYPE = ITEM_TYPE;\n  items = [];\n  onRequestAppend(e) {\n    const nextGroupKey = (+e.groupKey! || 0) + 1;\n\n    e.wait();\n    e.currentTarget.appendPlaceholders(5, nextGroupKey);\n\n    setTimeout(() => {\n      e.ready();\n      this.items = [\n        ...this.items,\n        ...getItems(nextGroupKey, 10),\n      ];\n    }, 1000);\n  }\n};\n'))),(0,s.kt)(l.Z,{value:"svelte",mdxType:"TabItem"},(0,s.kt)("p",null,"You can set the placeholder via usePlaceholder(true)."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<script>\nimport { ITEM_TYPE } from "@egjs/infinitegrid";\n\nlet items = [];\n<\/script>\n<MasonryInfiniteGrid\n  usePlaceholder={true}\n  on:requestAppend={({ detail: e }) => {\n    e.wait();\n    setTimeout(() => {\n      e.ready();\n      items = [\n        ...items,\n        ...getItems(nextGroupKey, 10),\n      ];\n    }, 1000);\n  }}\n  let:visibleItems\n>\n  {#each visibleItems as item (item.key)}\n    {#if item.type === ITEM_TYPE.NORMAL}\n      <div class="item"></div>\n    {:else if item.type === ITEM_TYPE.VIRTUAL}\n      <div class="placeholder" />\n    {/if}\n  {/each}\n</MasonryInfiniteGrid>\n')))),(0,s.kt)("h3",{id:"use-loading"},"Use loading"),(0,s.kt)("p",null,"You can show the loading bar while the data is loading. It can be added by calling the ",(0,s.kt)("inlineCode",{parentName:"p"},"e.wait")," function, and the loading bar automatically disappears when data is loaded."),(0,s.kt)(Y,{mdxType:"Loading"}),(0,s.kt)(r.Z,{groupId:"cfc",defaultValue:"js",values:[{label:"JavaScript",value:"js"},{label:"React",value:"react"},{label:"Vue@2",value:"vue"},{label:"Vue@3",value:"vue3"},{label:"Angular",value:"angular"},{label:"Svelte",value:"svelte"}],mdxType:"Tabs"},(0,s.kt)(l.Z,{value:"js",mdxType:"TabItem"},(0,s.kt)("p",null,"You can set a loading through the ",(0,s.kt)("inlineCode",{parentName:"p"},"ig.setLoading")," method."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'ig.setLoading({\n  html: `<div class="loading">Loading...</div>`,\n});\n\nig.on("requestAppend", e => {\n  const nextGroupKey = (+e.groupKey || 0) + 1;\n\n  e.wait();\n  setTimeout(() => {\n    e.ready();\n    ig.append(getItems(nextGroupKey, 10), nextGroupKey);\n  }, 1000);\n});\n'))),(0,s.kt)(l.Z,{value:"react",mdxType:"TabItem"},(0,s.kt)("p",null,"You can set the loading via the loading prop."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},'const [items, setItems] = React.useState([]);\n\n<MasonryInfiniteGrid\n  loading={<div className="loading">Loading...</div>}\n  onRequestAppend={(e) => {\n    const nextGroupKey = (+e.groupKey! || 0) + 1;\n\n    e.wait();\n    setTimeout(() => {\n      e.ready();\n      setItems([\n        ...items,\n        ...getItems(nextGroupKey, 10),\n      ]);\n    }, 1000);\n  }}>\n  {items.map((item) => <Item data-grid-groupkey={item.groupKey} key={item.key} num={item.key} />)}\n</MasonryInfiniteGrid>\n'))),(0,s.kt)(l.Z,{value:"vue",mdxType:"TabItem"},(0,s.kt)("p",null,"A loading can be set via a loading slot."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<masonry-infinite-grid\n  @request-append="onRequestAppend">\n  <div\n    class="item"\n    v-for="item in items"\n    :key="item.key"\n    :data-grid-groupkey="item.groupKey"\n  ></div>\n  <template v-slot:loading="{ item }">\n    <div\n      class="loading"\n      :key="item.key"\n      :data-grid-groupkey="item.groupKey"\n    >Loading...</div>\n  </template>\n</masonry-infinite-grid>\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"export default {\n  data() {\n    return {\n      items: [],\n    },\n  },\n  methods: {\n    onRequestAppend(e) {\n      const nextGroupKey = (+e.groupKey! || 0) + 1;\n\n      e.wait();\n      setTimeout(() => {\n        e.ready();\n        this.items = [\n          ...this.items,\n          ...getItems(nextGroupKey, 10),\n        ];\n      }, 1000);\n  },\n};\n"))),(0,s.kt)(l.Z,{value:"vue3",mdxType:"TabItem"},(0,s.kt)("p",null,"A loading can be set via a loading slot."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<masonry-infinite-grid\n  @request-append="onRequestAppend">\n  <div\n    class="item"\n    v-for="item in items"\n    :key="item.key"\n    :data-grid-groupkey="item.groupKey"\n  ></div>\n  <template v-slot:loading="{ item }">\n    <div\n      class="loading"\n      :key="item.key"\n      :data-grid-groupkey="item.groupKey"\n    >Loading...</div>\n  </template>\n</masonry-infinite-grid>\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"export default {\n  data() {\n    return {\n      items: [],\n    },\n  },\n  methods: {\n    onRequestAppend(e) {\n      const nextGroupKey = (+e.groupKey! || 0) + 1;\n\n      e.wait();\n      setTimeout(() => {\n        e.ready();\n        this.items = [\n          ...this.items,\n          ...getItems(nextGroupKey, 10),\n        ];\n      }, 1000);\n  },\n};\n"))),(0,s.kt)(l.Z,{value:"angular",mdxType:"TabItem"},(0,s.kt)("p",null,"You can set the loading via useLoading(true)."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<div NgxMasonryInfiniteGrid\n  class="container"\n  [useLoading]="true"\n  (requestAppend)="onRequestAppend($event)"\n  #ig\n  >\n  <ng-container *ngFor ="let item of ig.visibleItems; trackBy: trackBy;">\n    <div class="item" *ngIf="item.type === ITEM_TYPE.NORMAL"></div>\n    <div class="loading" *ngIf="item.type === ITEM_TYPE.LOADING">Loading...</div>\n  </ng-container>\n</div>\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},'import { ITEM_TYPE } from "@egjs/infinitegrid";\n\nexport default class App {\n  ITEM_TYPE = ITEM_TYPE;\n  items = [];\n  onRequestAppend(e) {\n    const nextGroupKey = (+e.groupKey! || 0) + 1;\n\n    e.wait();\n    setTimeout(() => {\n      e.ready();\n      this.items = [\n        ...this.items,\n        ...getItems(nextGroupKey, 10),\n      ];\n    }, 1000);\n  }\n};\n'))),(0,s.kt)(l.Z,{value:"svelte",mdxType:"TabItem"},(0,s.kt)("p",null,"You can set the loading via useLoading(true)."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<script>\nimport { ITEM_TYPE } from "@egjs/infinitegrid";\n\nlet items = [];\n<\/script>\n<MasonryInfiniteGrid\n  useLoading={true}\n  on:requestAppend={({ detail: e }) => {\n    e.wait();\n    setTimeout(() => {\n      e.ready();\n      items = [\n        ...items,\n        ...getItems(nextGroupKey, 10),\n      ];\n    }, 1000);\n  }}\n  let:visibleItems\n>\n  {#each visibleItems as item (item.key)}\n    {#if item.type === ITEM_TYPE.NORMAL}\n      <div class="item"></div>\n    {:else if item.type === ITEM_TYPE.LOADING}\n      <div class="loading">Loading...</div>\n    {/if}\n  {/each}\n</MasonryInfiniteGrid>\n')))),(0,s.kt)("h2",{id:"restore-status"},"Restore Status"),(0,s.kt)("p",null,"You want to save the current status to storage before moving the page and restore it after returning the page."),(0,s.kt)("p",null,"If it does not support BF Cache like Safari, you need to save and restore the status."),(0,s.kt)("p",null,"InfiniteGrid provides a way to get and restore status."),(0,s.kt)("p",null,"If you want to restore dynamically, call the ",(0,s.kt)("inlineCode",{parentName:"p"},"setStatus")," method."),(0,s.kt)("p",null,"In the framework, items must also be saved and restored."),(0,s.kt)("h3",{id:"get-status--restore-status"},"Get Status & Restore Status"),(0,s.kt)(D,{mdxType:"Status"}),(0,s.kt)(r.Z,{groupId:"cfc",defaultValue:"js",values:[{label:"JavaScript",value:"js"},{label:"React",value:"react"},{label:"Vue@2",value:"vue"},{label:"Vue@3",value:"vue3"},{label:"Angular",value:"angular"},{label:"Svelte",value:"svelte"}],mdxType:"Tabs"},(0,s.kt)(l.Z,{value:"js",mdxType:"TabItem"},(0,s.kt)("p",null,"Get Status"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"const status = ig.getStatus();\n")),(0,s.kt)("p",null,"Restore Status"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"const ig = new MasonryInfiniteGrid(...);\n\nig.setStatus(status);\n"))),(0,s.kt)(l.Z,{value:"react",mdxType:"TabItem"},(0,s.kt)("p",null,"Get Status"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"const igRef = React.useRef();\n\n\nigRef.current.getStatus();\n\n<MasonryInfiniteGrid\n  ref={igRef}>...</MasonryInfiniteGrid>\n")),(0,s.kt)("p",null,"Restore Status"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"<MasonryInfiniteGrid\n  ref={igRef}\n  status={status}\n  >...</MasonryInfiniteGrid>\n"))),(0,s.kt)(l.Z,{value:"vue",mdxType:"TabItem"},(0,s.kt)("p",null,"Get Status"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<masonry-infinite-grid ref="ig">\n  ...\n</masonry-infinite-grid>\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"this.$refs.ig.getStatus();\n")),(0,s.kt)("p",null,"Restore Status"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<masonry-infinite-grid v-bind:status="status">\n  ...\n</masonry-infinite-grid>\n'))),(0,s.kt)(l.Z,{value:"vue3",mdxType:"TabItem"},(0,s.kt)("p",null,"Get Status"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<masonry-infinite-grid ref="ig">\n  ...\n</masonry-infinite-grid>\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"this.$refs.ig.getStatus();\n")),(0,s.kt)("p",null,"Restore Status"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<masonry-infinite-grid v-bind:status="status">\n  ...\n</masonry-infinite-grid>\n'))),(0,s.kt)(l.Z,{value:"angular",mdxType:"TabItem"},(0,s.kt)("p",null,"Get Status"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},"<div NgxMasonryInfiniteGrid #ig>\n  ...\n</div>\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"import { Component, Input, AfterViewInit } from '@angular/core';\nimport { NgxInfiniteGridComponent } from '@egjs/ngx-infinitegrid';\n\nclass App {\n  @ViewChild(\"ig\") ig!: NgxInfiniteGridComponent;\n  getStatus() {\n    this.ig.getStatus();\n  }\n}\n")),(0,s.kt)("p",null,"Restore Status"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<div NgxMasonryInfiniteGrid [status]="status" #ig>\n  ...\n</div>\n'))),(0,s.kt)(l.Z,{value:"svelte",mdxType:"TabItem"},(0,s.kt)("p",null,"Get Status"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},"let ig;\n\nig.getStatus();\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"<MasonryInfiniteGrid\n  bind:this={ig}>\n</MasonryInfiniteGrid>\n")),(0,s.kt)("p",null,"Restore Status"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"<MasonryInfiniteGrid\n  status={status}\n  bind:this={ig}>\n</MasonryInfiniteGrid>\n")))),(0,s.kt)("h3",{id:"restore-visible-status"},"Restore Visible Status"),(0,s.kt)("p",null,"To reduce the size of the status, only the status of the items in the visible area is fetched."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'import { STATUS_TYPE } from "@egjs/infinitegrid";\n\n// (default) gets all infos\nig.getStatus(STATUS_TYPE.NOT_REMOVE);\n\n// gets visible infos\nig.getStatus(STATUS_TYPE.REMOVE_INVISIBLE_GROUPS);\n\n// gets visible infos. However, the information is simplified for invisible items.\nig.getStatus(STATUS.MINIMIZE_INVISIBLE_ITEMS);\n\n// gets visible infos. However, invisible items are removed and only the outline remains.\nig.getStatus(STATUS.MINIMIZE_INVISIBLE_GROUPS);\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'import { STATUS_TYPE } from "@egjs/infinitegrid";\n\nconst status = ig.getStatus(STATUS_TYPE.MINIMIZE_INVISIBLE_ITEMS);\nconst [startCursor, endCursor] = status.groupManager.itemCursors;\nconst itemsStatus = items.slice(startCursor, endCursor + 1);\n')),(0,s.kt)("h3",{id:"restore-visible-status-with-virtual-items"},"Restore Visible Status with virtual items"),(0,s.kt)("p",null,"Since you got the status for the visible area, replace it with a placeholder to handle the invisible area."),(0,s.kt)(W,{mdxType:"VisibleStatus"}),(0,s.kt)(re,{className:"MasonryInfiniteGrid",mdxType:"InfiniteGridStatusCode"}),(0,s.kt)("h3",{id:"restore-visible-status-with-virtual-items-and-scroll-0"},"Restore Visible Status with virtual items and scroll 0"),(0,s.kt)("p",null,"Since you got the status for the visible area, replace it with a placeholder to handle the invisible area."),(0,s.kt)("p",null,"Even if you move the scroll to 0 to the invisible area, all items can be restored."),(0,s.kt)(Q,{mdxType:"VisibleStatusWithScroll"}),(0,s.kt)(le,{className:"MasonryInfiniteGrid",mdxType:"InfiniteGridAllRestoreCode"}),(0,s.kt)("h2",{id:"use-transition"},"Use Transition"),(0,s.kt)("p",null,"If you want to use transition, use CSS."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-css"},".item {\n  transition: all ease 0.2s;\n}\n")),(0,s.kt)(me,{mdxType:"Transition"}))}he.isMDXComponent=!0}}]);