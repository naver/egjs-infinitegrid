{"version":3,"file":"parallax.min.js","sources":["../src/browser.ts","../src/consts.ts","../src/utils.ts","../src/Parallax.ts"],"sourcesContent":["let win: Window;\n\nif (typeof window === \"undefined\") {\n\t// window is undefined in node.js\n\twin = {\n\t\tdocument: {},\n\t\tnavigator: {\n\t\t\tuserAgent: \"\",\n\t\t},\n\t} as Window;\n} else {\n\twin = window;\n}\n\nexport { win as window };\nexport const document = win.document;\n","import { window, document } from \"./browser\";\nimport { IAlign, InfiniteGridMethodsKeys } from \"./types\";\n\nconst ua = window.navigator.userAgent;\n\nexport const SUPPORT_COMPUTEDSTYLE = !!(\"getComputedStyle\" in window);\nexport const SUPPORT_ADDEVENTLISTENER = !!(\"addEventListener\" in document);\nexport const SUPPORT_PASSIVE = (() => {\n\tlet supportsPassiveOption = false;\n\n\ttry {\n\t\tif (SUPPORT_ADDEVENTLISTENER && Object.defineProperty) {\n\t\t\t// tslint:disable-next-line: no-empty\n\t\t\tdocument.addEventListener(\"test\", () => { }, Object.defineProperty({},\n\t\t\t\t\"passive\", {\n\t\t\t\tget() {\n\t\t\t\t\tsupportsPassiveOption = true;\n\t\t\t\t},\n\t\t\t}));\n\t\t}\n\t} catch (e) {\n\t\t//\n\t}\n\treturn supportsPassiveOption;\n})();\n\nexport const IS_IE = /MSIE|Trident|Windows Phone|Edge/.test(ua);\nexport const IS_IOS = /iPhone|iPad/.test(ua);\nexport const IS_ANDROID2 = /Android 2\\./.test(ua);\nexport const CONTAINER_CLASSNAME = \"_eg-infinitegrid-container_\";\nexport const IGNORE_CLASSNAME = \"_eg-infinitegrid-ignore_\";\nexport const TRANSITION_NAME = \"_INFINITEGRID_TRANSITION\";\n\nexport const VERTICAL = \"vertical\";\nexport const HORIZONTAL = \"horizontal\";\n\nexport const DUMMY_POSITION = -100000;\nexport const GROUPKEY_ATT = \"data-groupkey\";\n\nexport const DEFAULT_OPTIONS = {\n\titemSelector: \"*\",\n\tisOverflowScroll: false,\n\tthreshold: 100,\n\tisEqualSize: false,\n\tisConstantSize: false,\n\tuseRecycle: true,\n\thorizontal: false,\n\ttransitionDuration: 0,\n\tuseFit: true,\n\tattributePrefix: \"data-\",\n\trenderExternal: false,\n\tresizeDebounce: 100,\n\tmaxResizeDebounce: 0,\n\tpercentage: false,\n};\n\nexport const DEFAULT_LAYOUT_OPTIONS = {\n\thorizontal: false,\n\tmargin: 0,\n};\n\nexport const agent = ua.toLowerCase();\nexport const isMobile = /mobi|ios|android/.test(agent);\n\nexport const ALIGN: IAlign = {\n\tSTART: \"start\",\n\tCENTER: \"center\",\n\tEND: \"end\",\n\tJUSTIFY: \"justify\",\n};\n\nexport const IDLE = 0;\nexport const LOADING_APPEND = 1;\nexport const LOADING_PREPEND = 2;\nexport const PROCESSING = 4;\n\nconst webkit = /applewebkit\\/([\\d|.]*)/g.exec(agent);\n\nexport const WEBKIT_VERSION = (webkit && parseInt(webkit[1], 10)) || 0;\nexport const DEFENSE_BROWSER = (WEBKIT_VERSION && WEBKIT_VERSION < 537);\n\nexport const ITEM_KEYS = [\"content\", \"groupKey\", \"itemKey\", \"orgSize\", \"mounted\", \"prevRect\", \"rect\", \"size\"];\ninterface ITransitionEnd {\n\ttransitionend: string;\n\twebkitTransitionEnd: string;\n\tMSTransitionEnd: string;\n\toTransitionEnd: string;\n\tmozTransitionEnd: string;\n}\n\nexport const [TRANSFORM, TRANSITION, TRANSITION_END] = (() => {\n\tconst properties: ITransitionEnd = {\n\t\ttransitionend: \"\",\n\t\twebkitTransitionEnd: \"-webkit-\",\n\t\tMSTransitionEnd: \"-ms-\",\n\t\toTransitionEnd: \"-o-\",\n\t\tmozTransitionEnd: \"-moz-\",\n\t};\n\n\tfor (const property in properties) {\n\t\tconst prefix = properties[property as keyof ITransitionEnd];\n\n\t\tif (`on${property.toLowerCase()}` in window) {\n\t\t\treturn [`${prefix}transform`, `${prefix}transition`, property];\n\t\t}\n\t}\n\treturn [];\n})() as [\"transform\", \"transition\", \"transitionend\"];\n\nexport const INFINITEGRID_EVENTS = [\"append\", \"prepend\", \"imageError\", \"change\", \"layoutComplete\"];\n\n// It's for making mistakes.\n// Whenever you add a public method, you must add the corresponding method name to an array or object.\n// An additional error may occur if not added.\nexport const INFINITEGRID_METHODS: { [key in InfiniteGridMethodsKeys]: true } = {\n\tgetLoadingBar: true,\n\tgetItem: true,\n\tgetItems: true,\n\tlayout: true,\n\tgetGroupKeys: true,\n\tgetStatus: true,\n\tsetStatus: true,\n\tisProcessing: true,\n\tstartLoading: true,\n\tendLoading: true,\n\tisLoading: true,\n\tupdateItem: true,\n\tupdateItems: true,\n\tmoveTo: true,\n};\n","\nimport { window, document } from \"./browser\";\nimport {\n\tSUPPORT_COMPUTEDSTYLE,\n\tSUPPORT_ADDEVENTLISTENER,\n\tSUPPORT_PASSIVE,\n\tVERTICAL,\n\tHORIZONTAL,\n\tDEFAULT_LAYOUT_OPTIONS,\n\tDUMMY_POSITION,\n\tINFINITEGRID_METHODS,\n} from \"./consts\";\nimport InfiniteGrid from \"./InfiniteGrid\";\nimport { IJQuery, IRectlProperties, InnerSizeType, ClientSizeType, ScrollSizeType, OffsetSizeType, IItem, IGroup, IArrayFormat, IInfiniteGridItem } from \"./types\";\nexport function toArray(nodes: HTMLCollection): HTMLElement[];\nexport function toArray<T extends Node>(nodes: IArrayFormat<T>): T[];\nexport function toArray<T extends Node>(nodes: IArrayFormat<T>): T[] {\n\t// SCRIPT5014 in IE8\n\tconst array: T[] = [];\n\n\tif (nodes) {\n\t\tconst length = nodes.length;\n\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tarray.push(nodes[i]);\n\t\t}\n\t}\n\treturn array;\n}\nexport function matchHTML(html: string) {\n\treturn html.match(/^<([A-z]+)\\s*([^>]*)>/);\n}\n/**\n * Select or create element\n * @param {String|HTMLElement|jQuery} param\n *  when string given is as HTML tag, then create element\n *  otherwise it returns selected elements\n * @param {Boolean} multi\n * @returns {HTMLElement}\n */\nexport function $(param: Window, multi?: false): Window;\nexport function $(\n\tparam: string | HTMLElement | Array<string | HTMLElement> | IJQuery,\n\tmulti: true,\n): HTMLElement[];\nexport function $(\n\tparam: string | HTMLElement | Array<string | HTMLElement> | IJQuery,\n\tmulti?: false,\n): HTMLElement;\nexport function $(\n\tparam: string | HTMLElement | Window | IJQuery,\n\tmulti?: false,\n): HTMLElement | Window;\nexport function $(\n\tparam: string | Window | HTMLElement | Array<string | HTMLElement> | IJQuery,\n\tmulti = false,\n): HTMLElement | Window | HTMLElement[] {\n\tlet el: Window | HTMLElement | HTMLElement[] | NodeListOf<HTMLElement> | undefined;\n\n\tif (typeof param === \"string\") { // String (HTML, Selector)\n\t\t// check if string is HTML tag format\n\t\tconst match = matchHTML(param);\n\n\t\t// creating element\n\t\tif (match) { // HTML\n\t\t\tconst dummy = document.createElement(\"div\");\n\n\t\t\tdummy.innerHTML = param;\n\t\t\tel = dummy.childNodes as NodeListOf<HTMLElement>;\n\t\t} else { // Selector\n\t\t\tel = document.querySelectorAll<HTMLElement>(param);\n\t\t}\n\t\tif (multi) {\n\t\t\treturn toArray(el as NodeListOf<HTMLElement>);\n\t\t} else {\n\t\t\treturn el && (el as NodeListOf<HTMLElement>)[0];\n\t\t}\n\t} else if (isWindow(param)) { // window\n\t\tel = param;\n\t} else if (isJQuery(param)) { // jQuery\n\t\tel = multi ? $(param.toArray(), true) :\n\t\t\t$(param.get(0), false);\n\t} else if (Array.isArray(param)) {\n\t\tel = param.map(v => $(v));\n\t\tif (!multi) {\n\t\t\tel = el.length >= 1 ? (el as HTMLElement[])[0] : undefined;\n\t\t}\n\t} else if (param.nodeName &&\n\t\t(param.nodeType === 1 || param.nodeType === 9)) { // HTMLElement, Document\n\t\tel = param;\n\t} else {\n\t\tel = [].slice.call(el);\n\t}\n\treturn el as Window | HTMLElement | HTMLElement[];\n}\nexport function addEvent(\n\telement: Element | Window,\n\ttype: string,\n\thandler: (...args: any[]) => any,\n\teventListenerOptions?: boolean | { [key: string]: any },\n) {\n\tif (SUPPORT_ADDEVENTLISTENER) {\n\t\tlet options = eventListenerOptions || false;\n\n\t\tif (typeof eventListenerOptions === \"object\") {\n\t\t\toptions = SUPPORT_PASSIVE ? eventListenerOptions : false;\n\t\t}\n\t\telement.addEventListener(type, handler, options);\n\t} else if ((element as any).attachEvent) {\n\t\t(element as any).attachEvent(`on${type}`, handler);\n\t} else {\n\t\t(element as any)[`on${type}`] = handler;\n\t}\n}\nexport function removeEvent(\n\telement: Element | Window,\n\ttype: string,\n\thandler: (...args: any[]) => any,\n) {\n\tif (element.removeEventListener) {\n\t\telement.removeEventListener(type, handler, false);\n\t} else if ((element as any).detachEvent) {\n\t\t(element as any).detachEvent(`on${type}`, handler);\n\t} else {\n\t\t(element as any)[`on${type}`] = null;\n\t}\n}\nexport function addOnceEvent(\n\telement: Element,\n\ttype: string,\n\thandler: (...args: any[]) => any,\n\teventListenerOptions?: boolean | { [key: string]: any },\n) {\n\tconst callback = (e: any) => {\n\t\tremoveEvent(element, type, callback);\n\t\thandler(e);\n\t};\n\n\taddEvent(element, type, callback, eventListenerOptions);\n}\nexport function scroll(el: HTMLElement | Window, horizontal = false) {\n\tconst prop = `scroll${horizontal ? \"Left\" : \"Top\"}` as \"scrollLeft\" | \"scrollTop\";\n\n\tif (isWindow(el)) {\n\t\treturn window[horizontal ? \"pageXOffset\" : \"pageYOffset\"] || document.body[prop] || document.documentElement[prop];\n\t} else {\n\t\treturn el[prop];\n\t}\n}\nexport function scrollTo(el: Window | Element, x: number, y: number) {\n\tif (isWindow(el)) {\n\t\tel.scroll(x, y);\n\t} else {\n\t\tel.scrollLeft = x;\n\t\tel.scrollTop = y;\n\t}\n}\nexport function scrollBy(el: Window | Element, x: number, y: number) {\n\tif (isWindow(el)) {\n\t\tel.scrollBy(x, y);\n\t} else {\n\t\tel.scrollLeft += x;\n\t\tel.scrollTop += y;\n\t}\n}\nexport function getStyle(el: Element) {\n\treturn (SUPPORT_COMPUTEDSTYLE ?\n\t\twindow.getComputedStyle(el) : (el as any).currentStyle) || {};\n}\nfunction _getSize(el: Window | Document | HTMLElement, name: \"Width\" | \"Height\", isOffset?: boolean) {\n\tif (isWindow(el)) { // WINDOW\n\t\treturn window[`inner${name}` as InnerSizeType] || document.body[`client${name}` as ClientSizeType];\n\t} else if (isDocument(el)) { // DOCUMENT_NODE\n\t\tconst doc = (el as Document).documentElement;\n\t\tconst body = (el as Document).body;\n\n\t\treturn Math.max(\n\t\t\tbody[`scroll${name}` as ScrollSizeType], doc[`scroll${name}` as ScrollSizeType],\n\t\t\tbody[`offset${name}` as OffsetSizeType], doc[`offset${name}` as OffsetSizeType],\n\t\t\tdoc[`client${name}` as ClientSizeType],\n\t\t);\n\t} else { // NODE\n\t\tlet size = 0;\n\n\t\tif (isOffset) {\n\t\t\tconst clientRect = el.getBoundingClientRect();\n\n\t\t\tsize = name === \"Width\" ? clientRect.right - clientRect.left : clientRect.bottom - clientRect.top;\n\t\t} else {\n\t\t\tsize = el[`client${name}` as ClientSizeType] || el[`offset${name}` as OffsetSizeType];\n\t\t}\n\t\tif (size) {\n\t\t\treturn size;\n\t\t}\n\t\tconst cssSize = getStyle(el)[name.toLowerCase()];\n\n\t\treturn (~cssSize.indexOf(\"px\") && parseFloat(cssSize)) || 0;\n\t}\n}\n\nexport function innerWidth(el: Window | Document | HTMLElement) {\n\treturn _getSize(el, \"Width\", false);\n}\nexport function innerHeight(el: Window | Document | HTMLElement) {\n\treturn _getSize(el, \"Height\", false);\n}\nexport function outerWidth(el: Window | Document | HTMLElement) {\n\treturn _getSize(el, \"Width\", true);\n}\nexport function outerHeight(el: Window | Document | HTMLElement) {\n\treturn _getSize(el, \"Height\", true);\n}\nexport function getSize(el: HTMLElement) {\n\treturn {\n\t\twidth: outerWidth(el),\n\t\theight: outerHeight(el),\n\t};\n}\nexport const STYLE: {\n\tvertical: IRectlProperties,\n\thorizontal: IRectlProperties,\n} = {\n\tvertical: {\n\t\tstartPos1: \"top\",\n\t\tendPos1: \"bottom\",\n\t\tsize1: \"height\",\n\t\tstartPos2: \"left\",\n\t\tendPos2: \"right\",\n\t\tsize2: \"width\",\n\t},\n\thorizontal: {\n\t\tstartPos1: \"left\",\n\t\tendPos1: \"right\",\n\t\tsize1: \"width\",\n\t\tstartPos2: \"top\",\n\t\tendPos2: \"bottom\",\n\t\tsize2: \"height\",\n\t},\n};\n\nexport function getStyleNames(isHorizontal: boolean): IRectlProperties {\n\treturn STYLE[isHorizontal ? HORIZONTAL : VERTICAL];\n}\nexport function assign<A, B>(target: A, source: B): A & B;\nexport function assign<A, B, C>(target: A, source1: B, source2: C): A & B & C;\nexport function assign<A, B, C, D>(target: A, source1: B, source2: C, source3: D): A & B & C & D;\nexport function assign(target: { [key: string]: any }, ...sources: Array<{ [key: string]: any }>): { [key: string]: any };\nexport function assign(target: { [key: string]: any }, ...sources: Array<{ [key: string]: any }>) {\n\tsources.forEach(source => {\n\t\tfor (const key in source) {\n\t\t\ttarget[key] = source[key];\n\t\t}\n\t});\n\treturn target;\n}\nexport function assignOptions<A extends { [key: string]: any }, B extends { [key: string]: any }>(\n\tdefaultOptions: A, options: B): typeof DEFAULT_LAYOUT_OPTIONS & A & B {\n\treturn assign({},\n\t\tDEFAULT_LAYOUT_OPTIONS,\n\t\tdefaultOptions,\n\t\toptions);\n}\n\nexport function toZeroArray(outline?: number[]) {\n\tif (!outline || !outline.length) {\n\t\treturn [0];\n\t}\n\treturn outline;\n}\nexport function cloneItems<T extends { [key: string]: any }>(items: T[]) {\n\treturn items.map(item => assign({}, item));\n}\nexport function isJQuery(el: any): el is IJQuery {\n\treturn (typeof (window as any).jQuery === \"function\" && el instanceof (window as any).jQuery) ||\n\t\tel.constructor.prototype.jquery && el.toArray;\n}\nexport function isWindow(el: any): el is Window {\n\treturn el === window;\n}\nexport function isDocument(el: Node): el is Document {\n\treturn el.nodeType === 9;\n}\n\nexport function fill<T>(arr: T[], value: T) {\n\tconst length = arr.length;\n\n\tfor (let i = length - 1; i >= 0; --i) {\n\t\tarr[i] = value;\n\t}\n\n\treturn arr;\n}\n\nexport function isUndefined(target: any): target is undefined {\n\treturn typeof target === \"undefined\";\n}\n\nexport function find<T>(arr: T[], callback: (target: T) => any) {\n\tconst length = arr.length;\n\n\tfor (let i = 0; i < length; ++i) {\n\t\tif (callback(arr[i])) {\n\t\t\treturn arr[i];\n\t\t}\n\t}\n\treturn null;\n}\nexport function findLast<T>(arr: T[], callback: (target: T) => any) {\n\tconst length = arr.length;\n\n\tfor (let i = length - 1; i >= 0; --i) {\n\t\tif (callback(arr[i])) {\n\t\t\treturn arr[i];\n\t\t}\n\t}\n\treturn null;\n}\nexport function categorize(newItems: IItem[]) {\n\tconst newGroups: IGroup[] = [];\n\tconst groupKeys: { [key: string]: IGroup } = {};\n\n\tnewItems.forEach(item => {\n\t\tconst { groupKey } = item;\n\t\tlet group = groupKeys[groupKey];\n\n\t\tif (!group) {\n\t\t\tgroup = {\n\t\t\t\tgroupKey,\n\t\t\t\titems: [],\n\t\t\t};\n\t\t\tgroupKeys[groupKey] = group;\n\t\t\tnewGroups.push(group);\n\t\t}\n\n\t\tgroup.items.push(item);\n\t});\n\n\treturn newGroups;\n}\n\nexport function resetSize(item: IInfiniteGridItem) {\n\titem.orgSize = null;\n\titem.size = null;\n}\n\nexport function makeItem(groupKey: string | number, el?: HTMLElement) {\n\treturn {\n\t\tel,\n\t\tgroupKey,\n\t\tmounted: false,\n\t\tneedUpdate: true,\n\t\tcontent: el ? el.outerHTML : \"\",\n\t\trect: {\n\t\t\ttop: DUMMY_POSITION,\n\t\t\tleft: DUMMY_POSITION,\n\t\t},\n\t};\n}\n\n/**\n * Decorator that makes the method of infinitegrid available in the framework.\n * @ko 프레임워크에서 인피니트그리드의 메소드를 사용할 수 있게 하는 데코레이터.\n * @memberof eg.InfiniteGrid\n * @private\n * @example\n * ```js\n * import NativeInfiniteGrid, { withInfiniteGridMethods } from \"@egjs/infinitegrid\";\n *\n * class InfiniteGrid extends React.Component<Partial<InfiniteGridProps & InfiniteGridOptions>> {\n *   &#64;withInfiniteGridMethods\n *   private infinitegrid: NativeInfiniteGrid;\n * }\n * ```\n */\nexport function withInfiniteGridMethods(prototype: any, infinitegridName: string) {\n\tObject.keys(INFINITEGRID_METHODS).forEach((name: keyof InfiniteGrid) => {\n\t\tif (prototype[name]) {\n\t\t\treturn;\n\t\t}\n\t\tprototype[name] = function(...args) {\n\t\t\tconst result = this[infinitegridName][name](...args);\n\n\t\t\t// fix `this` type to return your own `infinitegrid` instance to the instance using the decorator.\n\t\t\tif (result === this[infinitegridName]) {\n\t\t\t\treturn this;\n\t\t\t} else {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t};\n\t});\n}\n\nexport function hasClass(element: HTMLElement, className: string) {\n\tif (element.classList) {\n\t\treturn element.classList.contains(className);\n\t}\n\treturn !!element.className.match(new RegExp(`(\\\\s|^)${className}(\\\\s|$)`));\n}\n\nexport function addClass(element: HTMLElement, className: string) {\n\tif (element.classList) {\n\t\telement.classList.add(className);\n\t} else {\n\t\telement.className += ` ${className}`;\n\t}\n}\nexport function isObject(value: any): value is object {\n\treturn typeof value === \"object\";\n}\n\nexport function getRangeCost(value: number, range: number[]) {\n\treturn Math.max(value - range[1], range[0] - value, 0) + 1;\n}\n","import { ALIGN, isMobile, TRANSFORM } from \"./consts\";\nimport { $, isWindow, assign } from \"./utils\";\nimport { IAlign, IJQuery, PositionType, SizeType, InnerSizeType, ClientSizeType, IInfiniteGridItemElement, OffsetSizeType, IInfiniteGridItem } from \"./types\";\n\nexport interface IParallaxStyle {\n\tposition: PositionType;\n\tsize: SizeType;\n\tcammelSize: string;\n\tcoordinate: string;\n}\nconst style: {\n\tvertical: IParallaxStyle;\n\thorizontal: IParallaxStyle;\n} = {\n\tvertical: { position: \"top\", size: \"height\", cammelSize: \"Height\", coordinate: \"Y\" },\n\thorizontal: { position: \"left\", size: \"width\", cammelSize: \"Width\", coordinate: \"X\" },\n};\nconst { START, CENTER } = ALIGN;\n\n/**\n * @classdesc Parallax is a displacement or difference in the apparent position of an object viewed along two different lines of sight. You can apply parallax by scrolling the image and speed of the item.\n * @ko Parallax는 서로 다른 두 개의 시선에서 바라본 물체의 외관상 위치의 변위 또는 차이입니다. 스크롤에 따라 이미지와 아이템의 속도를 차이를 줌으로써 parallax을 적용할 수 있습니다.\n * @class eg.Parallax\n * @param {Element|String} [root=window] Scrolling target. If you scroll in the body, set window. 스크롤하는 대상. 만약 body에서 스크롤하면 window로 설정한다.\n * @param {Object} [options] The option object of eg.Parallax module <ko>eg.Parallax 모듈의 옵션 객체</ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>스크롤 이동 방향 (false: 세로방향, true: 가로방향)</ko>\n * @param {Element|String} [options.container=null] Container wrapping items. If root and container have no gaps, do not set option. <ko> 아이템들을 감싸고 있는 컨테이너. 만약 root와 container간의 차이가 없으면, 옵션을 설정하지 않아도 된다.</ko>\n * @param {String} [options.selector=\"img\"] The selector of the image to apply the parallax in the item <ko> 아이템안에 있는 parallax를 적용할 이미지의 selector </ko>\n * @param {Boolean} [options.strength=1] Dimensions that indicate the sensitivity of parallax. The higher the strength, the faster.\n * @param {Boolean} [options.center=0] The middle point of parallax. The top is 1 and the bottom is -1. <ko> parallax가 가운데로 오는 점. 상단이 1이고 하단이 -1이다. </ko>\n * @param {Boolean} [options.range=[-1, 1]] Range to apply the parallax. The top is 1 and the bottom is -1. <ko> parallax가 적용되는 범위, 상단이 1이고 하단이 -1이다. </ko>\n * @param {Boolean} [options.align=\"start\"] The alignment of the image in the item. (\"start\" : top or left, \"center\": middle) <ko> 아이템안의 이미지의 정렬 </ko>\n * @example\n```\n<script>\n// isOverflowScroll: false\nvar parallax = new eg.Parallax(window, {\n  container: \".container\",\n  selector: \"img.parallax\",\n  strength: 0.8,\n  center: 0,\n  range: [-1, 1],\n  align: \"center\",\n  horizontal: true,\n});\n\n// isOverflowScroll: ture\nvar parallax = new eg.Parallax(\".container\", {\n  selector: \"img.parallax\",\n  strength: 0.8,\n  center: 0,\n  range: [-1, 1],\n  align: \"center\",\n  horizontal: true,\n});\n\n// item interface\nvar item = {\n  // original size\n  size: {\n    width: 100,\n    height: 100,\n  },\n  // view size\n  rect: {\n    top: 100,\n    left: 100,\n    width: 100,\n    height: 100,\n  }\n};\n</script>\n```\n **/\nclass Parallax {\n\tpublic options: {\n\t\tcontainer: HTMLElement;\n\t\tselector: string;\n\t\tstrength: number;\n\t\tcenter: number;\n\t\trange: number[];\n\t\talign: IAlign[keyof IAlign];\n\t\thorizontal: boolean;\n\t};\n\tprivate _root: Window | HTMLElement;\n\tprivate _container: HTMLElement;\n\tprivate _rootSize: number;\n\tprivate _containerPosition: number;\n\tprivate _style: IParallaxStyle;\n\tconstructor(\n\t\troot: Window | HTMLElement | IJQuery | string = window,\n\t\toptions: Partial<Parallax[\"options\"]> = {}) {\n\t\tthis.options = assign({\n\t\t\tcontainer: null,\n\t\t\tselector: \"img\",\n\t\t\tstrength: 1,\n\t\t\tcenter: 0,\n\t\t\trange: [-1, 1],\n\t\t\talign: START,\n\t\t\thorizontal: false,\n\t\t}, options);\n\t\tthis._root = $(root);\n\t\tthis._container = this.options.container && $(this.options.container);\n\t\tthis._rootSize = 0;\n\t\tthis._containerPosition = 0;\n\t\tthis._style = style[this.options.horizontal ? \"horizontal\" : \"vertical\"];\n\t\tthis.resize();\n\t}\n\t/**\n\t * As the browser is resized, the gaps between the root and the container and the size of the items are updated.\n\t * @ko 브라우저의 크기가 변경됨으로 써 root와 container의 간격과 아이템들의 크기를 갱신한다.\n\t * @method eg.Parallax#resize\n\t * @param {Array} [items = []] Items to apply parallax. It does not apply if it is not in visible range. <ko>parallax를 적용할 아이템들. 가시거리에 존재하지 않으면 적용이 안된다.</ko>\n\t * @return {eg.Parallax} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n\t * @example\n  ```js\n  window.addEventListener(\"resize\", function (e) {\n\tparallax.resize(items);\n  });\n  ```\n\t */\n\tpublic resize(items: IInfiniteGridItem[] = []) {\n\t\tconst root = this._root;\n\t\tconst container = this._container;\n\t\tconst positionName = this._style.position;\n\t\tconst sizeName = this._style.cammelSize;\n\n\t\tif (!container || root === container) {\n\t\t\tthis._containerPosition = 0;\n\t\t} else {\n\t\t\tconst rootRect = (isWindow(root) ? document.body : root).getBoundingClientRect();\n\t\t\tconst containertRect = container.getBoundingClientRect();\n\n\t\t\tthis._containerPosition = containertRect[positionName] - rootRect[positionName];\n\t\t}\n\t\tthis._rootSize = isWindow(root) ?\n\t\t\twindow[`inner${sizeName}` as InnerSizeType] ||\n\t\t\tdocument.documentElement[`client${sizeName}` as ClientSizeType] :\n\t\t\troot[`client${sizeName}` as ClientSizeType];\n\n\t\tif (isMobile && isWindow(root)) {\n\t\t\tconst bodyWidth = document.body.offsetWidth || document.documentElement.offsetWidth;\n\t\t\tconst windowWidth = window.innerWidth;\n\n\t\t\tthis._rootSize = this._rootSize / (bodyWidth / windowWidth);\n\t\t}\n\t\titems.forEach(item => {\n\t\t\tthis._checkParallaxItem(item.el!);\n\t\t});\n\n\t\treturn this;\n\t}\n\t/**\n\t * Scrolls the image in the item by a parallax.\n\t * @ko 스크롤하면 아이템안의 이미지를 시차적용시킨다.\n\t * @method eg.Parallax#refresh\n\t * @param {Array} [items = []] Items to apply parallax. It does not apply if it is not in visible range. <ko>parallax를 적용할 아이템들. 가시거리에 존재하지 않으면 적용이 안된다.</ko>\n\t * @param {Number} [scrollPositionStart = 0] The scroll position.\n\t * @return {eg.Parallax} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n\t * @example\n  ```js\n  document.body.addEventListener(\"scroll\", function (e) {\n\tparallax.refresh(items, e.scrollTop);\n  });\n  ```\n\t */\n\tpublic refresh(items: IInfiniteGridItem[] = [], scrollPositionStart = 0) {\n\t\tconst styleNames = this._style;\n\t\tconst positionName = styleNames.position;\n\t\tconst coordinateName = styleNames.coordinate;\n\t\tconst sizeName = styleNames.size;\n\t\tconst options = this.options;\n\t\tconst { strength, center, range, align } = options;\n\t\tconst rootSize = this._rootSize;\n\t\tconst scrollPositionEnd = scrollPositionStart + rootSize;\n\t\tconst containerPosition = this._containerPosition;\n\n\t\titems.forEach(item => {\n\t\t\tif (!item.rect || !item.size || !item.el) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst position = containerPosition + item.rect[positionName];\n\t\t\tconst itemSize = item.rect[sizeName] || item.size[sizeName];\n\n\t\t\t// check item is in container.\n\t\t\tif (scrollPositionStart > position + itemSize ||\n\t\t\t\tscrollPositionEnd < position) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst el = item.el;\n\n\t\t\tif (!el.__IMAGE__) {\n\t\t\t\tthis._checkParallaxItem(el);\n\t\t\t}\n\t\t\tif (el.__IMAGE__ === -1) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst imageElement = el.__IMAGE__!;\n\t\t\tconst boxElement = el.__BOX__!;\n\t\t\tconst boxSize = boxElement.__SIZE__!;\n\t\t\tconst imageSize = imageElement.__SIZE__!;\n\n\t\t\t// no parallax\n\t\t\tif (boxSize >= imageSize) {\n\t\t\t\t// remove transform style\n\t\t\t\timageElement.style[TRANSFORM] = \"\";\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// if area's position is center, ratio is 0.\n\t\t\t// if area is hidden at the top, ratio is 1.\n\t\t\t// if area is hidden at the bottom, ratio is -1.\n\t\t\tconst imagePosition = position + boxSize / 2;\n\t\t\tlet ratio = (scrollPositionStart + rootSize / 2 -\n\t\t\t\t(rootSize + boxSize) / 2 * center - imagePosition) /\n\t\t\t\t(rootSize + boxSize) * 2 * strength;\n\n\t\t\t// if ratio is out of the range of -1 and 1, show empty space.\n\t\t\tratio = Math.max(Math.min(ratio, range[1]), range[0]);\n\n\t\t\t// dist is the position when thumnail's image is centered.\n\t\t\tconst dist = (boxSize - imageSize) / 2;\n\t\t\tlet translate = dist * (1 - ratio);\n\n\t\t\tif (align === CENTER) {\n\t\t\t\ttranslate -= dist;\n\t\t\t}\n\n\t\t\timageElement.__TRANSLATE__ = translate;\n\t\t\timageElement.__RATIO__ = ratio;\n\t\t\timageElement.style[TRANSFORM] = `translate${coordinateName}(${translate}px)`;\n\t\t});\n\t\treturn this;\n\t}\n\tprivate _checkParallaxItem(element: IInfiniteGridItemElement) {\n\t\tif (!element) {\n\t\t\treturn;\n\t\t}\n\t\tconst selector = this.options.selector;\n\n\t\tif (!element.__IMAGE__) {\n\t\t\tconst img = element.querySelector<IInfiniteGridItemElement>(selector);\n\n\t\t\telement.__IMAGE__ = img || -1;\n\t\t\tif (!img) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telement.__BOX__ = img.parentNode as IInfiniteGridItemElement;\n\t\t}\n\t\tif (element.__IMAGE__ === -1) {\n\t\t\treturn;\n\t\t}\n\t\tconst sizeName = this._style.cammelSize;\n\n\t\telement.__IMAGE__.__SIZE__ = element.__IMAGE__[`offset${sizeName}` as OffsetSizeType];\n\t\telement.__BOX__!.__SIZE__ = element.__BOX__![`offset${sizeName}` as OffsetSizeType];\n\t}\n}\n\nexport default Parallax;\n"],"names":["win","document","window","navigator","userAgent","ua","SUPPORT_ADDEVENTLISTENER","agent","supportsPassiveOption","Object","defineProperty","addEventListener","get","e","test","toLowerCase","isMobile","ALIGN","webkit","exec","TRANSFORM","parseInt","_a","properties","transitionend","webkitTransitionEnd","MSTransitionEnd","oTransitionEnd","mozTransitionEnd","property","prefix","$","param","multi","el","isWindow","jQuery","constructor","prototype","jquery","toArray","isJQuery","Array","isArray","map","v","length","undefined","nodeName","nodeType","slice","call","html","match","matchHTML","dummy","createElement","innerHTML","childNodes","querySelectorAll","nodes","array","i","push","style","vertical","position","size","cammelSize","coordinate","horizontal","START","CENTER","root","options","target","_i","sources","forEach","source","key","assign","container","selector","strength","center","range","align","_root","_container","this","_rootSize","_containerPosition","_style","resize","items","positionName","sizeName","rootRect","body","getBoundingClientRect","containertRect","documentElement","bodyWidth","offsetWidth","windowWidth","innerWidth","item","_this","_checkParallaxItem","scrollPositionStart","styleNames","coordinateName","rootSize","scrollPositionEnd","containerPosition","rect","__IMAGE__","imageElement","boxSize","__BOX__","__SIZE__","imageSize","ratio","dist","translate","Math","max","min","__TRANSLATE__","__RATIO__","element","img","querySelector","parentNode"],"mappings":"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"}