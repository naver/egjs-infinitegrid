{"version":3,"file":"infinitegrid.min.js","sources":["../src/browser.ts","../src/consts.ts","../src/utils.ts","../src/ItemManager.ts","../src/DOMRenderer.ts","../src/Watcher.ts","../src/Infinite.ts","../src/AutoSizer.ts","../src/ImageLoaded.ts","../src/LayoutManager.ts","../src/InfiniteGrid.ts","../src/layouts/GridLayout.ts","../src/layouts/FrameLayout.ts","../src/layouts/SquareLayout.ts","../src/layouts/lib/BoxModel.ts","../src/layouts/PackingLayout.ts","../src/layouts/lib/dijkstra.ts","../src/layouts/JustifiedLayout.ts","../src/index.umd.ts"],"sourcesContent":["import { WindowMockType } from \"./types\";\n\nlet win: WindowMockType;\n\nif (typeof window === \"undefined\") {\n\t// window is undefined in node.js\n\twin = {\n\t\tdocument: {},\n\t\tnavigator: {\n\t\t\tuserAgent: \"\",\n\t\t},\n\t};\n} else {\n\twin = window;\n}\n\nexport { win as window };\nexport const document = win.document;\n","import { window, document } from \"./browser\";\nimport { IAlign } from \"./types\";\n\nconst ua = window.navigator.userAgent;\n\nexport const SUPPORT_COMPUTEDSTYLE = !!(\"getComputedStyle\" in window);\nexport const SUPPORT_ADDEVENTLISTENER = !!(\"addEventListener\" in document);\nexport const SUPPORT_PASSIVE = (() => {\n\tlet supportsPassiveOption = false;\n\n\ttry {\n\t\tif (SUPPORT_ADDEVENTLISTENER && Object.defineProperty) {\n\t\t\tdocument.addEventListener(\"test\", null, Object.defineProperty({},\n\t\t\t\t\"passive\", {\n\t\t\t\t\tget() {\n\t\t\t\t\t\tsupportsPassiveOption = true;\n\t\t\t\t\t},\n\t\t\t\t}));\n\t\t}\n\t} catch (e) {\n\t\t//\n\t}\n\treturn supportsPassiveOption;\n})();\n\nexport const IS_IE = /MSIE|Trident|Windows Phone|Edge/.test(ua);\nexport const IS_IOS = /iPhone|iPad/.test(ua);\nexport const IS_ANDROID2 = /Android 2\\./.test(ua);\nexport const CONTAINER_CLASSNAME = \"_eg-infinitegrid-container_\";\nexport const IGNORE_CLASSNAME = \"_eg-infinitegrid-ignore_\";\nexport const TRANSITION_NAME = \"_INFINITEGRID_TRANSITION\";\n\nexport const APPEND = true;\nexport const PREPEND = false;\nexport const VERTICAL = \"vertical\";\nexport const HORIZONTAL = \"horizontal\";\nexport const CACHE = true;\nexport const NO_CACHE = false;\nexport const TRUSTED = true;\nexport const NO_TRUSTED = false;\nexport const MULTI = true;\nexport const SINGLE = false;\nexport const DUMMY_POSITION = -100000;\nexport const GROUPKEY_ATT = \"data-groupkey\";\n\nexport const DEFAULT_OPTIONS = {\n\thorizontal: false,\n\tmargin: 0,\n};\n\nexport const agent = ua.toLowerCase();\nexport const isMobile = /mobi|ios|android/.test(agent);\n\nexport const ALIGN: IAlign = {\n\tSTART: \"start\",\n\tCENTER: \"center\",\n\tEND: \"end\",\n\tJUSTIFY: \"justify\",\n};\n\nexport const IDLE = 0;\nexport const LOADING_APPEND = 1;\nexport const LOADING_PREPEND = 2;\nexport const PROCESSING = 4;\n\nconst webkit = /applewebkit\\/([\\d|.]*)/g.exec(agent);\n\nexport const WEBKIT_VERSION = (webkit && parseInt(webkit[1], 10)) || 0;\nexport const DEFENSE_BROWSER = (WEBKIT_VERSION && WEBKIT_VERSION < 537);\n\ninterface ITransitionEnd {\n\ttransitionend: string;\n\twebkitTransitionEnd: string;\n\tMSTransitionEnd: string;\n\toTransitionEnd: string;\n\tmozTransitionEnd: string;\n}\n\nexport const [TRANSFORM, TRANSITION, TRANSITION_END] = (() => {\n\tconst properties: ITransitionEnd = {\n\t\ttransitionend: \"\",\n\t\twebkitTransitionEnd: \"-webkit-\",\n\t\tMSTransitionEnd: \"-ms-\",\n\t\toTransitionEnd: \"-o-\",\n\t\tmozTransitionEnd: \"-moz-\",\n\t};\n\n\tfor (const property in properties) {\n\t\tconst prefix = properties[property as keyof ITransitionEnd];\n\n\t\tif (`on${property.toLowerCase()}` in window) {\n\t\t\treturn [`${prefix}transform`, `${prefix}transition`, property];\n\t\t}\n\t}\n\treturn [];\n})() as [\"transform\", \"transition\", \"transitionend\"];\n","\nimport { window, document } from \"./browser\";\nimport {\n\tSUPPORT_COMPUTEDSTYLE,\n\tSUPPORT_ADDEVENTLISTENER,\n\tSUPPORT_PASSIVE,\n\tVERTICAL,\n\tHORIZONTAL,\n\tDEFAULT_OPTIONS,\n} from \"./consts\";\nimport { IJQuery, IRectlProperties, InnerSizeType, ClientSizeType, ScrollSizeType, OffsetSizeType, WindowMockType } from \"./types\";\n\nexport function toArray(nodes: HTMLCollection): HTMLElement[];\nexport function toArray<T extends Node>(nodes: T[] | NodeListOf<T>): T[];\nexport function toArray<T extends Node>(nodes: T[] | NodeListOf<T> | HTMLCollection) {\n\t// SCRIPT5014 in IE8\n\tconst array = [];\n\n\tif (nodes) {\n\t\tfor (let i = 0, len = nodes.length; i < len; i++) {\n\t\t\tarray.push(nodes[i]);\n\t\t}\n\t}\n\treturn array;\n}\nexport function matchHTML(html: string) {\n\treturn html.match(/^<([A-z]+)\\s*([^>]*)>/);\n}\n/**\n * Select or create element\n * @param {String|HTMLElement|jQuery} param\n *  when string given is as HTML tag, then create element\n *  otherwise it returns selected elements\n * @param {Boolean} multi\n * @returns {HTMLElement}\n */\nexport function $(param: WindowMockType, multi?: false): WindowMockType;\nexport function $(\n\tparam: string | HTMLElement | Array<string | HTMLElement> | IJQuery,\n\tmulti: true,\n): HTMLElement[];\nexport function $(\n\tparam: string | HTMLElement | Array<string | HTMLElement> | IJQuery,\n\tmulti?: false,\n): HTMLElement;\nexport function $(\n\tparam: string | HTMLElement | WindowMockType | IJQuery,\n\tmulti?: false,\n): HTMLElement | WindowMockType;\nexport function $(\n\tparam: string | WindowMockType | HTMLElement | Array<string | HTMLElement> | IJQuery,\n\tmulti = false,\n): HTMLElement | WindowMockType | HTMLElement[] {\n\tlet el: WindowMockType | HTMLElement | HTMLElement[] | NodeListOf<HTMLElement>;\n\n\tif (typeof param === \"string\") { // String (HTML, Selector)\n\t\t// check if string is HTML tag format\n\t\tconst match = matchHTML(param);\n\n\t\t// creating element\n\t\tif (match) { // HTML\n\t\t\tconst dummy = document.createElement(\"div\");\n\n\t\t\tdummy.innerHTML = param;\n\t\t\tel = dummy.childNodes as NodeListOf<HTMLElement>;\n\t\t} else { // Selector\n\t\t\tel = document.querySelectorAll(param);\n\t\t}\n\t\tif (multi) {\n\t\t\treturn toArray(el as NodeListOf<HTMLElement>);\n\t\t} else {\n\t\t\treturn el && (el as NodeListOf<HTMLElement>)[0];\n\t\t}\n\t} else if (isWindow(param)) { // window\n\t\tel = param;\n\t} else if (isJQuery(param)) { // jQuery\n\t\tel = multi ? $(param.toArray(), true) :\n\t\t\t$(param.get(0), false);\n\t} else if (Array.isArray(param)) {\n\t\tel = param.map(v => $(v));\n\t\tif (!multi) {\n\t\t\tel = el.length >= 1 ? (el as HTMLElement[])[0] : undefined;\n\t\t}\n\t} else if (param.nodeName &&\n\t\t(param.nodeType === 1 || param.nodeType === 9)) { // HTMLElement, Document\n\t\tel = param;\n\t}\n\treturn el;\n}\nexport function addEvent(\n\telement: Element | WindowMockType,\n\ttype: string,\n\thandler: (...args: any[]) => any,\n\teventListenerOptions?: boolean | { [key: string]: any },\n) {\n\tif (SUPPORT_ADDEVENTLISTENER) {\n\t\tlet options = eventListenerOptions || false;\n\n\t\tif (typeof eventListenerOptions === \"object\") {\n\t\t\toptions = SUPPORT_PASSIVE ? eventListenerOptions : false;\n\t\t}\n\t\telement.addEventListener(type, handler, options);\n\t} else if ((element as any).attachEvent) {\n\t\t(element as any).attachEvent(`on${type}`, handler);\n\t} else {\n\t\t(element as any)[`on${type}`] = handler;\n\t}\n}\nexport function removeEvent(\n\telement: Element | WindowMockType,\n\ttype: string,\n\thandler: (...args: any[]) => any,\n) {\n\tif (element.removeEventListener) {\n\t\telement.removeEventListener(type, handler, false);\n\t} else if ((element as any).detachEvent) {\n\t\t(element as any).detachEvent(`on${type}`, handler);\n\t} else {\n\t\t(element as any)[`on${type}`] = null;\n\t}\n}\nexport function addOnceEvent(\n\telement: Element,\n\ttype: string,\n\thandler: (...args: any[]) => any,\n\teventListenerOptions?: boolean | { [key: string]: any },\n) {\n\tconst callback = (e: any) => {\n\t\tremoveEvent(element, type, callback);\n\t\thandler(e);\n\t};\n\n\taddEvent(element, type, callback, eventListenerOptions);\n}\nexport function scroll(el: HTMLElement | WindowMockType, horizontal = false) {\n\tconst prop = `scroll${horizontal ? \"Left\" : \"Top\"}` as \"scrollLeft\" | \"scrollTop\";\n\n\tif (isWindow(el)) {\n\t\treturn window[horizontal ? \"pageXOffset\" : \"pageYOffset\"] || document.body[prop] || document.documentElement[prop];\n\t} else {\n\t\treturn el[prop];\n\t}\n}\nexport function scrollTo(el: WindowMockType | Element, x: number, y: number) {\n\tif (isWindow(el)) {\n\t\tel.scroll(x, y);\n\t} else {\n\t\tel.scrollLeft = x;\n\t\tel.scrollTop = y;\n\t}\n}\nexport function scrollBy(el: WindowMockType | Element, x: number, y: number) {\n\tif (isWindow(el)) {\n\t\tel.scrollBy(x, y);\n\t} else {\n\t\tel.scrollLeft += x;\n\t\tel.scrollTop += y;\n\t}\n}\nexport function getStyles(el: Element) {\n\treturn (SUPPORT_COMPUTEDSTYLE ?\n\t\twindow.getComputedStyle(el) : (el as any).currentStyle) || {};\n}\nfunction _getSize(el: WindowMockType | Document | HTMLElement, name: \"Width\" | \"Height\", isOffset?: boolean) {\n\tif (isWindow(el)) { // WINDOW\n\t\treturn window[`inner${name}` as InnerSizeType] || document.body[`client${name}` as ClientSizeType];\n\t} else if (isDocument(el)) { // DOCUMENT_NODE\n\t\tconst doc = (el as Document).documentElement;\n\t\tconst body = (el as Document).body;\n\n\t\treturn Math.max(\n\t\t\tbody[`scroll${name}` as ScrollSizeType], doc[`scroll${name}` as ScrollSizeType],\n\t\t\tbody[`offset${name}` as OffsetSizeType], doc[`offset${name}` as OffsetSizeType],\n\t\t\tdoc[`client${name}` as ClientSizeType],\n\t\t);\n\t} else { // NODE\n\t\tlet size = 0;\n\n\t\tif (isOffset) {\n\t\t\tconst clientRect = el.getBoundingClientRect();\n\n\t\t\tsize = name === \"Width\" ? clientRect.right - clientRect.left : clientRect.bottom - clientRect.top;\n\t\t} else {\n\t\t\tsize = el[`client${name}` as ClientSizeType] || el[`offset${name}` as OffsetSizeType];\n\t\t}\n\t\tif (size) {\n\t\t\treturn size;\n\t\t}\n\t\tconst cssSize = getStyles(el)[name.toLowerCase()];\n\n\t\treturn (~cssSize.indexOf(\"px\") && parseFloat(cssSize)) || 0;\n\t}\n}\n\nexport function innerWidth(el: WindowMockType | Document | HTMLElement) {\n\treturn _getSize(el, \"Width\", false);\n}\nexport function innerHeight(el: WindowMockType | Document | HTMLElement) {\n\treturn _getSize(el, \"Height\", false);\n}\nexport function outerWidth(el: WindowMockType | Document | HTMLElement) {\n\treturn _getSize(el, \"Width\", true);\n}\nexport function outerHeight(el: WindowMockType | Document | HTMLElement) {\n\treturn _getSize(el, \"Height\", true);\n}\nexport function getSize(el: HTMLElement) {\n\treturn {\n\t\twidth: outerWidth(el),\n\t\theight: outerHeight(el),\n\t};\n}\nexport const STYLE: {\n\tvertical: IRectlProperties,\n\thorizontal: IRectlProperties,\n} = {\n\tvertical: {\n\t\tstartPos1: \"top\",\n\t\tendPos1: \"bottom\",\n\t\tsize1: \"height\",\n\t\tstartPos2: \"left\",\n\t\tendPos2: \"right\",\n\t\tsize2: \"width\",\n\t},\n\thorizontal: {\n\t\tstartPos1: \"left\",\n\t\tendPos1: \"right\",\n\t\tsize1: \"width\",\n\t\tstartPos2: \"top\",\n\t\tendPos2: \"bottom\",\n\t\tsize2: \"height\",\n\t},\n};\n\nexport function getStyleNames(isHorizontal: boolean): IRectlProperties {\n\treturn STYLE[isHorizontal ? HORIZONTAL : VERTICAL];\n}\nexport function assign<A, B>(target: A, source: B): A & B;\nexport function assign<A, B, C>(target: A, source1: B, source2: C): A & B & C;\nexport function assign<A, B, C, D>(target: A, source1: B, source2: C, source3: D): A & B & C & D;\nexport function assign(target: { [key: string]: any }, ...sources: Array<{ [key: string]: any }>): { [key: string]: any };\nexport function assign(target: { [key: string]: any }, ...sources: Array<{ [key: string]: any }>) {\n\tsources.forEach(source => {\n\t\tfor (const key in source) {\n\t\t\ttarget[key] = source[key];\n\t\t}\n\t});\n\treturn target;\n}\nexport function assignOptions<A extends { [key: string]: any }, B extends { [key: string]: any }>(\n\tdefaultOptions: A, options: B): typeof DEFAULT_OPTIONS & A & B {\n\treturn assign({},\n\t\tDEFAULT_OPTIONS,\n\t\tdefaultOptions,\n\t\toptions);\n}\n\nexport function toZeroArray(outline?: number[]) {\n\tif (!outline || !outline.length) {\n\t\treturn [0];\n\t}\n\treturn outline;\n}\nexport function cloneItems<T extends { [key: string]: any }>(items: T[]) {\n\treturn items.map(item => assign({}, item));\n}\nexport function isJQuery(el: any): el is IJQuery {\n\treturn (typeof (window as any).jQuery === \"function\" && el instanceof (window as any).jQuery) ||\n\t\tel.constructor.prototype.jquery && el.toArray;\n}\nexport function isWindow(el: any): el is WindowMockType {\n\treturn el === window;\n}\nexport function isDocument(el: Node): el is Document {\n\treturn el.nodeType === 9;\n}\n\nexport function fill<T>(arr: T[], value: T) {\n\tconst length = arr.length;\n\n\tfor (let i = length - 1; i >= 0; --i) {\n\t\tarr[i] = value;\n\t}\n\n\treturn arr;\n}\n\nexport function isUndefined(target: any): target is undefined {\n\treturn typeof target === \"undefined\";\n}\n","import { MULTI, GROUPKEY_ATT, IGNORE_CLASSNAME, DUMMY_POSITION } from \"./consts\";\nimport { $, toArray, isUndefined, assign } from \"./utils\";\nimport { CursorType, IJQuery, IInfiniteGridGroup, IInfiniteGridItem, IItemManagerStatus } from \"./types\";\n\nexport default class ItemManager {\n\tpublic static from(\n\t\telements: HTMLElement[] | string | string[] | IJQuery, selector: string,\n\t\t{ groupKey }: { groupKey: string | number }) {\n\t\tconst filted = ItemManager.selectItems($(elements, MULTI), selector);\n\n\t\t// Item Structure\n\t\treturn toArray(filted).map(el => ({\n\t\t\tel,\n\t\t\tgroupKey,\n\t\t\tcontent: el.outerHTML,\n\t\t\trect: {\n\t\t\t\ttop: DUMMY_POSITION,\n\t\t\t\tleft: DUMMY_POSITION,\n\t\t\t},\n\t\t}));\n\t}\n\tpublic static selectItems(elements: HTMLElement[], selector?: string) {\n\t\treturn elements.filter(v => {\n\t\t\tconst classNames = v.className.split(\" \");\n\n\t\t\tif (classNames.some(c => c === IGNORE_CLASSNAME)) {\n\t\t\t\treturn false;\n\t\t\t} else if (!selector || selector === \"*\") {\n\t\t\t\treturn v;\n\t\t\t} else {\n\t\t\t\treturn classNames.some(c => c === selector);\n\t\t\t}\n\t\t});\n\t}\n\tpublic static pluck<A extends { [key: string]: any }, B extends keyof A>(data: A[], property: B):\n\t\tA[B] extends any[] ? A[B] : Array<A[B]> {\n\t\treturn data.reduce((acc, v) => acc.concat(v[property]), []) as any;\n\t}\n\tpublic _data: IInfiniteGridGroup[];\n\tconstructor() {\n\t\tthis.clear();\n\t}\n\tpublic getStatus(startKey?: string | number, endKey?: string | number): IItemManagerStatus {\n\t\tconst datas = this._data;\n\t\tconst startIndex = Math.max(this.indexOf(startKey), 0);\n\t\tconst endIndex = this.indexOf(endKey) + 1 || datas.length;\n\n\t\treturn {\n\t\t\t_data: datas.slice(startIndex, endIndex).map(data => {\n\t\t\t\tconst items = data.items.map(item => {\n\t\t\t\t\tconst item2 = assign({}, item);\n\n\t\t\t\t\tdelete item2.el;\n\t\t\t\t\treturn item2;\n\t\t\t\t});\n\t\t\t\tconst data2 = assign({}, data);\n\n\t\t\t\tdata2.items = items;\n\t\t\t\treturn data2;\n\t\t\t}),\n\t\t};\n\t}\n\tpublic setStatus(status: IItemManagerStatus) {\n\t\tconst data = status._data;\n\n\t\tthis.set(data);\n\t}\n\tpublic size() {\n\t\treturn this._data.length;\n\t}\n\tpublic fit(base: number, horizontal: boolean) {\n\t\tif (!this._data.length) {\n\t\t\treturn;\n\t\t}\n\t\tconst property = horizontal ? \"left\" : \"top\";\n\n\t\tif (base !== 0) {\n\t\t\tthis._data = this._data.map(v => {\n\t\t\t\tv.items = v.items.map(item => {\n\t\t\t\t\titem.rect[property] -= base;\n\t\t\t\t\treturn item;\n\t\t\t\t});\n\t\t\t\tv.outlines.start = v.outlines.start.map(start => start - base);\n\t\t\t\tv.outlines.end = v.outlines.end.map(end => end - base);\n\t\t\t\treturn v;\n\t\t\t});\n\t\t}\n\t}\n\tpublic pluck<T extends keyof IInfiniteGridGroup>(property: T, start?: number, end?: number) {\n\t\tconst data = isUndefined(start) ? this._data :\n\t\t\tthis._data.slice(start, (isUndefined(end) ? start : end) + 1);\n\n\t\treturn ItemManager.pluck(data, property);\n\t}\n\tpublic getOutline(index: number, property: keyof IInfiniteGridGroup[\"outlines\"]) {\n\t\tconst data = this._data[index];\n\n\t\treturn data ? data.outlines[property] : [];\n\t}\n\tpublic getEdgeIndex(cursor: CursorType, start: number, end: number) {\n\t\tconst prop = cursor === \"start\" ? \"min\" : \"max\";\n\t\tlet index = -1;\n\t\tlet targetValue = cursor === \"start\" ? Infinity : -Infinity;\n\n\t\tfor (let i = start; i <= end; i++) {\n\t\t\tconst value = Math[prop](...this.getOutline(i, cursor));\n\n\t\t\tif ((cursor === \"start\" && targetValue > value) ||\n\t\t\t\t(cursor === \"end\" && targetValue < value)) {\n\t\t\t\ttargetValue = value;\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\tpublic getEdgeValue(cursor: CursorType, start: number, end: number) {\n\t\tconst outlines = this.pluck(\"outlines\", this.getEdgeIndex(cursor, start, end))\n\t\t\t.reduce<number[]>((acc, v) => acc.concat(v[cursor]), []);\n\n\t\treturn outlines.length ? Math[cursor === \"start\" ? \"min\" : \"max\"](...outlines) : 0;\n\t}\n\tpublic clearOutlines(startCursor = -1, endCursor = -1) {\n\t\tconst datas = this.get();\n\n\t\tdatas.forEach((group, cursor) => {\n\t\t\tif (startCursor <= cursor && cursor <= endCursor) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tgroup.items.forEach(item => {\n\t\t\t\titem.rect.top = DUMMY_POSITION;\n\t\t\t\titem.rect.left = DUMMY_POSITION;\n\t\t\t});\n\t\t\tgroup.outlines.start = [];\n\t\t\tgroup.outlines.end = [];\n\t\t});\n\t}\n\tpublic getMaxEdgeValue() {\n\t\tconst groups = this.get();\n\t\tconst length = groups.length;\n\n\t\tfor (let i = length - 1; i >= 0; --i) {\n\t\t\tconst end = groups[i].outlines.end;\n\n\t\t\tif (end.length) {\n\t\t\t\tconst pos = Math.max(...end);\n\n\t\t\t\treturn pos;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tpublic append(layouted: IInfiniteGridGroup) {\n\t\tthis._data.push(layouted);\n\t\treturn layouted.items;\n\t}\n\tpublic prepend(layouted: IInfiniteGridGroup) {\n\t\tthis._data.unshift(layouted);\n\t\treturn layouted.items;\n\t}\n\tpublic clear() {\n\t\tthis._data = [];\n\t}\n\tpublic remove(element: HTMLElement, start: number, end: number) {\n\t\tlet items: IInfiniteGridItem[] = [];\n\t\tlet groups: IInfiniteGridGroup[] = [];\n\t\tconst key = element.getAttribute(GROUPKEY_ATT);\n\t\tconst datas = this.get(start, end)\n\t\t\t.filter(v => String(v.groupKey) === key);\n\n\t\tif (!datas.length) {\n\t\t\treturn { items, groups };\n\t\t}\n\t\tconst data = datas[0];\n\n\t\tconst length = data.items.length;\n\t\tlet idx = -1;\n\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tif (data.items[i].el === element) {\n\t\t\t\tidx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\t// remove item information\n\t\t\titems = data.items.splice(idx, 1);\n\n\t\t\tif (!data.items.length) {\n\t\t\t\tthis._data.splice(this.indexOf(data), 1);\n\t\t\t\tgroups = [data];\n\t\t\t} else {\n\t\t\t\tthis.set(data, key);\n\t\t\t}\n\t\t}\n\t\treturn { items, groups };\n\t}\n\tpublic indexOf(data: IInfiniteGridGroup | string | number) {\n\t\tconst groupKey = typeof data === \"object\" ? data.groupKey : data;\n\t\tconst datas = this._data;\n\t\tconst length = datas.length;\n\n\t\tfor (let i = 0; i < length; ++i) {\n\t\t\tif (groupKey === datas[i].groupKey) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tpublic get(start?: number, end?: number) {\n\t\treturn isUndefined(start) ? this._data :\n\t\t\tthis._data.slice(start, (isUndefined(end) ? start : end) + 1);\n\t}\n\tpublic set(data: IInfiniteGridGroup | IInfiniteGridGroup[], key?: string | number) {\n\t\tif (!Array.isArray(data)) {\n\t\t\tif (!isUndefined(key)) {\n\t\t\t\tconst len = this._data.length;\n\t\t\t\tlet idx = -1;\n\n\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\tif (this._data[i].groupKey === key) {\n\t\t\t\t\t\tidx = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tidx > 0 && (this._data[idx] = data);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._data = data.concat();\n\t\t}\n\t}\n\tpublic getData(index: number) {\n\t\treturn this._data[index];\n\t}\n}\n","import {\n\tAPPEND,\n\tPREPEND,\n\tDUMMY_POSITION,\n\tMULTI,\n\tGROUPKEY_ATT,\n\tCONTAINER_CLASSNAME,\n\tTRANSITION_NAME,\n\tTRANSITION,\n\tTRANSITION_END,\n\tTRANSFORM,\n} from \"./consts\";\nimport { window, document } from \"./browser\";\nimport {\n\t$,\n\tinnerHeight,\n\tinnerWidth,\n\tgetSize,\n\tgetStyles,\n\taddOnceEvent,\n\tassign,\n} from \"./utils\";\nimport { RectType, IPosition, ISize, IJQuery, IInfiniteGridItem, WindowMockType, IDOMRendererStatus, IDOMRendererSize } from \"./types\";\n\nexport function resetSize(item: IInfiniteGridItem) {\n\titem.orgSize = null;\n\titem.size = null;\n}\nexport interface IDOMRendererOptions {\n\tisEqualSize: boolean;\n\tisConstantSize: boolean;\n\thorizontal: boolean;\n\tcontainer: boolean | HTMLElement;\n}\n\nexport interface IDOMRendererOrgStyle {\n\tposition?: CSSStyleDeclaration[\"position\"];\n\toverflowX?: CSSStyleDeclaration[\"overflowX\"];\n\toverflowY?: CSSStyleDeclaration[\"overflowY\"];\n}\n\nfunction createContainer(element: HTMLElement) {\n\tconst container = document.createElement(\"div\");\n\n\tcontainer.className = CONTAINER_CLASSNAME;\n\tcontainer.style.position = \"relative\";\n\tcontainer.style.height = \"100%\";\n\n\tconst children = element.children;\n\tconst length = children.length;\t// for IE8\n\n\tfor (let i = 0; i < length; i++) {\n\t\tcontainer.appendChild(children[0]);\n\t}\n\telement.appendChild(container);\n\treturn container;\n}\nfunction render(properties: RectType[], rect: IInfiniteGridItem[\"rect\"], styles: HTMLElement[\"style\"]) {\n\tproperties.forEach(p => {\n\t\t(p in rect) && (styles[p] = `${rect[p]}px`);\n\t});\n}\nfunction setTransition(styles: HTMLElement[\"style\"], transitionDuration?: number, pos1?: IPosition, pos2?: IPosition) {\n\tstyles[`${TRANSITION}-property`] = transitionDuration ? `${TRANSFORM},width,height` : \"\";\n\tstyles[`${TRANSITION}-duration`] = transitionDuration ? `${transitionDuration}s` : \"\";\n\tstyles[`${TRANSITION}-delay`] = transitionDuration ? `0s` : \"\";\n\tstyles[TRANSFORM] = transitionDuration ? `translate(${pos1.left - pos2.left}px,${pos1.top - pos2.top}px)` : \"\";\n}\n\nexport default class DOMRenderer {\n\tpublic static renderItem(item: IInfiniteGridItem, rect: IInfiniteGridItem[\"rect\"], transitionDuration?: number) {\n\t\tif (!item.el) {\n\t\t\treturn;\n\t\t}\n\t\tconst { el, prevRect } = item;\n\t\tconst styles = el.style;\n\n\t\t// for debugging\n\t\tel.setAttribute(GROUPKEY_ATT, `${item.groupKey}`);\n\t\tstyles.position = \"absolute\";\n\t\trender([\"width\", \"height\"], rect, styles);\n\t\tif (transitionDuration && TRANSITION && prevRect) {\n\t\t\tsetTransition(styles, transitionDuration, rect as IPosition, prevRect as IPosition);\n\t\t\tif ((el as any)[TRANSITION_NAME]) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tel[TRANSITION_NAME] = true;\n\t\t\taddOnceEvent(el, TRANSITION_END, () => {\n\t\t\t\tconst itemRect = item.rect;\n\n\t\t\t\tsetTransition(styles);\n\t\t\t\trender([\"left\", \"top\"], itemRect, styles);\n\t\t\t\titem.prevRect = itemRect;\n\t\t\t\tel[TRANSITION_NAME] = false;\n\t\t\t});\n\t\t} else {\n\t\t\trender([\"left\", \"top\"], rect, styles);\n\t\t\titem.prevRect = rect;\n\t\t}\n\t}\n\tpublic static renderItems(items: IInfiniteGridItem[], transitionDuration?: number) {\n\t\titems.forEach(item => {\n\t\t\tDOMRenderer.renderItem(item, item.rect, transitionDuration);\n\t\t});\n\t}\n\tpublic static removeItems(items: IInfiniteGridItem[]) {\n\t\titems.forEach(item => {\n\t\t\tif (item.el) {\n\t\t\t\tDOMRenderer.removeElement(item.el);\n\t\t\t\titem.el = null;\n\t\t\t}\n\t\t});\n\t}\n\tpublic static removeElement(element: HTMLElement) {\n\t\tconst parentNode = element && element.parentNode;\n\n\t\tif (!parentNode) {\n\t\t\treturn;\n\t\t}\n\t\tparentNode.removeChild(element);\n\t}\n\tpublic static createElements(items: IInfiniteGridItem[]) {\n\t\tif (!items.length) {\n\t\t\treturn;\n\t\t}\n\t\tconst noElementItems = items.filter(item => !item.el);\n\n\t\tif (!noElementItems.length) {\n\t\t\treturn;\n\t\t}\n\t\tconst elements = $(noElementItems.map(({ content }) =>\n\t\t\tcontent.replace(/^[\\s\\uFEFF]+|[\\s\\uFEFF]+$/g, \"\")).join(\"\"), MULTI);\n\n\t\tnoElementItems.forEach((item, index) => {\n\t\t\titem.el = elements[index];\n\t\t});\n\t}\n\tpublic container: HTMLElement;\n\tpublic view: WindowMockType | HTMLElement;\n\tpublic options: IDOMRendererOptions = {\n\t\tisEqualSize: false,\n\t\tisConstantSize: false,\n\t\thorizontal: false,\n\t\tcontainer: false,\n\t};\n\tpublic _size: IDOMRendererSize = {\n\t\tcontainer: -1,\n\t\tview: -1,\n\t\tviewport: -1,\n\t\titem: null,\n\t};\n\tpublic _orgStyle: IDOMRendererOrgStyle = {};\n\tconstructor(element: string | HTMLElement | IJQuery, options: IDOMRendererOptions) {\n\t\tassign(this.options, options);\n\t\tthis._init(element);\n\t\tthis.resize();\n\t}\n\tpublic getStatus() {\n\t\treturn {\n\t\t\tcssText: this.container.style.cssText,\n\t\t\t_size: assign({}, this._size),\n\t\t};\n\t}\n\tpublic setStatus(status: IDOMRendererStatus) {\n\t\tthis.container.style.cssText = status.cssText;\n\t\tassign(this._size, status._size);\n\t}\n\tpublic updateSize(items: IInfiniteGridItem[]) {\n\t\tconst { isEqualSize, isConstantSize } = this.options;\n\t\tconst size = this._size;\n\n\t\treturn items.map(item => {\n\t\t\tif (!item.el) {\n\t\t\t\treturn item;\n\t\t\t}\n\t\t\tif (isEqualSize && !size.item) {\n\t\t\t\tsize.item = getSize(item.el);\n\t\t\t}\n\t\t\titem.size = (isEqualSize && assign({}, size.item)) ||\n\t\t\t\t(isConstantSize && item.orgSize && assign({}, item.orgSize)) ||\n\t\t\t\tgetSize(item.el);\n\t\t\tif (!item.orgSize) {\n\t\t\t\titem.orgSize = assign({}, item.size);\n\t\t\t}\n\t\t\treturn item;\n\t\t});\n\t}\n\tpublic append(items: IInfiniteGridItem[]) {\n\t\tthis._insert(items, APPEND, {\n\t\t\ttop: DUMMY_POSITION,\n\t\t\tleft: DUMMY_POSITION,\n\t\t});\n\t}\n\tpublic prepend(items: IInfiniteGridItem[]) {\n\t\tthis._insert(items, PREPEND, {\n\t\t\ttop: DUMMY_POSITION,\n\t\t\tleft: DUMMY_POSITION,\n\t\t});\n\t}\n\tpublic createAndInsert(items: IInfiniteGridItem[], isAppend?: boolean) {\n\t\tDOMRenderer.createElements(items);\n\n\t\tDOMRenderer.renderItems(items);\n\t\tthis._insert(items, isAppend);\n\t}\n\tpublic getViewSize() {\n\t\treturn this._size.view;\n\t}\n\tpublic getViewportSize() {\n\t\treturn this._size.viewport;\n\t}\n\tpublic getContainerSize() {\n\t\treturn this._size.container;\n\t}\n\tpublic setContainerSize(size: number) {\n\t\tthis._size.container = size;\n\t\tthis.container.style[this.options.horizontal ? \"width\" : \"height\"] = `${size}px`;\n\t}\n\tpublic resize() {\n\t\tconst horizontal = this.options.horizontal;\n\t\tconst view = this.view;\n\t\tconst size = this._calcSize();\n\n\t\tif (size === 0) {\n\t\t\treturn;\n\t\t}\n\t\tconst isResize = size !== this._size.viewport;\n\n\t\tif (isResize) {\n\t\t\tthis._size = {\n\t\t\t\tviewport: size,\n\t\t\t\titem: null,\n\t\t\t};\n\t\t}\n\t\tthis._size.view = horizontal ? innerWidth(view) : innerHeight(view);\n\t\treturn isResize;\n\t}\n\tpublic isNeededResize() {\n\t\treturn this._calcSize() !== this._size.viewport;\n\t}\n\tpublic clear() {\n\t\tthis.container.innerHTML = \"\";\n\t\tthis.container.style[this.options.horizontal ? \"width\" : \"height\"] = \"\";\n\n\t\tthis._size = {\n\t\t\titem: null,\n\t\t\tviewport: -1,\n\t\t\tcontainer: -1,\n\t\t\tview: -1,\n\t\t};\n\t}\n\tpublic destroy() {\n\t\tthis.clear();\n\t\tconst container = this.options.container;\n\n\t\tfor (const p in this._orgStyle) {\n\t\t\t(this[container ? \"view\" : \"container\"] as HTMLElement).style[p as keyof IDOMRendererOrgStyle] =\n\t\t\t\tthis._orgStyle[p as keyof IDOMRendererOrgStyle];\n\t\t}\n\t\tcontainer && this.container.parentNode.removeChild(this.container);\n\t}\n\tprivate _init(el: HTMLElement | IJQuery | string) {\n\t\tconst element = $(el);\n\t\tconst style = getStyles(element);\n\t\tconst { container, horizontal } = this.options;\n\n\t\tif (style.position === \"static\") {\n\t\t\tthis._orgStyle.position = element.style.position;\n\t\t\telement.style.position = \"relative\";\n\t\t}\n\t\tif (container) {\n\t\t\tconst target = horizontal ? [\"X\", \"Y\"] : [\"Y\", \"X\"];\n\n\t\t\tthis._orgStyle.overflowX = element.style.overflowX;\n\t\t\tthis._orgStyle.overflowY = element.style.overflowY;\n\t\t\telement.style[`overflow${target[0]}` as \"overflowX\" | \"overflowY\"] = \"scroll\";\n\t\t\telement.style[`overflow${target[1]}` as \"overflowX\" | \"overflowY\"] = \"hidden\";\n\t\t\tthis.view = element;\n\t\t\tthis.container = container === true ? createContainer(this.view as HTMLElement) : container;\n\t\t} else {\n\t\t\tthis.view = window;\n\t\t\tthis.container = element;\n\t\t}\n\t}\n\tprivate _insert(items: IInfiniteGridItem[], isAppend?: boolean, styles?: IInfiniteGridItem[\"rect\"]) {\n\t\tconst container = this.container;\n\t\tconst df = document.createDocumentFragment();\n\n\t\titems.forEach(item => {\n\t\t\tstyles && DOMRenderer.renderItem(item, styles);\n\t\t\tisAppend ? df.appendChild(item.el) : df.insertBefore(item.el, df.firstChild);\n\t\t});\n\t\tisAppend ?\n\t\t\tcontainer.appendChild(df) :\n\t\t\tcontainer.insertBefore(df, container.firstChild);\n\t}\n\tprivate _calcSize() {\n\t\treturn this.options.horizontal ?\n\t\t\tinnerHeight(this.container) : innerWidth(this.container);\n\t}\n}\n","import {\n\tIS_IOS,\n} from \"./consts\";\nimport {\n\twindow,\n} from \"./browser\";\nimport {\n\taddEvent,\n\tremoveEvent,\n\tscroll,\n\tscrollTo,\n\tscrollBy,\n\tassign,\n} from \"./utils\";\nimport { WindowMockType, IWatchStatus } from \"./types\";\n\nexport interface IWatcherOptions {\n\tcontainer: HTMLElement;\n\tisOverflowScroll: boolean;\n\thorizontal: boolean;\n\tresize: () => void;\n\tcheck: (e?: {\n\t\tisForward: boolean,\n\t\tscrollPos: number,\n\t\torgScrollPos: number,\n\t\thorizontal: boolean,\n\t}) => void;\n}\n\nexport default class Watcher {\n\tpublic options: IWatcherOptions;\n\tprivate _timer: {\n\t\tresize: any;\n\t};\n\tprivate _containerOffset: number;\n\tprivate _view: WindowMockType | HTMLElement;\n\tprivate _isScrollIssue: boolean;\n\tprivate _prevPos: number;\n\tconstructor(view: WindowMockType | HTMLElement, options: Partial<IWatcherOptions> = {}) {\n\t\tassign(this.options = {\n\t\t\tcontainer: view as HTMLElement,\n\t\t\tresize: () => void 0,\n\t\t\tcheck: () => void 0,\n\t\t\tisOverflowScroll: false,\n\t\t\thorizontal: false,\n\t\t}, options);\n\t\tthis._timer = {\n\t\t\tresize: null,\n\t\t};\n\t\tthis.reset();\n\t\tthis._containerOffset = 0;\n\t\tthis._view = view;\n\t\tthis._isScrollIssue = IS_IOS;\n\t\tthis._onCheck = this._onCheck.bind(this);\n\t\tthis._onResize = this._onResize.bind(this);\n\t\tthis.attachEvent();\n\t\tthis.resize();\n\t\tthis.setScrollPos();\n\t}\n\tpublic getStatus(): IWatchStatus {\n\t\treturn {\n\t\t\t_prevPos: this._prevPos,\n\t\t\tscrollPos: this.getOrgScrollPos(),\n\t\t};\n\t}\n\tpublic setStatus(status: IWatchStatus, applyScrollPos = true) {\n\t\tthis._prevPos = status._prevPos;\n\t\tapplyScrollPos && this.scrollTo(status.scrollPos);\n\t}\n\tpublic scrollBy(pos: number) {\n\t\tconst arrPos = this.options.horizontal ? [pos, 0] : [0, pos];\n\n\t\tscrollBy(this._view, arrPos[0], arrPos[1]);\n\t\tthis.setScrollPos();\n\t}\n\tpublic scrollTo(pos: number) {\n\t\tconst arrPos = this.options.horizontal ? [pos, 0] : [0, pos];\n\n\t\tscrollTo(this._view, arrPos[0], arrPos[1]);\n\t}\n\tpublic getScrollPos() {\n\t\treturn this._prevPos;\n\t}\n\tpublic setScrollPos(pos = this.getOrgScrollPos()) {\n\t\tlet rawPos = pos;\n\n\t\tif (typeof pos === \"undefined\") {\n\t\t\trawPos = this.getOrgScrollPos();\n\t\t}\n\t\tthis._prevPos = rawPos - this.getContainerOffset();\n\t}\n\tpublic attachEvent() {\n\t\taddEvent(this._view, \"scroll\", this._onCheck);\n\t\taddEvent(window, \"resize\", this._onResize);\n\t}\n\tpublic getOrgScrollPos() {\n\t\treturn scroll(this._view, this.options.horizontal);\n\t}\n\tpublic reset() {\n\t\tthis._prevPos = null;\n\t}\n\tpublic getContainerOffset() {\n\t\treturn this._containerOffset;\n\t}\n\tpublic resize() {\n\t\tthis._containerOffset = this.options.isOverflowScroll ? 0 : this._getOffset();\n\t}\n\tpublic detachEvent() {\n\t\tremoveEvent(this._view, \"scroll\", this._onCheck);\n\t\tremoveEvent(window, \"resize\", this._onResize);\n\t}\n\tpublic destroy() {\n\t\tthis.detachEvent();\n\t\tthis.reset();\n\t}\n\tprivate _onCheck() {\n\t\tconst prevPos = this.getScrollPos();\n\t\tconst orgScrollPos = this.getOrgScrollPos();\n\n\t\tthis.setScrollPos(orgScrollPos);\n\t\tconst scrollPos = this.getScrollPos();\n\n\t\tif (prevPos === null || (this._isScrollIssue && orgScrollPos === 0) || prevPos === scrollPos) {\n\t\t\torgScrollPos && (this._isScrollIssue = false);\n\t\t\treturn;\n\t\t}\n\t\tthis._isScrollIssue = false;\n\t\tthis.options.check({\n\t\t\tisForward: prevPos < scrollPos,\n\t\t\tscrollPos,\n\t\t\torgScrollPos,\n\t\t\thorizontal: this.options.horizontal,\n\t\t});\n\t}\n\tprivate _getOffset() {\n\t\tconst { container, horizontal } = this.options;\n\t\tconst rect = container.getBoundingClientRect();\n\n\t\treturn rect[horizontal ? \"left\" : \"top\"] + this.getOrgScrollPos();\n\t}\n\tprivate _onResize() {\n\t\tif (this._timer.resize) {\n\t\t\tclearTimeout(this._timer.resize);\n\t\t}\n\t\tthis._timer.resize = setTimeout(() => {\n\t\t\tthis.resize();\n\t\t\tthis.options.resize();\n\t\t\tthis._timer.resize = null;\n\t\t\tthis.reset();\n\t\t}, 100);\n\t}\n\n}\n","import ItemManager from \"./ItemManager\";\nimport { assign } from \"./utils\";\nimport { CursorType, IInfiniteGridItem, IInfiniteGridGroup, IInfiniteStatus } from \"./types\";\n\nfunction isVisible(group: IInfiniteGridGroup, threshold: number, scrollPos: number, endScrollPos: number) {\n\tconst { items, outlines } = group;\n\tconst start = outlines.start;\n\tconst end = outlines.end;\n\n\tif (start.length === 0 || end.length === 0 || !items.length || !items[0].el) {\n\t\treturn 2;\n\t}\n\tconst min = Math.min(...start);\n\tconst max = Math.max(...end);\n\n\tif ((endScrollPos + threshold < min)) {\n\t\treturn +1;\n\t} else if ((scrollPos - threshold > max)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nexport interface IInfiniteOptions {\n\tuseRecycle?: boolean;\n\tthreshold?: number;\n\tappend?: (e?: { cache: IInfiniteGridGroup[] }) => void;\n\tprepend?: (e?: { cache: IInfiniteGridGroup[] }) => void;\n\trecycle?: (e?: { start: number, end: number }) => void;\n}\nclass Infinite {\n\tpublic options: Required<IInfiniteOptions>;\n\tprivate _items: ItemManager;\n\tprivate _status: IInfiniteStatus;\n\tconstructor(itemManger: ItemManager, options: IInfiniteOptions) {\n\t\tthis.options = assign({\n\t\t\tuseRecycle: true,\n\t\t\tthreshold: 100,\n\t\t\tappend: () => void 0,\n\t\t\tprepend: () => void 0,\n\t\t\trecycle: () => void 0,\n\t\t}, options);\n\n\t\tthis._items = itemManger;\n\t\tthis.clear();\n\t}\n\tpublic setSize(size: number) {\n\t\tthis._status.size = size;\n\t}\n\tpublic recycle(scrollPos: number, isForward?: boolean) {\n\t\tif (!this.options.useRecycle) {\n\t\t\treturn;\n\t\t}\n\t\tconst { startCursor, endCursor, size } = this._status;\n\n\t\tif (startCursor === -1 || endCursor === -1) {\n\t\t\treturn;\n\t\t}\n\t\tconst endScrollPos = scrollPos + size;\n\t\tconst { threshold, recycle } = this.options;\n\t\tconst visibles = this._items.get(startCursor, endCursor)\n\t\t\t.map(group => isVisible(group, threshold, scrollPos, endScrollPos));\n\t\tconst length = visibles.length;\n\t\tlet start = isForward ? 0 : visibles.lastIndexOf(0);\n\t\tlet end = isForward ? visibles.indexOf(0) - 1 : visibles.length - 1;\n\n\t\tif (!isForward && start !== -1) {\n\t\t\tstart += 1;\n\t\t}\n\t\tif (start < 0 || end < 0 || start > end || end - start + 1 >= length) {\n\t\t\treturn;\n\t\t}\n\t\tstart = startCursor + start;\n\t\tend = startCursor + end;\n\n\t\trecycle({ start, end });\n\t\tif (isForward) {\n\t\t\tthis.setCursor(\"start\", end + 1);\n\t\t} else {\n\t\t\tthis.setCursor(\"end\", start - 1);\n\t\t}\n\t}\n\tpublic scroll(scrollPos: number) {\n\t\tconst startCursor = this.getCursor(\"start\");\n\t\tconst endCursor = this.getCursor(\"end\");\n\t\tconst items = this._items;\n\n\t\tif (typeof scrollPos !== \"number\" || startCursor === -1 ||\n\t\t\tendCursor === -1 || !items.size()) {\n\t\t\treturn;\n\t\t}\n\t\tconst size = this._status.size;\n\t\tconst { threshold, append, prepend } = this.options;\n\t\tconst datas = items.get();\n\t\tconst endScrollPos = scrollPos + size;\n\t\tconst startEdgePos = Math.max(...datas[startCursor].outlines.start);\n\t\tconst endEdgePos = Math.min(...datas[endCursor].outlines.end);\n\t\tconst visibles = datas.map((group, i) => {\n\t\t\tconst { start, end } = group.outlines;\n\n\t\t\tif (!start.length || !end.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tconst startPos = Math.min(...start);\n\t\t\tconst endPos = Math.max(...end);\n\n\t\t\tif (startPos - threshold <= endScrollPos && scrollPos <= endPos + threshold) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t\tconst startIndex = visibles.indexOf(true);\n\t\tconst endIndex = visibles.lastIndexOf(true);\n\n\t\tif (~startIndex && startIndex < startCursor) {\n\t\t\tprepend({ cache: datas.slice(startIndex, Math.min(startCursor, endIndex + 1)) });\n\t\t} else if (endCursor < endIndex) {\n\t\t\tappend({ cache: datas.slice(Math.max(startIndex, endCursor + 1), endIndex + 1) });\n\t\t} else if (endScrollPos >= endEdgePos - threshold) {\n\t\t\tappend({ cache: datas.slice(endCursor + 1, endCursor + 2) });\n\t\t} else if (scrollPos <= startEdgePos + threshold) {\n\t\t\tprepend({ cache: datas.slice(startCursor - 1, startCursor) });\n\t\t}\n\t}\n\tpublic setCursor(cursor: CursorType, index: number) {\n\t\tconst status = this._status;\n\t\tconst items = this._items;\n\t\tconst size = items.size();\n\n\t\tif (!this.options.useRecycle) {\n\t\t\tstatus.startCursor = 0;\n\t\t\tif (items.getOutline(size - 1, \"end\").length) {\n\t\t\t\tstatus.endCursor = size - 1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (cursor !== \"end\") {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (cursor === \"start\") {\n\t\t\tstatus.startCursor = index;\n\t\t} else {\n\t\t\tstatus.endCursor = Math.min(size - 1, index);\n\t\t}\n\t\tstatus.startCursor = Math.max(0, status.startCursor);\n\t}\n\tpublic setStatus(status: IInfiniteStatus) {\n\t\tthis._status = assign(this._status, status);\n\t}\n\tpublic getStatus(startKey: string | number, endKey: string | number): IInfiniteStatus {\n\t\tconst { startCursor, endCursor, size } = this._status;\n\t\tconst startIndex = Math.max(this._items.indexOf(startKey), 0);\n\t\tconst endIndex = (this._items.indexOf(endKey) + 1 || this._items.size()) - 1;\n\t\tconst start = Math.max(startCursor - startIndex, ~startCursor ? 0 : -1);\n\t\tconst end = Math.max(Math.min(endCursor - startIndex, endIndex - startIndex), start);\n\n\t\treturn {\n\t\t\tstartCursor: start,\n\t\t\tendCursor: end,\n\t\t\tsize,\n\t\t};\n\t}\n\tpublic getEdgeOutline(cursor: CursorType) {\n\t\tconst { startCursor, endCursor } = this._status;\n\n\t\tif (startCursor === -1 || endCursor === -1) {\n\t\t\treturn [];\n\t\t}\n\t\treturn this._items.getOutline(cursor === \"start\" ? startCursor : endCursor, cursor);\n\t}\n\tpublic getEdgeValue(cursor: CursorType) {\n\t\tconst outlines = this.getEdgeOutline(cursor);\n\n\t\treturn outlines.length ? Math[cursor === \"start\" ? \"min\" : \"max\"](...outlines) : 0;\n\t}\n\tpublic getVisibleItems() {\n\t\treturn this._items.pluck(\"items\", this._status.startCursor, this._status.endCursor);\n\t}\n\tpublic getCursor(cursor: CursorType) {\n\t\treturn this._status[cursor === \"start\" ? \"startCursor\" : \"endCursor\"];\n\t}\n\tpublic getVisibleData() {\n\t\treturn this._items.get(this._status.startCursor, this._status.endCursor);\n\t}\n\tpublic remove(element: HTMLElement): {\n\t\titems: IInfiniteGridItem[],\n\t\tgroups: IInfiniteGridGroup[],\n\t} {\n\t\tconst { startCursor, endCursor } = this._status;\n\t\tconst result =\n\t\t\tthis._items.remove(element, startCursor, endCursor);\n\n\t\tif (result.groups.length) {\n\t\t\tthis.setCursor(\"end\", endCursor - 1);\n\t\t}\n\t\tif (!this._items.size()) {\n\t\t\tthis._status.startCursor = -1;\n\t\t\tthis._status.endCursor = -1;\n\t\t}\n\t\treturn result;\n\t}\n\tpublic clear() {\n\t\tthis._status = {\n\t\t\tstartCursor: -1,\n\t\t\tendCursor: -1,\n\t\t\tsize: -1,\n\t\t};\n\t}\n}\n\nexport default Infinite;\n","import { window } from \"./browser\";\nimport { addEvent, removeEvent, innerWidth, innerHeight } from \"./utils\";\n\nconst elements: HTMLElement[] = [];\n\nfunction onResize() {\n\tAutoSizer.resizeAll();\n}\nexport interface IAutoSizierElemenet extends HTMLElement {\n\t__PREFIX__?: string;\n}\nexport default class AutoSizer {\n\tpublic static add(element: IAutoSizierElemenet, prefix = \"data-\") {\n\t\tif (!elements.length) {\n\t\t\taddEvent(window, \"resize\", onResize);\n\t\t}\n\t\telement.__PREFIX__ = prefix;\n\t\telements.push(element);\n\t\tAutoSizer.resize(element);\n\t}\n\tpublic static remove(element: IAutoSizierElemenet, isFixed = false) {\n\t\tconst fixed = element.getAttribute(`${element.__PREFIX__}fixed`) || \"width\";\n\n\t\tif (!isFixed) {\n\t\t\telement.style[fixed === \"width\" ? \"height\" : \"width\"] = \"\";\n\t\t}\n\t\tconst index = elements.indexOf(element);\n\n\t\tif (index < 0) {\n\t\t\treturn;\n\t\t}\n\t\telements.splice(index, 1);\n\t\tif (!elements.length) {\n\t\t\tremoveEvent(window, \"reisze\", onResize);\n\t\t}\n\t}\n\tpublic static resize(element: IAutoSizierElemenet, prefix = \"data-\") {\n\t\tconst elementPrefix = typeof element.__PREFIX__ === \"string\" ? element.__PREFIX__ : prefix;\n\t\tconst dataWidth = parseInt(element.getAttribute(`${elementPrefix}width`), 10) || 0;\n\t\tconst dataHeight = parseInt(element.getAttribute(`${elementPrefix}height`), 10) || 0;\n\t\tconst fixed = element.getAttribute(`${elementPrefix}fixed`);\n\n\t\tif (fixed === \"height\") {\n\t\t\tconst size = innerHeight(element) || dataHeight;\n\n\t\t\telement.style.width = `${dataWidth / dataHeight * size}px`;\n\t\t} else {\n\t\t\tconst size = innerWidth(element) || dataWidth;\n\n\t\t\telement.style.height = `${dataHeight / dataWidth * size}px`;\n\t\t}\n\t}\n\tpublic static resizeAll() {\n\t\telements.forEach(element => AutoSizer.resize(element));\n\t}\n}\n","import { IS_IE } from \"./consts\";\nimport { addEvent, removeEvent, toArray } from \"./utils\";\nimport AutoSizer from \"./AutoSizer\";\n\nexport const CHECK_ALL: 1 = 1;\nexport const CHECK_ONLY_ERROR: 2 = 2;\n\nexport interface IImageLoadedOptions {\n\tprefix?: string;\n\tlength?: number;\n\ttype?: 1 | 2;\n\tcomplete?: () => void;\n\tend?: () => void;\n\terror?: (e: { target: LoadingImageElement, itemIndex: number }) => void;\n}\nexport interface LoadingImageElement extends HTMLImageElement {\n\t__ITEM_INDEX__?: number;\n}\n\nfunction isDataAttribute(target: HTMLElement, prefix: string) {\n\treturn !!target.getAttribute(`${prefix}width`);\n}\n\nclass ImageLoaded {\n\tpublic static CHECK_ALL = 1;\n\tpublic static CHECK_ONLY_ERROR = 2;\n\tpublic static waitImageLoaded(\n\t\tchecklist: LoadingImageElement[][],\n\t\t{ prefix = \"\", length, type, complete, error, end }: IImageLoadedOptions,\n\t) {\n\t\tlet checkCount = 0;\n\t\tlet endCount = length;\n\n\t\tif (type !== CHECK_ONLY_ERROR) {\n\t\t\tcheckCount = endCount;\n\t\t}\n\t\tconst checkEnd = () => {\n\t\t\tif (--endCount !== 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tend && end();\n\t\t};\n\t\tconst checkImage = () => {\n\t\t\tcheckCount--;\n\t\t\tif (checkCount !== 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcomplete && complete();\n\t\t};\n\t\tconst onError = (target: LoadingImageElement, itemIndex = target.__ITEM_INDEX__) => {\n\t\t\terror && error({\n\t\t\t\ttarget,\n\t\t\t\titemIndex,\n\t\t\t});\n\t\t};\n\t\tconst onCheck = (e: Event) => {\n\t\t\tconst target = (e.target || e.srcElement) as LoadingImageElement;\n\n\t\t\tremoveEvent(target, \"error\", onCheck);\n\t\t\tremoveEvent(target, \"load\", onCheck);\n\n\t\t\tif (type === CHECK_ALL && isDataAttribute(target, prefix)) {\n\t\t\t\tAutoSizer.remove(target, e.type === \"error\");\n\t\t\t} else {\n\t\t\t\tcheckImage();\n\t\t\t}\n\t\t\tif (e.type === \"error\") {\n\t\t\t\tonError(target);\n\t\t\t}\n\t\t\tdelete target.__ITEM_INDEX__;\n\t\t\tcheckEnd();\n\t\t};\n\n\t\tchecklist.forEach((images, i) => {\n\t\t\timages.forEach(v => {\n\t\t\t\t// workaround for IE\n\t\t\t\tif (v.complete && (!IS_IE || (IS_IE && v.naturalWidth))) {\n\t\t\t\t\tif (!v.naturalWidth) {\n\t\t\t\t\t\tonError(v, i);\n\t\t\t\t\t}\n\t\t\t\t\tcheckImage();\n\t\t\t\t\tcheckEnd();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tv.__ITEM_INDEX__ = i;\n\t\t\t\tif (type === CHECK_ALL && isDataAttribute(v, prefix)) {\n\t\t\t\t\tAutoSizer.add(v, prefix);\n\t\t\t\t\tcheckImage();\n\t\t\t\t}\n\t\t\t\taddEvent(v, \"load\", onCheck);\n\t\t\t\taddEvent(v, \"error\", onCheck);\n\n\t\t\t\tIS_IE && v.setAttribute(\"src\", v.getAttribute(\"src\"));\n\t\t\t});\n\t\t});\n\t}\n\tpublic static checkImageLoaded(el: HTMLElement) {\n\t\tif (el.tagName === \"IMG\") {\n\t\t\treturn (el as HTMLImageElement).complete ? [] : [(el as HTMLImageElement)];\n\t\t} else {\n\t\t\treturn toArray(el.querySelectorAll(\"img\"));\n\t\t}\n\t}\n\tpublic static check(\n\t\telements: HTMLElement[],\n\t\t{ prefix, type = CHECK_ALL, complete, error, end }: IImageLoadedOptions,\n\t) {\n\t\tconst images = elements.map(element => this.checkImageLoaded(element));\n\t\tconst length = images.reduce((sum, element) => sum + element.length, 0);\n\n\t\tif (type === CHECK_ONLY_ERROR || length === 0) {\n\t\t\t// convert to async\n\t\t\tsetTimeout(() => {\n\t\t\t\tcomplete && complete();\n\t\t\t\tif (length === 0) {\n\t\t\t\t\tend && end();\n\t\t\t\t}\n\t\t\t}, 0);\n\t\t}\n\t\tif (length > 0) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tthis.waitImageLoaded(images, { prefix, length, type, complete, error, end });\n\t\t\t}, 0);\n\t\t}\n\t}\n}\n\nexport default ImageLoaded;\n","import AutoSizer from \"./AutoSizer\";\nimport ImageLoaded, { CHECK_ALL, CHECK_ONLY_ERROR } from \"./ImageLoaded\";\nimport ItemManager from \"./ItemManager\";\nimport { matchHTML, $, assign } from \"./utils\";\nimport { DUMMY_POSITION } from \"./consts\";\nimport DOMRenderer from \"./DOMRenderer\";\nimport { ILayout, ILayoutResult, IInfiniteGridItem, IInfiniteGridGroup, IErrorCallbackOptions } from \"./types\";\n\nfunction hasTarget<T>(target: T[], value: T) {\n\treturn ~target.indexOf(value);\n}\n\nexport interface ILayoutManagerOptions {\n\tattributePrefix?: string;\n\tisEqualSize?: boolean;\n\tisConstantSize?: boolean;\n\thorizontal?: boolean;\n}\n\nexport interface ICompleteCallbackOptions {\n\tgroups?: ILayoutResult[];\n\titems?: IInfiniteGridItem[];\n\tisAppend?: boolean;\n}\nexport interface IEndCallbackOptions {\n\tremove: HTMLElement[];\n\tlayout?: boolean;\n}\nexport interface ILayoutManagerCallbacks {\n\tcomplete: (e: ICompleteCallbackOptions) => void;\n\terror: (e: IErrorCallbackOptions) => void;\n\tend: (e: IEndCallbackOptions) => void;\n}\n\nexport default class LayoutMananger {\n\tpublic options: Required<ILayoutManagerOptions>;\n\tpublic _items: ItemManager;\n\tpublic _renderer: DOMRenderer;\n\tpublic _layout: ILayout;\n\tconstructor(items: ItemManager, renderer: DOMRenderer, options: ILayoutManagerOptions = {}) {\n\t\tassign(this.options = {\n\t\t\tattributePrefix: \"data-\",\n\t\t\tisEqualSize: false,\n\t\t\tisConstantSize: false,\n\t\t\thorizontal: false,\n\t\t}, options);\n\n\t\tthis._items = items;\n\t\tthis._renderer = renderer;\n\t\tthis._layout = null;\n\t}\n\tpublic setLayout(layout: ILayout) {\n\t\tthis._layout = layout;\n\t}\n\tpublic setSize(size: number) {\n\t\tthis._layout.setSize(size);\n\t}\n\tpublic append(\n\t\t{\n\t\t\tgroups,\n\t\t\titems,\n\t\t\tisUpdate,\n\t\t}: {\n\t\t\tgroups: IInfiniteGridGroup[],\n\t\t\titems: IInfiniteGridItem[],\n\t\t\tisUpdate?: boolean,\n\t\t},\n\t\tcallbacks: Partial<ILayoutManagerCallbacks>,\n\t) {\n\t\tthis._insert({ groups, items, isUpdate, isAppend: true }, callbacks);\n\t}\n\tpublic prepend(\n\t\t{\n\t\t\tgroups,\n\t\t\titems,\n\t\t\tisUpdate,\n\t\t}: {\n\t\t\tgroups: IInfiniteGridGroup[],\n\t\t\titems: IInfiniteGridItem[],\n\t\t\tisUpdate?: boolean,\n\t\t},\n\t\tcallbacks: Partial<ILayoutManagerCallbacks>,\n\t) {\n\t\tthis._insert({ groups, items, isUpdate, isAppend: false }, callbacks);\n\t}\n\tpublic layout(isRelayout: boolean, groups: IInfiniteGridGroup[], items: IInfiniteGridItem[]) {\n\t\tconst renderer = this._renderer;\n\t\tconst { isEqualSize, isConstantSize } = renderer.options;\n\t\tconst layoutGroups = groups.filter(group => {\n\t\t\tconst item = group.items[0];\n\n\t\t\treturn item.orgSize && item.rect.top > DUMMY_POSITION / 10;\n\t\t});\n\n\t\tif (!layoutGroups.length) {\n\t\t\treturn [];\n\t\t}\n\t\tlet outline = layoutGroups[0].outlines.start;\n\n\t\tif (isRelayout) {\n\t\t\toutline = [outline.length ? Math.min(...outline) : 0];\n\t\t\tif (!isConstantSize && items.length) {\n\t\t\t\trenderer.updateSize(items);\n\n\t\t\t\t// update invisible items' size\n\t\t\t\tif (isEqualSize && items[0].size) {\n\t\t\t\t\tItemManager.pluck(layoutGroups, \"items\").forEach(item => {\n\t\t\t\t\t\titem.size = assign({}, items[0].size);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._layout.layout(layoutGroups, outline);\n\t\treturn layoutGroups;\n\t}\n\tpublic destroy() {\n\t\tthis._items = null;\n\t\tthis._renderer = null;\n\t}\n\tprivate _complete(\n\t\tgroups: IInfiniteGridGroup[],\n\t\titems: IInfiniteGridItem[],\n\t\tisAppend: boolean,\n\t\tisUpdate: boolean,\n\t\tcallback: ILayoutManagerCallbacks[\"complete\"],\n\t) {\n\t\tconst itemManager = this._items;\n\t\tconst cursor = isAppend ? \"end\" : \"start\";\n\t\tconst groupIndex = itemManager.indexOf(groups[0]);\n\t\tconst prevGroup = itemManager.getData(groupIndex + (isAppend ? -1 : 1));\n\t\tlet outline = prevGroup ? prevGroup.outlines[cursor] : [0];\n\n\t\tthis._renderer.updateSize(items);\n\n\t\tconst groupInfos = groups.map(group => {\n\t\t\tconst groupOutline = group.outlines[isAppend ? \"start\" : \"end\"];\n\t\t\tconst isRelayout = isUpdate || !outline.length || (outline.length === groupOutline.length ?\n\t\t\t\t!outline.every((v, index) => v === groupOutline[index]) : true);\n\n\t\t\tif (!isRelayout) {\n\t\t\t\toutline = group.outlines[isAppend ? \"end\" : \"start\"];\n\t\t\t\tDOMRenderer.renderItems(group.items);\n\t\t\t\treturn group;\n\t\t\t}\n\t\t\tconst groupItems = group.items;\n\t\t\tconst groupInfo = this._layout[isAppend ? \"append\" : \"prepend\"](groupItems, outline, true);\n\n\t\t\tassign(group, groupInfo);\n\t\t\tDOMRenderer.renderItems(groupInfo.items);\n\t\t\toutline = groupInfo.outlines[isAppend ? \"end\" : \"start\"];\n\n\t\t\treturn groupInfo;\n\t\t});\n\n\t\tcallback({\n\t\t\tgroups: groupInfos,\n\t\t\titems,\n\t\t\tisAppend,\n\t\t});\n\t}\n\tprivate _error(\n\t\tremoveTarget: HTMLElement[],\n\t\treplaceTarget: number[],\n\t\ttarget: HTMLImageElement,\n\t\titems: IInfiniteGridItem[],\n\t\terrorIndex: number,\n\t\tcallback: ILayoutManagerCallbacks[\"error\"],\n\t) {\n\t\tconst item = items[errorIndex];\n\t\tconst element = item.el;\n\t\tconst prefix = this.options.attributePrefix;\n\n\t\t// remove item\n\t\tconst removeItem = () => {\n\t\t\tif (hasTarget(removeTarget, element)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tremoveTarget.push(element);\n\t\t\tconst index = replaceTarget.indexOf(errorIndex);\n\n\t\t\tindex !== -1 && replaceTarget.splice(index, 1);\n\t\t};\n\t\t// remove image\n\t\tconst remove = () => {\n\t\t\tif (target === element) {\n\t\t\t\tremoveItem();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (hasTarget(removeTarget, element)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttarget.parentNode.removeChild(target);\n\t\t\titem.content = element.outerHTML;\n\t\t\tif (hasTarget(replaceTarget, errorIndex)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treplaceTarget.push(errorIndex);\n\t\t};\n\t\t// replace image\n\t\tconst replace = (src: string) => {\n\t\t\tif (hasTarget(removeTarget, element)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (src) {\n\t\t\t\tif (matchHTML(src) || typeof src === \"object\") {\n\t\t\t\t\tconst parentNode = target.parentNode;\n\n\t\t\t\t\tparentNode.insertBefore($(src), target);\n\t\t\t\t\tparentNode.removeChild(target);\n\t\t\t\t\titem.content = element.outerHTML;\n\t\t\t\t} else {\n\t\t\t\t\ttarget.src = src;\n\t\t\t\t\tif (target.getAttribute(`${prefix}width`)) {\n\t\t\t\t\t\tAutoSizer.remove(target);\n\t\t\t\t\t\ttarget.removeAttribute(`${prefix}width`);\n\t\t\t\t\t\ttarget.removeAttribute(`${prefix}height`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\titem.content = element.outerHTML;\n\t\t\tif (hasTarget(replaceTarget, errorIndex)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treplaceTarget.push(errorIndex);\n\t\t};\n\t\t// replace item\n\t\tconst replaceItem = (content: string) => {\n\t\t\tif (hasTarget(removeTarget, element)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telement.innerHTML = content;\n\t\t\titem.content = element.outerHTML;\n\t\t\tif (hasTarget(replaceTarget, errorIndex)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treplaceTarget.push(errorIndex);\n\t\t};\n\n\t\tcallback({\n\t\t\ttarget,\n\t\t\telement,\n\t\t\titems,\n\t\t\titem,\n\t\t\titemIndex: errorIndex,\n\t\t\treplace,\n\t\t\treplaceItem,\n\t\t\tremove,\n\t\t\tremoveItem,\n\t\t});\n\t}\n\tprivate _end(\n\t\tremoveTarget: HTMLElement[],\n\t\treplaceTarget: number[],\n\t\titems: IInfiniteGridItem[],\n\t\tcallback: ILayoutManagerCallbacks[\"end\"],\n\t) {\n\t\tconst { attributePrefix } = this.options;\n\n\t\tconst removeTargetLength = removeTarget.length;\n\t\tconst replaceTargetLength = replaceTarget.length;\n\n\t\tif (!removeTargetLength && !replaceTargetLength) {\n\t\t\tcallback({ remove: [] });\n\t\t\treturn;\n\t\t}\n\t\tconst layoutedItems = replaceTarget.map(itemIndex => items[itemIndex]);\n\n\t\tif (!replaceTargetLength) {\n\t\t\tcallback({ remove: removeTarget, layout: true });\n\t\t\treturn;\n\t\t}\n\t\t// wait layoutComplete beacause of error event.\n\t\tImageLoaded.check(layoutedItems.map(v => v.el), {\n\t\t\tprefix: attributePrefix,\n\t\t\tcomplete: () => {\n\t\t\t\tthis._renderer.updateSize(layoutedItems);\n\t\t\t\tcallback({ remove: removeTarget, layout: true });\n\t\t\t},\n\t\t});\n\t}\n\tprivate _insert(\n\t\t{\n\t\t\tgroups,\n\t\t\titems = ItemManager.pluck(groups, \"items\"),\n\t\t\tisAppend,\n\t\t\tisUpdate,\n\t\t}: {\n\t\t\tgroups: IInfiniteGridGroup[],\n\t\t\titems: IInfiniteGridItem[],\n\t\t\tisAppend: boolean,\n\t\t\tisUpdate: boolean,\n\t\t},\n\t\t{\n\t\t\terror = () => void 0,\n\t\t\tcomplete = () => void 0,\n\t\t\tend = () => void 0,\n\t\t}: Partial<ILayoutManagerCallbacks>,\n\t) {\n\t\tif (!groups.length) {\n\t\t\treturn;\n\t\t}\n\t\tconst checkGroups = isAppend ? groups : groups.reverse();\n\t\tconst replaceTarget: number[] = [];\n\t\tconst removeTarget: HTMLElement[] = [];\n\t\tconst elements = items.map(item => item.el);\n\t\tconst type = this.options.isEqualSize && this._renderer._size.item ? CHECK_ONLY_ERROR : CHECK_ALL;\n\t\tconst prefix = this.options.attributePrefix;\n\n\t\tImageLoaded.check(elements, {\n\t\t\tprefix,\n\t\t\ttype,\n\t\t\tcomplete: () => {\n\t\t\t\tif (!this._items) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis._complete(checkGroups, items, isAppend, isUpdate, complete);\n\t\t\t},\n\t\t\terror: ({ target, itemIndex }) => {\n\t\t\t\tif (!this._items) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis._error(removeTarget, replaceTarget, target, items, itemIndex, error);\n\t\t\t},\n\t\t\tend: () => {\n\t\t\t\tif (!this._items) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis._end(removeTarget, replaceTarget, items, end);\n\t\t\t},\n\t\t});\n\t}\n}\n","/**\n * Copyright (c) 2017 NAVER Corp.\n * egjs projects are licensed under the MIT license\n*/\nimport Component from \"@egjs/component\";\nimport ItemManager from \"./ItemManager\";\nimport DOMRenderer, { resetSize } from \"./DOMRenderer\";\nimport Watcher from \"./Watcher\";\nimport {\n\tAPPEND,\n\tPREPEND,\n\tCACHE,\n\tNO_CACHE,\n\tTRUSTED,\n\tNO_TRUSTED,\n\tIS_ANDROID2,\n\tIDLE,\n\tLOADING_APPEND,\n\tLOADING_PREPEND,\n\tPROCESSING,\n\tDEFENSE_BROWSER,\n\tIGNORE_CLASSNAME,\n\tDUMMY_POSITION,\n\tIS_IOS,\n} from \"./consts\";\nimport Infinite from \"./Infinite\";\nimport { toArray, $, outerHeight, outerWidth, assign } from \"./utils\";\nimport LayoutMananger from \"./LayoutManager\";\nimport {\n\tIJQuery, ILayout,\n\tCursorType, StyleType,\n\tIItemManagerStatus, IInfiniteGridItem,\n\tIInfiniteGridGroup, IErrorCallbackOptions, IDOMRendererStatus, IWatchStatus, IInfiniteStatus, IInfiniteGridStatus\n} from \"./types\";\n\n// IE8\n// https://stackoverflow.com/questions/43216659/babel-ie8-inherit-issue-with-object-create\n/* eslint-disable */\n// if (typeof Object.create !== \"function\") {\n//   // tslint:disable\n//   Object.create = (o: any, properties: any) => {\n//     if (typeof o !== \"object\" && typeof o !== \"function\") {\n//       throw new TypeError(\"Object prototype may only be an Object: \" + o);\n//     } else if (o === null) {\n//       throw new Error(\"This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument.\");\n//     }\n//     function F() { }\n//     F.prototype = o;\n//     return new F();\n//   };\n//   // tslint:enable\n// }\n/* eslint-enable */\n\nexport interface IInfiniteGridOptions {\n\titemSelector: string;\n\tisOverflowScroll: boolean;\n\tthreshold: number;\n\tisEqualSize: boolean;\n\tisConstantSize: boolean;\n\tuseRecycle: boolean;\n\thorizontal: boolean;\n\ttransitionDuration: number;\n\tuseFit: boolean;\n\tattributePrefix: string;\n}\n\n/**\n * A module used to arrange card elements including content infinitely according to layout type. With this module, you can implement various layouts composed of different card elements whose sizes vary. It guarantees performance by maintaining the number of DOMs the module is handling under any circumstance\n * @ko          .         .        DOM      \n * @alias eg.InfiniteGrid\n * @extends eg.Component\n *\n * @example\n```\n<ul id=\"grid\">\n  <li class=\"card\">\n    <div>test1</div>\n  </li>\n  <li class=\"card\">\n    <div>test2</div>\n  </li>\n  <li class=\"card\">\n    <div>test3</div>\n  </li>\n  <li class=\"card\">\n    <div>test4</div>\n  </li>\n  <li class=\"card\">\n    <div>test5</div>\n  </li>\n  <li class=\"card\">\n    <div>test6</div>\n  </li>\n</ul>\n<script>\nvar some = new eg.InfiniteGrid(\"#grid\").on(\"layoutComplete\", function(e) {\n  // ...\n});\n\n// If you already have items in the container, call \"layout\" method.\nsome.layout();\n</script>\n```\n *\n * @support {\"ie\": \"8+\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\", \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"2.1+ (except 3.x)\"}\n **/\nclass InfiniteGrid extends Component {\n\t/**\n\t * Version info string\n\t * @ko  \n\t * @name VERSION\n\t * @static\n\t * @type {String}\n\t * @example\n\t * eg.InfiniteGrid.VERSION;  // ex) 3.3.3\n\t * @memberof eg.InfiniteGrid\n\t */\n\tpublic static VERSION = \"#__VERSION__#\";\n\n\tpublic options: IInfiniteGridOptions;\n\tprivate _loadingBar: {\n\t\tappend?: HTMLElement,\n\t\tprepend?: HTMLElement,\n\t};\n\tprivate _items: ItemManager;\n\tprivate _renderer: DOMRenderer;\n\tprivate _manager: LayoutMananger;\n\tprivate _watcher: Watcher;\n\tprivate _infinite: Infinite;\n\tprivate _status: IInfiniteGridStatus[\"_status\"];\n\n\t/**\n\t * @param {HTMLElement|String|jQuery} element A base element for a module <ko>   </ko>\n\t * @param {Object} [options] The option object of the eg.InfiniteGrid module <ko>eg.InfiniteGrid   </ko>\n\t * @param {String} [options.itemSelector] A selector to select card elements that make up the layout<ko>     (selector)</ko>\n\t * @param {Boolean} [options.useRecycle=true] Indicates whether keep the number of DOMs is maintained. If the useRecycle value is 'true', keep the number of DOMs is maintained. If the useRecycle value is 'false', the number of DOMs will increase as card elements are added. <ko>DOM    . useRecycle  'true' DOM   . useRecycle  'false'     DOM   .</ko>\n\t * @param {Boolean} [options.isOverflowScroll=false] Indicates whether overflow:scroll is applied<ko>overflow:scroll  .</ko>\n\t * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (true: horizontal, false: vertical) <ko>   (true , false )</ko>\n\t * @param {Boolean} [options.useFit=true] The useFit option scrolls upwards so that no space is visible until an item is added <ko>          .</ko>\n\t * @param {Boolean} [options.isEqualSize=false] Indicates whether sizes of all card elements are equal to one another. If sizes of card elements to be arranged are all equal and this option is set to \"true\", the performance of layout arrangement can be improved. <ko>    .          'true'       </ko>\n\t * @param {Boolean} [options.isConstantSize=false] Indicates whether sizes of all card elements does not change, the performance of layout arrangement can be improved. <ko>        'true'       </ko>\n\t * @param {Number} [options.transitionDruation=0] Indicates how many seconds a transition effect takes to complete. <ko>     .</ko>\n\t * @param {Number} [options.threshold=100] The threshold size of an event area where card elements are added to a layout.<ko>        .</ko>\n\t * @param {String} [options.attributePrefix=\"data-\"] The prefix to use element's data attribute.<ko>    .</ko>\n\t */\n\tconstructor(element: HTMLElement | string | IJQuery, options?: Partial<IInfiniteGridOptions>) {\n\t\tsuper();\n\t\tassign(this.options = {\n\t\t\titemSelector: \"*\",\n\t\t\tisOverflowScroll: false,\n\t\t\tthreshold: 100,\n\t\t\tisEqualSize: false,\n\t\t\tisConstantSize: false,\n\t\t\tuseRecycle: true,\n\t\t\thorizontal: false,\n\t\t\ttransitionDuration: 0,\n\t\t\tuseFit: true,\n\t\t\tattributePrefix: \"data-\",\n\t\t}, options);\n\t\tDEFENSE_BROWSER && (this.options.useFit = false);\n\t\tIS_ANDROID2 && (this.options.isOverflowScroll = false);\n\t\tthis._reset();\n\t\tthis._loadingBar = {};\n\n\t\tconst {\n\t\t\tisOverflowScroll,\n\t\t\tisEqualSize,\n\t\t\tisConstantSize,\n\t\t\thorizontal,\n\t\t\tthreshold,\n\t\t\tuseRecycle,\n\t\t} = this.options;\n\n\t\tthis._items = new ItemManager();\n\t\tthis._renderer = new DOMRenderer(element, {\n\t\t\tisEqualSize,\n\t\t\tisConstantSize,\n\t\t\thorizontal,\n\t\t\tcontainer: isOverflowScroll,\n\t\t});\n\t\tthis._watcher = new Watcher(\n\t\t\tthis._renderer.view,\n\t\t\t{\n\t\t\t\tisOverflowScroll,\n\t\t\t\thorizontal,\n\t\t\t\tcontainer: this._renderer.container,\n\t\t\t\tresize: () => this._onResize(),\n\t\t\t\tcheck: param => this._onCheck(param),\n\t\t\t});\n\n\t\tthis._infinite = new Infinite(this._items, {\n\t\t\tuseRecycle,\n\t\t\tthreshold,\n\t\t\tappend: param => this._requestAppend(param),\n\t\t\tprepend: param => this._requestPrepend(param),\n\t\t\trecycle: param => this._recycle(param),\n\t\t});\n\t}\n\t/**\n\t * Adds a card element at the bottom of a layout. This method is available only if the isProcessing() method returns false.\n\t * @ko     . isProcessing()   'false'      \n\t *   isProcessing()  false   .\n\t * @param {Array|jQuery} elements Array of the card elements to be added <ko>   </ko>\n\t * @param {Number|String} [groupKey] The group key to be configured in a card element. It is automatically generated by default.\n\t * <ko>     .    .</ko>\n\t * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n\t * @example\n\t * infinitegrid.append(\"&lt;div class='item'&gt;test1&lt;/div&gt;&lt;div class='item'&gt;test2&lt;/div&gt;\");\n\t * infinitegrid.append([\"&lt;div class='item'&gt;test1&lt;/div&gt;\", \"&lt;div class='item'&gt;test2&lt;/div&gt;\"]);\n\t * infinitegrid.append([HTMLElement1, HTMLElement2]);\n\t * infinitegrid.append(jQuery([\"&lt;div class='item'&gt;test1&lt;/div&gt;\", \"&lt;div class='item'&gt;test2&lt;/div&gt;\"]));\n\t */\n\tpublic append(elements: HTMLElement[] | IJQuery | string[] | string, groupKey?: string | number) {\n\t\tthis._manager && this._insert({\n\t\t\telements,\n\t\t\tisAppend: APPEND,\n\t\t\tgroupKey,\n\t\t});\n\t\treturn this;\n\t}\n\t/**\n\t * Adds a card element at the top of a layout. This method is available only if the isProcessing() method returns false.\n\t * @ko     . isProcessing()   'false'      \n\t * @param {Array|jQuery} elements Array of the card elements to be added <ko>   </ko>\n\t * @param {Number|String} [groupKey] The group key to be configured in a card element. It is automatically generated by default.\n\t * <ko>     .    .</ko>\n\t * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n\t * @example\n\t * infinitegrid.prepend(\"&lt;div class='item'&gt;test1&lt;/div&gt;&lt;div class='item'&gt;test2&lt;/div&gt;\");\n\t * infinitegrid.prepend([\"&lt;div class='item'&gt;test1&lt;/div&gt;\", \"&lt;div class='item'&gt;test2&lt;/div&gt;\"]);\n\t * infinitegrid.prepend([HTMLElement1, HTMLElement2]);\n\t * infinitegrid.prepend(jQuery([\"&lt;div class='item'&gt;test1&lt;/div&gt;\", \"&lt;div class='item'&gt;test2&lt;/div&gt;\"]));\n\t */\n\tpublic prepend(elements: HTMLElement[] | IJQuery | string[] | string, groupKey?: string | number) {\n\t\tthis._manager && this._insert({\n\t\t\telements,\n\t\t\tisAppend: PREPEND,\n\t\t\tgroupKey,\n\t\t});\n\t\treturn this;\n\t}\n\t/**\n\t * Specifies the Layout class to use.\n\t * @ko  Layout  .\n\t * @param {Class|Object} LayoutKlass The Layout class to use or an instance of a layout moudle<ko> Layout     </ko>\n\t * @param {Object} options Options to apply to the Layout.<ko>Layout  </ko>\n\t * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n\t * @example\n\t * infinitegrid.setLayout(eg.InfiniteGrid.GridLayout, {\n\t *  margin: 10,\n\t *  align: \"start\"\n\t * });\n\t * infinitegrid.setLayout(eg.InfiniteGrid.JustifiedLayout, {\n\t *  margin: 10,\n\t *  minSize: 100,\n\t *  maxSize: 200\n\t * });\n\t * infinitegrid.setLayout(eg.InfiniteGrid.SquareLayout, {\n\t *  margin: 10,\n\t *  column: 2\n\t * });\n\t * infinitegrid.setLayout(eg.InfiniteGrid.FrameLayout, {\n\t *  margin: 10,\n\t *  frame: [\n\t *   [1, 2],\n\t *   [4, 3],\n\t *  ]\n\t * });\n\t * infinitegrid.setLayout(eg.InfiniteGrid.PackingLayout, {\n\t *  margin: 10,\n\t *  aspectRatio: 1.5\n\t * });\n\t * var layout = new eg.InfiniteGrid.GridLayout({\n\t *   margin: 10,\n\t *  align: \"start\"\n\t * });\n\t * infinitegrid.setLayout(layout);\n\t */\n\tpublic setLayout(LayoutKlass: ILayout | (new (...args: any[]) => ILayout), options = {}) {\n\t\tconst { isEqualSize, isConstantSize, attributePrefix, horizontal } = this.options;\n\n\t\tif (!this._manager) {\n\t\t\tthis._manager = new LayoutMananger(this._items, this._renderer, {\n\t\t\t\tattributePrefix,\n\t\t\t\tisEqualSize,\n\t\t\t\tisConstantSize,\n\t\t\t});\n\t\t}\n\t\tif (typeof LayoutKlass === \"function\") {\n\t\t\tthis._manager.setLayout(new LayoutKlass(assign(options, {\n\t\t\t\thorizontal,\n\t\t\t})));\n\t\t} else {\n\t\t\tLayoutKlass.options.horizontal = horizontal;\n\t\t\tthis._manager.setLayout(LayoutKlass);\n\t\t}\n\t\tthis._renderer.resize();\n\t\tthis._setSize(this._renderer.getViewportSize());\n\t\treturn this;\n\t}\n\t/**\n\t * Returns the layouted items.\n\t * @ko   .\n\t * @param {Boolean} includeCached Indicates whether to include the cached items. <ko>    .</ko>\n\t * @returns List of items <ko> </ko>\n\t */\n\tpublic getItems(includeCached = false): IInfiniteGridItem[] {\n\t\treturn includeCached ? this._items.pluck(\"items\") : this._infinite.getVisibleItems();\n\t}\n\t/**\n\t * Rearranges a layout.\n\t * @ko   .\n\t * @param {Boolean} [isRelayout=true] Indicates whether a card element is being relayouted <ko>   </ko>\n\t * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n\t */\n\tpublic layout(isRelayout = true) {\n\t\tif (!this._manager) {\n\t\t\treturn this;\n\t\t}\n\t\tconst renderer = this._renderer;\n\t\tconst itemManager = this._items;\n\t\tconst infinite = this._infinite;\n\t\tconst isResize = renderer.resize();\n\t\tconst items = this.getItems();\n\t\tconst { isEqualSize, isConstantSize, transitionDuration } = this.options;\n\t\tconst isLayoutAll = isRelayout && (isEqualSize || isConstantSize);\n\t\tconst size = itemManager.size();\n\n\t\tif (isRelayout) {\n\t\t\tthis._watcher.resize();\n\t\t\tif (isResize) {\n\t\t\t\tthis._setSize(renderer.getViewportSize());\n\t\t\t}\n\t\t}\n\t\t// check childElement\n\t\tif (!size || !items.length) {\n\t\t\tconst children = toArray(renderer.container.children);\n\n\t\t\tif (children.length) {\n\t\t\t\tthis._insert({\n\t\t\t\t\telements: children,\n\t\t\t\t\tisAppend: true,\n\t\t\t\t\tisChildren: true,\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tif (renderer.getContainerSize()) {\n\t\t\t\t\trenderer.setContainerSize(0);\n\t\t\t\t}\n\t\t\t\tthis._requestAppend({});\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\t// layout datas\n\t\tconst startCursor = infinite.getCursor(\"start\");\n\t\tconst endCursor = infinite.getCursor(\"end\");\n\t\tconst data = isLayoutAll || !(isRelayout && isResize) ? itemManager.get() :\n\t\t\titemManager.get(startCursor, endCursor);\n\n\t\t// LayoutManger interface\n\t\tthis._manager.layout(isRelayout, data, isResize ? items : []);\n\t\tif (isLayoutAll) {\n\t\t\tthis._fit();\n\t\t} else if (isRelayout && isResize) {\n\t\t\titemManager.clearOutlines(startCursor, endCursor);\n\t\t}\n\t\tDOMRenderer.renderItems(items, transitionDuration);\n\t\tisRelayout && this._watcher.setScrollPos();\n\t\tthis._onLayoutComplete({\n\t\t\titems,\n\t\t\tisAppend: APPEND,\n\t\t\tfromCache: CACHE,\n\t\t\tisTrusted: NO_TRUSTED,\n\t\t\tuseRecycle: false,\n\t\t\tisLayout: true,\n\t\t});\n\t\treturn this;\n\t}\n\t/**\n\t * Removes a item element on a grid layout.\n\t * @ko     .\n\t * @param {HTMLElement} item element to be removed <ko>  </ko>\n\t * @return {Object}  Removed item element <ko>   </ko>\n\t */\n\tpublic remove(element: HTMLElement, isLayout = true) {\n\t\tif (element) {\n\t\t\tconst {items, groups} = this._infinite.remove(element);\n\n\t\t\titems && DOMRenderer.removeElement(element);\n\t\t\tisLayout && this.layout(groups.length > 0);\n\t\t\treturn items;\n\t\t}\n\t\treturn null;\n\t}\n\t/**\n\t * Returns the list of group keys which belongs to card elements currently being maintained. You can use the append() or prepend() method to configure group keys so that multiple card elements can be managed at once. If you do not use these methods to configure group keys, groupkey is automatically generated.\n\t * @ko         .         append()  prepend()      . append()  prepend()        .\n\t * @param {Boolean} includeCached Indicates whether to include the cached groups. <ko>    .</ko>\n\t * @return {Array} List of group keys <ko>  </ko>\n\t */\n\tpublic getGroupKeys(includeCached?: boolean) {\n\t\tconst data = includeCached ?\n\t\t\tthis._items.get() : this._infinite.getVisibleData();\n\n\t\treturn data.map(v => v.groupKey);\n\t}\n\t/**\n\t * Returns the current state of a module such as location information. You can use the setStatus() method to restore the information returned through a call to this method.\n\t * @ko         .       setStatus()    \n\t * @return {Object} State object of the eg.InfiniteGrid module<ko>eg.InfiniteGrid   </ko>\n\t */\n\tpublic getStatus(startKey?: string | number, endKey?: string | number): IInfiniteGridStatus {\n\t\treturn {\n\t\t\t_status: assign({}, this._status),\n\t\t\t_items: this._items.getStatus(startKey, endKey),\n\t\t\t_renderer: this._renderer.getStatus(),\n\t\t\t_watcher: this._watcher.getStatus(),\n\t\t\t_infinite: this._infinite.getStatus(startKey, endKey),\n\t\t};\n\t}\n\t/**\n\t * Sets the state of the eg.InfiniteGrid module with the information returned through a call to the getStatue() method.\n\t * @ko getStatue()    eg.InfiniteGrid   .\n\t * @param {Object} status State object of the eg.InfiniteGrid module <ko>eg.InfiniteGrid   </ko>\n\t * @param {boolean} [applyScrollPos=true] Checks whether to scroll<ko>   .</ko>\n\t * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n\t */\n\tpublic setStatus(status: IInfiniteGridStatus, applyScrollPos = true) {\n\t\tif (!status) {\n\t\t\treturn this;\n\t\t}\n\t\tconst { _status, _renderer, _items, _watcher, _infinite } = status;\n\n\t\tif (!_status ||\n\t\t\t!_renderer || !_items || !_watcher || !_infinite) {\n\t\t\treturn this;\n\t\t}\n\t\tconst items = this._items;\n\t\tconst renderer = this._renderer;\n\t\tconst watcher = this._watcher;\n\t\tconst infinite = this._infinite;\n\n\t\twatcher.detachEvent();\n\t\tassign(this._status, _status);\n\t\tthis._status.processingStatus = IDLE;\n\t\titems.setStatus(_items);\n\t\trenderer.setStatus(_renderer);\n\t\tinfinite.setStatus(_infinite);\n\n\t\tconst visibleItems = this.getItems();\n\t\tconst length = visibleItems.length;\n\n\t\trenderer.createAndInsert(visibleItems, true);\n\n\t\tconst isReLayout = renderer.isNeededResize();\n\n\t\twatcher.setStatus(_watcher, applyScrollPos);\n\t\twatcher.attachEvent();\n\n\t\tconst { isConstantSize, isEqualSize } = this.options;\n\n\t\tif (!length) {\n\t\t\tthis._requestAppend({ cache: [] });\n\t\t} else if (isReLayout) {\n\t\t\trenderer.resize();\n\t\t\tthis._setSize(renderer.getViewportSize());\n\n\t\t\tif (isConstantSize) {\n\t\t\t\tthis.layout(true);\n\t\t\t} else {\n\t\t\t\tthis._items.clearOutlines();\n\t\t\t\tthis._postLayout({\n\t\t\t\t\tfromCache: true,\n\t\t\t\t\tgroups: isEqualSize ? items.get() : infinite.getVisibleData(),\n\t\t\t\t\titems: visibleItems,\n\t\t\t\t\tnewItems: visibleItems,\n\t\t\t\t\tisAppend: true,\n\t\t\t\t\tisTrusted: false,\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tthis.layout(false);\n\t\t}\n\t\treturn this;\n\t}\n\t/**\n\t * Clears added card elements and data.\n\t * @ko      .\n\t * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n\t */\n\tpublic clear() {\n\t\tthis._items.clear();\n\t\tthis._renderer.clear();\n\t\tthis._infinite.clear();\n\t\tthis._reset();\n\t\tthis._appendLoadingBar();\n\t\treturn this;\n\t}\n\t/**\n\t * Specifies the Loading Bar to use for append or prepend items.\n\t * @ko  append  prepend      .\n\t * @param {String|Object} [userLoadingBar={}] The loading bar HTML markup or element or element selector <ko>   HTML  element  selector </ko>\n\t * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n\t */\n\tpublic setLoadingBar(userLoadingBar: {\n\t\tappend?: string | HTMLElement,\n\t\tprepepnd?: string | HTMLElement,\n\t} | string = {}) {\n\t\tconst loadingBarObj: {\n\t\t\tappend?: string | HTMLElement,\n\t\t\tprepend?: string | HTMLElement,\n\t\t} = typeof userLoadingBar === \"object\" ? userLoadingBar : {\n\t\t\tappend: userLoadingBar,\n\t\t\tprepend: userLoadingBar,\n\t\t};\n\n\t\tthis._status.loadingSize = 0;\n\t\tthis._status.loadingStyle = {};\n\t\tconst loadingBar = this._loadingBar;\n\n\t\tfor (const type in loadingBarObj) {\n\t\t\tloadingBar[type as \"append\" | \"prepend\"] = $(loadingBarObj[type as \"append\" | \"prepend\"]);\n\t\t\tloadingBar[type as \"append\" | \"prepend\"].className += ` ${IGNORE_CLASSNAME}`;\n\t\t}\n\t\tthis._appendLoadingBar();\n\t\treturn this;\n\t}\n\t/**\n\t * Checks whether a card element or data is being added.\n\t * @ko         \n\t * @return {Boolean} Indicates whether a card element or data is being added <ko>        </ko>\n\t */\n\tpublic isProcessing() {\n\t\treturn this._isProcessing() || this._isLoading();\n\t}\n\t/**\n\t * Returns the element of loading bar.\n\t * @ko   element .\n\t * @param {Boolean} [isAppend=currentLoadingBar|true] Checks whether the card element is added to the append () method. <ko>  append()     .</ko>\n\t * @return {Element} The element of loading bar. <ko>  element</ko>\n\t */\n\tpublic getLoadingBar(isAppend = this._getLoadingStatus() !== LOADING_PREPEND) {\n\t\treturn this._loadingBar[isAppend ? \"append\" : \"prepend\"];\n\t}\n\t/**\n\t * Start loading for append/prepend during loading data.\n\t * @ko    append/prepend   .\n\t * @param {Boolean} [isAppend=true] Checks whether the card element is added to the append () method. <ko>  append()     .</ko>\n\t * @param {Object} [userStyle = {display: \"block\"}] custom style to apply to this loading bar for start. <ko>         </ko>\n\t * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n\t */\n\tpublic startLoading(isAppend?: boolean, userStyle: StyleType = { display: \"block\" }) {\n\t\tif (this._isLoading()) {\n\t\t\treturn this;\n\t\t}\n\t\tconst type = isAppend ? \"append\" : \"prepend\";\n\n\t\tthis._process(isAppend ? LOADING_APPEND : LOADING_PREPEND);\n\t\tif (!this._loadingBar[type]) {\n\t\t\treturn this;\n\t\t}\n\t\tthis._renderLoading(userStyle);\n\t\tthis._status.loadingStyle = userStyle;\n\t\tif (!isAppend) {\n\t\t\tthis._fit();\n\t\t} else {\n\t\t\tthis._setContainerSize(this._getEdgeValue(\"end\") + this._status.loadingSize);\n\t\t}\n\t\treturn this;\n\t}\n\t/**\n\t * End loading after startLoading() for append/prepend\n\t * @ko  append/prepend  startLoading()    .\n\t * @param {Object} [userStyle = {display: \"none\"}] custom style to apply to this loading bar for end <ko>         </ko>\n\t * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n\t */\n\tpublic endLoading(userStyle: StyleType = { display: \"none\" }) {\n\t\tif (!this._isLoading()) {\n\t\t\treturn this;\n\t\t}\n\t\tconst isAppend = this._getLoadingStatus() === LOADING_APPEND;\n\t\tconst type = isAppend ? \"append\" : \"prepend\";\n\t\tconst el = this._loadingBar[type];\n\t\tconst status = this._status;\n\t\tconst size = status.loadingSize;\n\n\t\tthis._process(LOADING_APPEND | LOADING_PREPEND, false);\n\t\tstatus.loadingSize = 0;\n\t\tstatus.loadingStyle = {};\n\t\tif (el) {\n\t\t\tconst style: StyleType = assign({\n\t\t\t\t[this.options.horizontal ? \"left\" : \"top\"]: `${-size}px`,\n\t\t\t}, userStyle);\n\n\t\t\tfor (const property in style) {\n\t\t\t\tel.style[property as keyof StyleType] = style[property as keyof StyleType];\n\t\t\t}\n\t\t\tif (!isAppend) {\n\t\t\t\tthis._fitItems(size);\n\t\t\t} else {\n\t\t\t\tthis._setContainerSize(this._getEdgeValue(\"end\"));\n\t\t\t}\n\t\t}\n\t\tif (this.options.useRecycle && !this.isProcessing()) {\n\t\t\tthis._infinite.recycle(this._watcher.getScrollPos(), isAppend);\n\t\t}\n\t\treturn this;\n\t}\n\t/**\n\t * Retrieves the item via index or the element.\n\t * @ko index  element   .\n\t * @param {number | HTMLElement} [groupIndex=0] The element corresponding to item or the index of the group where the item is in position <ko> item  element   item  group index</ko>\n\t * @param {number} [itemIndex] If groupIndex is used, the index of the item in the group <ko> groupIndex    group  Item index </ko>\n\t * @return The item containing the content, size and position,etc<ko>content, size, position   item </ko>\n\t * @example\n\n\t ig.getItem(0, 0);\n\t ig.getItem(element);\n\n\t {\n\t  el: HTMLElement,\n\t  content: \"<div>...</div>\",\n\t  size: {width: ..., height: ...},\n\t  rect: {top: ..., left: ..., width: ..., height: ...},\n\t }\n\t */\n\tpublic getItem(groupIndex = 0, itemIndex?: number): IInfiniteGridItem {\n\t\tif (itemIndex == null && typeof groupIndex === \"object\") {\n\t\t\tif (!groupIndex) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tconst items = this.getItems();\n\t\t\tconst length = items.length;\n\n\t\t\tfor (let i = 0; i < length; ++i) {\n\t\t\t\tif (items[i].el === groupIndex) {\n\t\t\t\t\treturn items[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tconst group = this._items.getData(groupIndex);\n\n\t\t\treturn group && group.items[itemIndex || 0];\n\t\t}\n\t}\n\t/**\n\t * Updates the item via index or the element.\n\t * @ko index  element   .\n\t * @param {number | HTMLElement} [groupIndex=0] The element corresponding to item or the index of the group where the item is in position <ko> item  element   item  group index</ko>\n\t * @param {number} [itemIndex] If groupIndex is used, the index of the item in the group <ko> groupIndex    group  Item index </ko>\n\t * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n\t * @example\n\telement.innerHTML = \"2\";\n\telement.style.height = \"400px\";\n\tig.updateItem(element);\n\tig.updateItem(0, 0);\n\t */\n\tpublic updateItem(groupIndex?: number, itemIndex?: number) {\n\t\tconst item = this.getItem(groupIndex, itemIndex);\n\n\t\tthis._updateItem(item) && this.layout(false);\n\n\t\treturn this;\n\t}\n\t/**\n\t * Update the currently displayed items.\n\t * @ko   .\n\t * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n\t * @example\n\telement.innerHTML = \"2\";\n\telement.style.height = \"400px\";\n\n\telement2.innerHTML = \"2\";\n\telement2.style.height = \"400px\";\n\n\tig.updateItems();\n\t */\n\tpublic updateItems() {\n\t\tthis.getItems().forEach(item => {\n\t\t\tthis._updateItem(item);\n\t\t});\n\t\tthis.layout(false);\n\t\treturn this;\n\t}\n\t/**\n\t * Move to some group or item position.\n\t * @ko      .\n\t * @param {Number} [index] group's index <ko>  index</ko>\n\t * @param {Number} [itemIndex=-1] item's index <ko>  index</ko>\n\t * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n\t */\n\tpublic moveTo(index?: number, itemIndex = 0) {\n\t\tif (this.isProcessing()) {\n\t\t\treturn this;\n\t\t}\n\t\tconst data = this._items.getData(index);\n\n\t\tif (!data) {\n\t\t\treturn this;\n\t\t}\n\t\tconst infinite = this._infinite;\n\t\tconst outlines = data.outlines;\n\t\tconst items = data.items;\n\t\tconst item = items[itemIndex];\n\t\tconst isResize = outlines.start && (outlines.start.length === 0);\n\t\tconst startCursor = infinite.getCursor(\"start\");\n\t\tconst endCursor = infinite.getCursor(\"end\");\n\t\tconst isInCursor = startCursor <= index && index <= endCursor;\n\t\tconst { useRecycle, horizontal } = this.options;\n\n\t\tif (isInCursor || !useRecycle || !isResize) {\n\t\t\tlet pos = item ? item.rect[horizontal ? \"left\" : \"top\"] : Math.max(...outlines.start);\n\t\t\tconst fit = Math.min(...outlines.start);\n\n\t\t\tif (fit < 0) {\n\t\t\t\t// base < 0\n\t\t\t\tthis._fitItems(fit, 0);\n\t\t\t\tpos -= fit;\n\t\t\t}\n\t\t\tconst isAppend = index > startCursor;\n\n\t\t\tif (isInCursor || isAppend) {\n\t\t\t\tthis._scrollTo(pos);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tthis._postLayout({\n\t\t\t\tfromCache: true,\n\t\t\t\tgroups: [data],\n\t\t\t\titems,\n\t\t\t\tnewItems: [],\n\t\t\t\tisAppend,\n\t\t\t\tisTrusted: false,\n\t\t\t\tmoveCache: true,\n\t\t\t\tmoveItem: itemIndex,\n\t\t\t});\n\t\t\treturn this;\n\t\t} else {\n\t\t\tconst isAppend = index > endCursor || index < startCursor - 1;\n\n\t\t\tthis._postCache({\n\t\t\t\tisAppend,\n\t\t\t\tcache: [data],\n\t\t\t\tisTrusted: false,\n\t\t\t\tmoveItem: itemIndex,\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\t/**\n   * Destroys elements, properties, and events used on a grid layout.\n   * @ko     ,  \n   */\n\tpublic destroy() {\n\t\tthis._infinite.clear();\n\t\tthis._watcher.destroy();\n\t\tthis._manager.destroy();\n\t\tthis._reset();\n\t\tthis._items.clear();\n\t\tthis._renderer.destroy();\n\t}\n\tprivate _setContainerSize(size: number) {\n\t\tthis._renderer.setContainerSize(Math.max(this._items.getMaxEdgeValue(), size));\n\t}\n\tprivate _appendLoadingBar() {\n\t\tconst loadingBar = this._loadingBar;\n\t\tconst container = this._renderer.container;\n\n\t\tfor (const type in loadingBar) {\n\t\t\tcontainer.appendChild(loadingBar[type as \"append\" | \"prepend\"]);\n\t\t}\n\t}\n\tprivate _setSize(size: number) {\n\t\tthis._infinite.setSize(this._renderer.getViewSize());\n\t\tthis._manager.setSize(size);\n\t}\n\tprivate _fitItems(base: number, margin = 0) {\n\t\tbase > 0 && this._watcher.scrollBy(-base);\n\t\tthis._items.fit(base, this.options.horizontal);\n\t\tDOMRenderer.renderItems(this.getItems());\n\t\tthis._setContainerSize(this._getEdgeValue(\"end\") || margin);\n\t\tbase < 0 && this._watcher.scrollBy(-base);\n\t}\n\t// called by visible\n\tprivate _fit(useFit = this.options.useFit) {\n\t\tlet base = this._getEdgeValue(\"start\");\n\t\tconst margin = (this._getLoadingStatus() === LOADING_PREPEND && this._status.loadingSize) || 0;\n\t\tconst { isConstantSize, isEqualSize, useRecycle } = this.options;\n\n\t\tif (!useRecycle || !useFit || isConstantSize || isEqualSize) {\n\t\t\tif (base < margin) {\n\t\t\t\tthis._fitItems(base - margin, margin);\n\t\t\t}\n\t\t\tbase = 0;\n\t\t} else if (base !== 0 || margin) {\n\t\t\tthis._fitItems(base - margin, margin);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\tthis._isLoading() && this._renderLoading();\n\t\treturn base;\n\t}\n\tprivate _getEdgeValue(cursor: CursorType) {\n\t\treturn this._infinite.getEdgeValue(cursor);\n\t}\n\tprivate _isProcessing() {\n\t\treturn (this._status.processingStatus & PROCESSING) > 0;\n\t}\n\tprivate _isLoading() {\n\t\treturn this._getLoadingStatus() > 0;\n\t}\n\tprivate _getLoadingStatus() {\n\t\treturn this._status.processingStatus & (LOADING_APPEND | LOADING_PREPEND);\n\t}\n\tprivate _process(status: number, isAdd = true) {\n\t\tif (isAdd) {\n\t\t\tthis._status.processingStatus |= status;\n\t\t} else {\n\t\t\tthis._status.processingStatus -= this._status.processingStatus & status;\n\t\t}\n\t}\n\tprivate _insert({\n\t\telements,\n\t\tisAppend,\n\t\tisChildren,\n\t\tgroupKey = new Date().getTime() + Math.floor(Math.random() * 1000),\n\t}: {\n\t\telements: string | string[] | HTMLElement[] | IJQuery,\n\t\tisAppend?: boolean,\n\t\tisChildren?: boolean,\n\t\tgroupKey?: string | number,\n\t}) {\n\t\tif (this._isProcessing() || elements.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tconst items = ItemManager.from(elements, this.options.itemSelector, {\n\t\t\tgroupKey,\n\t\t});\n\n\t\tif (!items.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst group: IInfiniteGridGroup = {\n\t\t\tgroupKey,\n\t\t\titems,\n\t\t\toutlines: { start: [], end: [] },\n\t\t};\n\t\tconst method = isAppend ? \"append\" : \"prepend\";\n\n\t\tthis._items[method](group);\n\n\t\tif (!isAppend) {\n\t\t\tconst infinite = this._infinite;\n\t\t\tconst startCursor = infinite.getCursor(\"start\");\n\t\t\tconst endCursor = infinite.getCursor(\"end\");\n\n\t\t\tinfinite.setCursor(\"start\", startCursor + 1);\n\t\t\tinfinite.setCursor(\"end\", endCursor + 1);\n\t\t}\n\t\tthis._postLayout({\n\t\t\tfromCache: NO_CACHE,\n\t\t\tgroups: [group],\n\t\t\titems,\n\t\t\tnewItems: items,\n\t\t\tisAppend,\n\t\t\tisChildren,\n\t\t\tisTrusted: NO_TRUSTED,\n\t\t});\n\t}\n\t// add items, and remove items for recycling\n\tprivate _recycle({ start, end }: { start: number, end: number }) {\n\t\tif (!this.options.useRecycle) {\n\t\t\treturn;\n\t\t}\n\t\tDOMRenderer.removeItems(this._items.pluck(\"items\", start, end));\n\t}\n\tprivate _renderLoading(userStyle = this._status.loadingStyle) {\n\t\tif (!this._isLoading()) {\n\t\t\treturn;\n\t\t}\n\t\tconst isAppend = this._getLoadingStatus() === LOADING_APPEND;\n\t\tconst el = this._loadingBar[isAppend ? \"append\" : \"prepend\"];\n\n\t\tif (!el) {\n\t\t\treturn;\n\t\t}\n\t\tconst style = assign({\n\t\t\tposition: \"absolute\",\n\t\t}, userStyle);\n\n\t\tfor (const property in style) {\n\t\t\tel.style[property as keyof StyleType] = style[property as keyof StyleType];\n\t\t}\n\t\tthis._status.loadingSize = this.options.horizontal ? outerWidth(el) : outerHeight(el);\n\t\tconst posName = this.options.horizontal ? \"left\" : \"top\";\n\n\t\tif (!(posName in style)) {\n\t\t\tconst pos = isAppend ? this._getEdgeValue(\"end\") : this._getEdgeValue(\"start\") - this._status.loadingSize;\n\n\t\t\tel.style[posName] = `${pos}px`;\n\t\t}\n\t}\n\tprivate _updateItem(item: IInfiniteGridItem) {\n\t\tif (item && item.el) {\n\t\t\titem.content = item.el.outerHTML;\n\n\t\t\t!this.options.isEqualSize && resetSize(item);\n\t\t\tthis._renderer.updateSize([item]);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tprivate _setScrollPos(pos: number) {\n\t\tthis._watcher.setScrollPos(this._watcher.getContainerOffset() + pos);\n\t}\n\tprivate _scrollTo(pos: number) {\n\t\tthis._watcher.scrollTo(this._watcher.getContainerOffset() + pos);\n\t}\n\tprivate _onImageError(e: IErrorCallbackOptions) {\n\t\t/**\n\t\t * This event is fired when an error occurs in the image.\n\t\t * @ko       .\n\t\t * @event eg.InfiniteGrid#imageError\n\t\t * @param {eg.InfiniteGrid.IErrorCallbackOptions} e The object of data to be sent to an event <ko>   </ko>\n\t\t * @example\n\tig.on(\"imageError\", e => {\n\t  e.remove();\n\t  e.removeItem();\n\t  e.replace(\"http://...jpg\");\n\t  e.replace(imageElement);\n\t  e.replaceItem(\"item html\");\n\t});\n\t\t */\n\t\tthis.trigger(\"imageError\", assign(e, { element: e.item.el }));\n\t}\n\tprivate _postCache({\n\t\tcache,\n\t\tisAppend,\n\t\tisTrusted = true,\n\t\tmoveItem = -1,\n\t}: {\n\t\tcache: IInfiniteGridGroup[],\n\t\tisAppend?: boolean,\n\t\tisTrusted?: boolean,\n\t\tmoveItem?: number,\n\t}) {\n\t\tconst { isConstantSize } = this.options;\n\t\tconst items = ItemManager.pluck(cache, \"items\");\n\t\tlet fromCache = true;\n\t\tconst newItems = items.filter(item => {\n\t\t\tif (!item.orgSize) {\n\t\t\t\tfromCache = false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn !isConstantSize && item.rect.top < DUMMY_POSITION / 10;\n\t\t});\n\n\t\tthis._postLayout({\n\t\t\tfromCache,\n\t\t\tgroups: cache,\n\t\t\titems,\n\t\t\tnewItems,\n\t\t\tisAppend,\n\t\t\tisTrusted,\n\t\t\tmoveItem,\n\t\t});\n\t}\n\tprivate _postLayout({\n\t\tfromCache,\n\t\tgroups,\n\t\titems = ItemManager.pluck(groups, \"items\"),\n\t\tnewItems,\n\t\tisAppend,\n\t\tisChildren,\n\t\tisTrusted,\n\t\tmoveCache,\n\t\tmoveItem = -2,\n\t}: {\n\t\tfromCache: boolean,\n\t\tgroups: IInfiniteGridGroup[],\n\t\titems: IInfiniteGridItem[],\n\t\tnewItems?: IInfiniteGridItem[],\n\t\tisAppend: boolean,\n\t\tisChildren?: boolean,\n\t\tisTrusted?: boolean,\n\t\tmoveCache?: boolean,\n\t\tmoveItem?: number,\n\t}) {\n\t\tthis._process(PROCESSING);\n\t\tconst method = isAppend ? \"append\" : \"prepend\";\n\t\tconst itemManager = this._items;\n\t\tconst horizontal = this.options.horizontal;\n\n\t\t// If container has children, it does not render first.\n\t\tif (!isChildren) {\n\t\t\tDOMRenderer.createElements(items);\n\t\t\tthis._renderer[method](items);\n\t\t}\n\t\tthis._manager[method]({\n\t\t\tgroups,\n\t\t\titems: newItems,\n\t\t}, {\n\t\t\t\tcomplete: () => {\n\t\t\t\t\tconst infinite = this._infinite;\n\t\t\t\t\tconst startCursor = Math.max(infinite.getCursor(\"start\"), 0);\n\t\t\t\t\tconst endCursor = Math.max(infinite.getCursor(\"end\"), 0);\n\t\t\t\t\tlet requestStartCursor = itemManager.indexOf(groups[0].groupKey);\n\t\t\t\t\tlet requestEndCursor = itemManager.indexOf(groups[groups.length - 1].groupKey);\n\t\t\t\t\tlet isInCursor = true;\n\n\t\t\t\t\tif (requestStartCursor > endCursor + 1 || requestEndCursor < startCursor - 1) {\n\t\t\t\t\t\tisInCursor = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (isInCursor) {\n\t\t\t\t\t\tif (isAppend) {\n\t\t\t\t\t\t\trequestStartCursor = startCursor;\n\t\t\t\t\t\t\trequestEndCursor = Math.max(endCursor, requestEndCursor);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trequestStartCursor = Math.max(Math.min(startCursor, requestStartCursor), 0);\n\t\t\t\t\t\t\trequestEndCursor = endCursor;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t!isInCursor && this._recycle({ start: startCursor, end: endCursor });\n\t\t\t\t\tinfinite.setCursor(\"start\", requestStartCursor);\n\t\t\t\t\tinfinite.setCursor(\"end\", requestEndCursor);\n\n\t\t\t\t\tif (moveItem > -1) {\n\t\t\t\t\t\tconst pos = items[moveItem].rect[horizontal ? \"left\" : \"top\"];\n\n\t\t\t\t\t\tif (!isInCursor && !moveCache) {\n\t\t\t\t\t\t\titemManager.clearOutlines(requestStartCursor, requestEndCursor);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._scrollTo(pos);\n\t\t\t\t\t\tthis._setScrollPos(pos);\n\t\t\t\t\t}\n\t\t\t\t\tthis._onLayoutComplete({\n\t\t\t\t\t\titems,\n\t\t\t\t\t\tisAppend,\n\t\t\t\t\t\tfromCache,\n\t\t\t\t\t\tisTrusted,\n\t\t\t\t\t\tuseRecycle: false,\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\terror: e => this._onImageError(e),\n\t\t\t\tend: ({ remove, layout }) => {\n\t\t\t\t\tremove.forEach(el => this.remove(el, false));\n\t\t\t\t\tif (layout) {\n\t\t\t\t\t\tthis.layout(false);\n\t\t\t\t\t} else if (!this.isProcessing() && this.options.useRecycle) {\n\t\t\t\t\t\tconst watcher = this._watcher;\n\t\t\t\t\t\tconst scrollPos = watcher.getScrollPos();\n\n\t\t\t\t\t\tthis._infinite.recycle(scrollPos, isAppend);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t});\n\t\treturn this;\n\t}\n\t// called by visible\n\tprivate _requestAppend({ cache }: { cache?: IInfiniteGridGroup[] }) {\n\t\tif (this._isProcessing()) {\n\t\t\treturn;\n\t\t}\n\t\tif (cache && cache.length) {\n\t\t\tthis._postCache({ cache, isAppend: APPEND });\n\t\t} else {\n\t\t\t/**\n\t\t\t * This event is fired when a card element must be added at the bottom or right of a layout because there is no card to be displayed on screen when a user scrolls near bottom or right.\n\t\t\t * @ko          .          \n\t\t\t * @event eg.InfiniteGrid#append\n\t\t\t * @param {Object} param The object of data to be sent to an event <ko>   </ko>\n\t\t\t * @param {String|Number} groupKey The group key of the first group visible on the screen <ko>    </ko>\n\t\t\t * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>     true,  API    false .</ko>\n\t\t\t * @param {Function} param.startLoading Start loading for append loading data. <ko>     . </ko>\n\t\t\t * @param {Object} param.startLoading.userStyle The custom style to apply to this loading bar for start. <ko>         </ko>\n\t\t\t * @param {Function} param.endLoading End loading after startLoading() for append/prepend loading data. <ko>   append/prepend startLoading()    .</ko>\n\t\t\t * @param {Object} param.endLoading.userStyle The custom style to apply to this loading bar for start. <ko>         </ko>\n\t\t\t */\n\t\t\tthis.trigger(\"append\", {\n\t\t\t\tisTrusted: TRUSTED,\n\t\t\t\tgroupKey: this.getGroupKeys().pop() || \"\",\n\t\t\t\tstartLoading: (userStyle: StyleType) => {\n\t\t\t\t\tthis.startLoading(true, userStyle);\n\t\t\t\t},\n\t\t\t\tendLoading: (userStyle: StyleType) => {\n\t\t\t\t\tthis.endLoading(userStyle);\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\t}\n\t// called by visible\n\tprivate _requestPrepend({ cache }: { cache?: IInfiniteGridGroup[] }) {\n\t\tthis._fit(this.options.useFit || !cache.length);\n\t\tif (this._isProcessing()) {\n\t\t\treturn;\n\t\t}\n\t\tif (cache && cache.length) {\n\t\t\tthis._postCache({ cache, isAppend: PREPEND });\n\t\t} else {\n\t\t\t/**\n\t\t\t * This event is fired when a card element must be added at the top or left of a layout because there is no card to be displayed on screen when a user scrolls near top or left.\n\t\t\t * @ko         .          .\n\t\t\t * @event eg.InfiniteGrid#prepend\n\t\t\t * @param {Object} param The object of data to be sent to an event <ko>   </ko>\n\t\t\t * @param {String|Number} groupKey The group key of the first group visible on the screen <ko>    </ko>\n\t\t\t * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>     true,  API    false .</ko>\n\t\t\t * @param {Function} param.startLoading Start loading for prepend loading data. <ko>     . </ko>\n\t\t\t * @param {Object} param.startLoading.userStyle The custom style to apply to this loading bar for start. <ko>         </ko>\n\t\t\t * @param {Function} param.endLoading End loading after startLoading() for append/prepend loading data. <ko>   append/prepend startLoading()    .</ko>\n\t\t\t * @param {Object} param.endLoading.userStyle The custom style to apply to this loading bar for start. <ko>         </ko>\n\t\t\t */\n\t\t\tthis.trigger(\"prepend\", {\n\t\t\t\tisTrusted: TRUSTED,\n\t\t\t\tgroupKey: this.getGroupKeys().shift(),\n\t\t\t\tstartLoading: (userStyle: StyleType) => {\n\t\t\t\t\tthis.startLoading(false, userStyle);\n\t\t\t\t},\n\t\t\t\tendLoading: (userStyle: StyleType) => {\n\t\t\t\t\tthis.endLoading(userStyle);\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\t}\n\tprivate _onResize() {\n\t\tthis.layout(true);\n\t}\n\tprivate _onCheck({\n\t\tisForward,\n\t\tscrollPos,\n\t\thorizontal,\n\t\torgScrollPos,\n\t}: {\n\t\tisForward: boolean,\n\t\tscrollPos: number,\n\t\thorizontal: boolean,\n\t\torgScrollPos: number,\n\t}) {\n\t\t/**\n\t\t * This event is fired when the user scrolls.\n\t\t * @ko      .\n\t\t * @event eg.InfiniteGrid#change\n\t\t * @param {Object} param The object of data to be sent to an event <ko>   </ko>\n\t\t * @param {Boolean} param.isForward Indicates whether the scroll progression direction is forward or backword. <ko>    ,   .</ko>\n\t\t * @param {Number} param.scrollPos Current scroll position value relative to the infiniteGrid container element. <ko>infiniteGrid      </ko>\n\t\t * @param {Boolean} param.orgScrollPos Current position of the scroll <ko>  </ko>\n\t\t * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>     true,  API    false .</ko>\n\t\t * @param {Boolean} options.horizontal Direction of the scroll movement (true: horizontal, false: vertical) <ko>   (true , false </ko>\n\t\t */\n\t\tthis.trigger(\"change\", {\n\t\t\tisForward,\n\t\t\thorizontal,\n\t\t\tscrollPos,\n\t\t\torgScrollPos,\n\t\t});\n\t\tthis._infinite.scroll(scrollPos);\n\t}\n\tprivate _onLayoutComplete({\n\t\titems,\n\t\tisAppend,\n\t\tisTrusted = false,\n\t\tuseRecycle = this.options.useRecycle,\n\t\tfromCache = false,\n\t\tisLayout = false,\n\t}: {\n\t\titems: IInfiniteGridItem[],\n\t\tisAppend: boolean,\n\t\tisTrusted: boolean,\n\t\tuseRecycle: boolean,\n\t\tfromCache: boolean,\n\t\tisLayout?: boolean,\n\t}) {\n\t\tconst viewSize = this._renderer.getViewSize();\n\n\t\tif (!isAppend) {\n\t\t\tthis._fit();\n\t\t} else {\n\t\t\tthis._isLoading() && this._renderLoading();\n\t\t}\n\n\t\tconst watcher = this._watcher;\n\t\tconst scrollPos = watcher.getScrollPos();\n\n\t\t// recycle after _fit beacause prepend and append are occured simultaneously by scroll.\n\t\tif (!isLayout && useRecycle && !this._isLoading()) {\n\t\t\tthis._infinite.recycle(scrollPos, isAppend);\n\t\t}\n\n\t\tconst size = this._getEdgeValue(\"end\");\n\n\t\tif (isAppend) {\n\t\t\tthis._setContainerSize(size + this._status.loadingSize || 0);\n\t\t\tif (scrollPos > 0) {\n\t\t\t\t!IS_IOS && this._scrollTo(scrollPos);\n\t\t\t}\n\t\t}\n\t\t!isLayout && this._process(PROCESSING, false);\n\n\t\t/**\n\t\t * This event is fired when layout is successfully arranged through a call to the append(), prepend(), or layout() method.\n\t\t * @ko      . append()  prepend() , layout()        \n\t\t * @event eg.InfiniteGrid#layoutComplete\n\t\t *\n\t\t * @param {Object} param The object of data to be sent to an event <ko>   </ko>\n\t\t * @param {Array} param.target Rearranged card elements<ko>  </ko>\n\t\t * @param {Boolean} param.fromCache Check whether these items are cache or not <ko>    .</ko>\n\t\t * @param {Boolean} param.isLayout Returns true if this is an event called by resize event or layout method. Returns false if this is an event called by adding an item. <ko>     layout()    true,    false .</ko>\n\t\t * @param {Boolean} param.isAppend Checks whether the append() method is used to add a card element. It returns true even though the layoutComplete event is fired after the layout() method is called. <ko>  append()   . layout()    layoutComplete   'true' .</ko>\n\t\t * @param {Boolean} param.isScroll Checks whether scrolling has occurred after the append(), prepend(), ..., etc method is called <ko>append, prend      .</ko>\n\t\t * @param {Number} param.scrollPos Current scroll position value relative to the infiniteGrid container element. <ko>infiniteGrid      </ko>\n\t\t * @param {Number} param.orgScrollPos Current position of the scroll <ko>  </ko>\n\t\t * @param {Number} param.size The size of container element <ko>  </ko>\n\t\t * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>     true,  API    false .</ko>\n\t\t * @param {Function} param.endLoading End loading after startLoading() for append/prepend loading data. <ko>   append/prepend startLoading()    .</ko>\n\t\t * @param {Object} param.endLoading.userStyle The custom style to apply to this loading bar for start. <ko>         </ko>\n\t\t */\n\t\tthis.trigger(\"layoutComplete\", {\n\t\t\ttarget: items.concat(),\n\t\t\tisAppend,\n\t\t\tisTrusted,\n\t\t\tfromCache,\n\t\t\tisLayout,\n\t\t\tisScroll: viewSize < watcher.getContainerOffset() + size,\n\t\t\tscrollPos,\n\t\t\torgScrollPos: watcher.getOrgScrollPos(),\n\t\t\tsize,\n\t\t\tendLoading: (userStyle: StyleType) => {\n\t\t\t\tthis.endLoading(userStyle);\n\t\t\t},\n\t\t});\n\t\tthis._infinite.scroll(scrollPos);\n\t}\n\tprivate _reset() {\n\t\tthis._status = {\n\t\t\tprocessingStatus: IDLE,\n\t\t\tloadingSize: 0,\n\t\t\tloadingStyle: {},\n\t\t};\n\t}\n}\n\nexport default InfiniteGrid;\n","import { ALIGN, APPEND, PREPEND } from \"../consts\";\nimport { getStyleNames, assignOptions, fill, cloneItems } from \"../utils\";\nimport { ILayout, IAlign, IRectlProperties, IInfiniteGridItem, IInfiniteGridGroup } from \"../types\";\n\n// ALIGN\nconst { START, CENTER, END, JUSTIFY } = ALIGN;\n\n/**\n * @classdesc The GridLayout is a layout that stacks cards with the same width as a stack of bricks. Adjust the width of all images to the same size, find the lowest height column, and insert a new card.\n * @ko GridLayout          .      ,        .            .\n * @class eg.InfiniteGrid.GridLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.GridLayout module <ko>eg.InfiniteGrid.GridLayout   </ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>  </ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>   (false: , true: )</ko>\n * @param {Boolean} [options.align=START] Align of the position of the items (START, CENTER, END, JUSTIFY) <ko>   (START, CENTER, END, JUSTIFY)</ko>\n * @param {Boolean} [options.itemSize=0] The size of the items. If it is 0, it is calculated as the size of the first item in items. <ko>  .    0,      . </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid(\"#grid\". {\n  horizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.GridLayout, {\n  margin: 10,\n  align: \"start\",\n  itemSize: 200\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.GridLayout({\n  margin: 10,\n  align: \"center\",\n  itemSize: 200,\n  horizontal: true,\n});\n\n</script>\n```\n **/\nclass GridLayout implements ILayout {\n\tpublic options: {\n\t\thorizontal: boolean,\n\t\tmargin: number,\n\t\talign: IAlign[keyof IAlign],\n\t\titemSize: number,\n\t};\n\tprivate _size: number;\n\tprivate _columnSize: number;\n\tprivate _columnLength: number;\n\tprivate _style: IRectlProperties;\n\tconstructor(options: Partial<GridLayout[\"options\"]> = {}) {\n\t\tthis.options = assignOptions({\n\t\t\tmargin: 0,\n\t\t\thorizontal: false,\n\t\t\talign: START,\n\t\t\titemSize: 0,\n\t\t}, options);\n\t\tthis._size = 0;\n\t\tthis._columnSize = 0;\n\t\tthis._columnLength = 0;\n\t\tthis._style = getStyleNames(this.options.horizontal);\n\t}\n\t/**\n\t * Adds items at the bottom of a outline.\n\t * @ko    .\n\t * @method eg.InfiniteGrid.GridLayout#append\n\t * @param {Array} items Array of items to be layouted <ko>  </ko>\n\t * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n\t * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n\t * @example\n\t * layout.prepend(items, [100, 200, 300, 400]);\n\t */\n\tpublic append(items: IInfiniteGridItem[], outline?: number[], cache?: boolean) {\n\t\treturn this._insert(items, outline, APPEND, cache);\n\t}\n\t/**\n\t * Adds items at the top of a outline.\n\t * @ko    .\n\t * @method eg.InfiniteGrid.GridLayout#prepend\n\t * @param {Array} items Array of items to be layouted <ko>  </ko>\n\t * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n\t * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n\t * @example\n\t * layout.prepend(items, [100, 200, 300, 400]);\n\t */\n\tpublic prepend(items: IInfiniteGridItem[], outline?: number[], cache?: boolean) {\n\t\treturn this._insert(items, outline, PREPEND, cache);\n\t}\n\t/**\n\t * Adds items of groups at the bottom of a outline.\n\t * @ko     .\n\t * @method eg.InfiniteGrid.GridLayout#layout\n\t * @param {Array} groups Array of groups to be layouted <ko>  </ko>\n\t * @param {Array} outline Array of outline points to be reference points <ko>    </ko>\n\t * @return {eg.InfiniteGrid.GridLayout} An instance of a module itself<ko>  </ko>\n\t * @example\n\t * layout.layout(groups, [100, 200, 300, 400]);\n\t */\n\tpublic layout(groups: IInfiniteGridGroup[] = [], outline: number[] = []) {\n\t\tconst firstItem = (groups.length && groups[0].items.length && groups[0].items[0]);\n\n\t\tthis.checkColumn(firstItem);\n\n\t\t// if outlines' length and columns' length are now same, re-caculate outlines.\n\t\tlet startOutline: number[];\n\n\t\tif (outline.length !== this._columnLength) {\n\t\t\tconst pos = outline.length === 0 ? 0 : Math.min(...outline);\n\n\t\t\t// re-layout items.\n\t\t\tstartOutline = fill(new Array(this._columnLength), pos);\n\t\t} else {\n\t\t\tstartOutline = outline.slice();\n\t\t}\n\t\tgroups.forEach(group => {\n\t\t\tconst items = group.items;\n\t\t\tconst result = this._layout(items, startOutline, APPEND);\n\n\t\t\tgroup.outlines = result;\n\t\t\tstartOutline = result.end;\n\t\t});\n\n\t\treturn this;\n\t}\n\t/**\n\t * Set the viewport size of the layout.\n\t * @ko    .\n\t * @method eg.InfiniteGrid.GridLayout#setSize\n\t * @param {Number} size The viewport size of container area where items are added to a layout <ko>      </ko>\n\t * @return {eg.InfiniteGrid.GridLayout} An instance of a module itself<ko>  </ko>\n\t * @example\n\t * layout.setSize(800);\n\t */\n\tpublic setSize(size: number) {\n\t\tthis._size = size;\n\t\treturn this;\n\t}\n\tprivate checkColumn(item: IInfiniteGridItem) {\n\t\tconst { itemSize, margin, horizontal } = this.options;\n\t\tconst sizeName = horizontal ? \"height\" : \"width\";\n\t\tconst columnSize = Math.floor(itemSize || (item && item.size[sizeName]) || 0) || 0;\n\n\t\tthis._columnSize = columnSize;\n\t\tif (!columnSize) {\n\t\t\tthis._columnLength = 1;\n\t\t\treturn;\n\t\t}\n\t\tthis._columnLength = Math.max(Math.floor((this._size + margin) / (columnSize + margin)), 1);\n\t}\n\tprivate _layout(items: IInfiniteGridItem[], outline: number[], isAppend?: boolean) {\n\t\tconst length = items.length;\n\t\tconst margin = this.options.margin;\n\t\tconst align = this.options.align;\n\t\tconst style = this._style;\n\n\t\tconst size1Name = style.size1;\n\t\tconst size2Name = style.size2;\n\t\tconst pos1Name = style.startPos1;\n\t\tconst pos2Name = style.startPos2;\n\t\tconst columnSize = this._columnSize;\n\t\tconst columnLength = this._columnLength;\n\n\t\tconst size = this._size;\n\t\tconst viewDist = (size - (columnSize + margin) * columnLength + margin);\n\n\t\tconst pointCaculateName = isAppend ? \"min\" : \"max\";\n\t\tconst startOutline = outline.slice();\n\t\tconst endOutline = outline.slice();\n\n\t\tfor (let i = 0; i < length; ++i) {\n\t\t\tconst point = Math[pointCaculateName](...endOutline) || 0;\n\t\t\tlet index = endOutline.indexOf(point);\n\t\t\tconst item = items[isAppend ? i : length - 1 - i];\n\t\t\tconst size1 = item.size[size1Name];\n\t\t\tconst size2 = item.size[size2Name];\n\t\t\tconst pos1 = isAppend ? point : point - margin - size1;\n\t\t\tconst endPos1 = pos1 + size1 + margin;\n\n\t\t\tif (index === -1) {\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\tlet pos2 = (columnSize + margin) * index;\n\n\t\t\t// ALIGN\n\t\t\tif (align === CENTER) {\n\t\t\t\tpos2 += viewDist / 2;\n\t\t\t} else if (align === END) {\n\t\t\t\tpos2 += viewDist + columnSize - size2;\n\t\t\t} else if (align === JUSTIFY) {\n\t\t\t\tif (columnLength <= 1) {\n\t\t\t\t\tpos2 += viewDist / 2;\n\t\t\t\t} else {\n\t\t\t\t\tpos2 = (size - columnSize) / (columnLength - 1) * index;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// tetris\n\t\t\titem.rect = {\n\t\t\t\t[pos1Name as \"top\"]: pos1,\n\t\t\t\t[pos2Name as \"left\"]: pos2,\n\t\t\t};\n\t\t\titem.column = index;\n\t\t\tendOutline[index] = isAppend ? endPos1 : pos1;\n\t\t}\n\t\tif (!isAppend) {\n\t\t\titems.sort((a, b) => {\n\t\t\t\tconst item1pos1 = a.rect[pos1Name];\n\t\t\t\tconst item1pos2 = a.rect[pos2Name];\n\t\t\t\tconst item2pos1 = b.rect[pos1Name];\n\t\t\t\tconst item2pos2 = b.rect[pos2Name];\n\n\t\t\t\tif (item1pos1 - item2pos1) {\n\t\t\t\t\treturn item1pos1 - item2pos1;\n\t\t\t\t}\n\t\t\t\treturn item1pos2 - item2pos2;\n\t\t\t});\n\t\t}\n\t\t// if append items, startOutline is low, endOutline is high\n\t\t// if prepend items, startOutline is high, endOutline is low\n\t\treturn {\n\t\t\tstart: isAppend ? startOutline : endOutline,\n\t\t\tend: isAppend ? endOutline : startOutline,\n\t\t};\n\t}\n\tprivate _insert(\n\t\titems: IInfiniteGridItem[] = [],\n\t\toutline: number[] = [],\n\t\tisAppend?: boolean,\n\t\tcache?: boolean,\n\t) {\n\t\tconst clone = cache ? items : cloneItems(items);\n\n\t\tlet startOutline = outline;\n\n\t\tif (!this._columnLength) {\n\t\t\tthis.checkColumn(items[0]);\n\t\t}\n\t\tif (outline.length !== this._columnLength) {\n\t\t\tstartOutline = fill(new Array(this._columnLength), outline.length ? (Math[isAppend ? \"min\" : \"max\"](...outline) || 0) : 0);\n\t\t}\n\n\t\tconst result = this._layout(clone, startOutline, isAppend);\n\n\t\treturn {\n\t\t\titems: clone,\n\t\t\toutlines: result,\n\t\t};\n\t}\n}\n\nexport default GridLayout;\n","import { APPEND, PREPEND, DUMMY_POSITION } from \"../consts\";\nimport { getStyleNames, assignOptions, fill, cloneItems } from \"../utils\";\nimport { ILayout, IRectlProperties, ISize, IInfiniteGridGroup, IInfiniteGridItem } from \"../types\";\n\nexport type FrameType = number[][];\nexport interface IFrameShape {\n\tleft?: number;\n\ttop?: number;\n\ttype: any;\n\twidth: number;\n\theight: number;\n\tindex?: number;\n}\nexport interface IFrameLayoutInterface {\n\thorizontal: boolean;\n\tmargin: number;\n\tframe: FrameType;\n\tframeFill: boolean;\n\titemSize: number | ISize;\n\t[key: string]: any;\n}\n/*\nFrame\n[\n[1, 1, 1, 1, 1],\n[0, 0, 2, 2, 2],\n[0, 0, 2, 2, 2],\n[3, 4, 5, 5, 5],\n]\n*/\nfunction disableFrame(\n\tframe: FrameType,\n\ttype: number,\n\ttop: number,\n\tleft: number,\n\twidth: number,\n\theight: number,\n) {\n\tfor (let i = top; i < top + height; ++i) {\n\t\tfor (let j = left; j < left + width; ++j) {\n\t\t\tif (type !== frame[i][j]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tframe[i][j] = 0;\n\t\t}\n\t}\n}\nfunction searchShapeInFrame(\n\tframe: FrameType,\n\ttype: number,\n\ttop: number,\n\tleft: number,\n\twidth: number,\n\theight: number,\n) {\n\tconst size: IFrameShape = {\n\t\tleft,\n\t\ttop,\n\t\ttype,\n\t\twidth: 1,\n\t\theight: 1,\n\t};\n\n\tfor (let i = left; i < width; ++i) {\n\t\tif (frame[top][i] === type) {\n\t\t\tsize.width = i - left + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tfor (let i = top; i < height; ++i) {\n\t\tif (frame[i][left] === type) {\n\t\t\tsize.height = i - top + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\t// After finding the shape, it will not find again.\n\tdisableFrame(frame, type, top, left, size.width, size.height);\n\treturn size;\n}\nfunction getShapes(frame: FrameType) {\n\tconst height = frame.length;\n\tconst width = height ? frame[0].length : 0;\n\tconst shapes: IFrameShape[] = [];\n\n\tfor (let i = 0; i < height; ++i) {\n\t\tfor (let j = 0; j < width; ++j) {\n\t\t\tconst type = frame[i][j];\n\n\t\t\tif (!type) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// Separate shapes with other numbers.\n\t\t\tshapes.push(searchShapeInFrame(frame, type, i, j, width, height));\n\t\t}\n\t}\n\tshapes.sort((a, b) => (a.type < b.type ? -1 : 1));\n\treturn {\n\t\tshapes,\n\t\twidth,\n\t\theight,\n\t};\n}\n/**\n * @classdesc FrameLayout is a layout that allows you to place cards in a given frame. It is a layout that corresponds to a level intermediate between the placement of the image directly by the designer and the layout using the algorithm.\n * @ko FrameLayout      .             .\n * @class eg.InfiniteGrid.FrameLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.FrameLayout module <ko>eg.InfiniteGrid.FrameLayout   </ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>  </ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>   (false: , true: )</ko>\n * @param {Boolean} [options.itemSize=0] The size of the items. If it is 0, it is calculated as the size of the first item in items. <ko>  .    0,      . </ko>\n * @param {Boolean} [options.frame=[]] The size of the items. If it is 0, it is calculated as the size of the first item in items. <ko>  .    0,      . </ko>\n * @param {Boolean} [options.frameFill=true] Make sure that the frame can be attached after the previous frame. <ko>          . </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid(\"#grid\". {\n  horizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.FrameLayout, {\n  margin: 10,\n  itemSize: 200,\n  frame: [\n    [1, 1, 1, 1, 1],\n    [0, 0, 2, 2, 2],\n    [0, 0, 2, 2, 2],\n    [3, 4, 5, 5, 5],\n  ],\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.FrameLayout({\n  margin: 10,\n  itemSize: 200,\n  horizontal: true,\n  frame: [\n    [1, 1, 1, 1, 1],\n    [0, 0, 2, 2, 2],\n    [0, 0, 2, 2, 2],\n    [3, 4, 5, 5, 5],\n  ],\n});\n\n</script>\n```\n **/\nclass FrameLayout implements ILayout {\n\tpublic options: IFrameLayoutInterface;\n\tprotected _itemSize: number | ISize;\n\tprotected _shapes: {\n\t\tshapes: IFrameShape[],\n\t\twidth?: number,\n\t\theight?: number,\n\t};\n\tprotected _size: number;\n\tprotected _style: IRectlProperties;\n\n\tconstructor(options: Partial<IFrameLayoutInterface> = {}) {\n\t\tthis.options = assignOptions({\n\t\t\tmargin: 0,\n\t\t\thorizontal: false,\n\t\t\titemSize: 0,\n\t\t\tframe: [],\n\t\t\tframeFill: true,\n\t\t}, options);\n\t\tconst frame = this.options.frame.map(row => row.slice());\n\n\t\tthis._itemSize = this.options.itemSize || 0;\n\t\t// divide frame into shapes.\n\t\tthis._shapes = getShapes(frame);\n\t\tthis._size = 0;\n\t\tthis._style = getStyleNames(this.options.horizontal);\n\t}\n\t/**\n\t * Adds items of groups at the bottom of a outline.\n\t * @ko     .\n\t * @method eg.InfiniteGrid.FrameLayout#layout\n\t * @param {Array} groups Array of groups to be layouted <ko>  </ko>\n\t * @param {Array} outline Array of outline points to be reference points <ko>    </ko>\n\t * @return {eg.InfiniteGrid.FrameLayout} An instance of a module itself<ko>  </ko>\n\t * @example\n\t * layout.layout(groups, [100, 200, 300, 400]);\n\t */\n\tpublic layout(groups: IInfiniteGridGroup[] = [], outline: number[] = []) {\n\t\tconst length = groups.length;\n\t\tlet point = outline;\n\n\t\tfor (let i = 0; i < length; ++i) {\n\t\t\tconst group = groups[i];\n\t\t\tconst outlines = this._layout(group.items, point, APPEND);\n\n\t\t\tgroup.outlines = outlines;\n\t\t\tpoint = outlines.end;\n\t\t}\n\t\treturn this;\n\t}\n\t/**\n\t * Set the viewport size of the layout.\n\t * @ko    .\n\t * @method eg.InfiniteGrid.FrameLayout#setSize\n\t * @param {Number} size The viewport size of container area where items are added to a layout <ko>      </ko>\n\t * @return {eg.InfiniteGrid.FrameLayout} An instance of a module itself<ko>  </ko>\n\t * @example\n\t * layout.setSize(800);\n\t */\n\tpublic setSize(size: number) {\n\t\tthis._size = size;\n\t\treturn this;\n\t}\n\t/**\n\t * Adds items at the bottom of a outline.\n\t * @ko    .\n\t * @method eg.InfiniteGrid.FrameLayout#append\n\t * @param {Array} items Array of items to be layouted <ko>  </ko>\n\t * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n\t * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n\t * @example\n\t * layout.prepend(items, [100]);\n\t */\n\tpublic append(items: IInfiniteGridItem[], outline?: number[], cache?: boolean) {\n\t\treturn this._insert(items, outline, APPEND, cache);\n\t}\n\t/**\n\t * Adds items at the top of a outline.\n\t * @ko    .\n\t * @method eg.InfiniteGrid.FrameLayout#prepend\n\t * @param {Array} items Array of items to be layouted <ko>  </ko>\n\t * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n\t * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n\t * @example\n\t * layout.prepend(items, [100]);\n\t */\n\tpublic prepend(items: IInfiniteGridItem[], outline?: number[], cache?: boolean) {\n\t\treturn this._insert(items, outline, PREPEND, cache);\n\t}\n\tprotected _getItemSize() {\n\t\tthis._checkItemSize();\n\n\t\treturn this._itemSize;\n\t}\n\tprotected _checkItemSize() {\n\t\tif (this.options.itemSize) {\n\t\t\tthis._itemSize = this.options.itemSize;\n\t\t\treturn;\n\t\t}\n\t\tconst style = this._style;\n\t\tconst size = style.size2;\n\t\tconst margin = this.options.margin;\n\n\t\t// if itemSize is not in options, caculate itemSize from size.\n\t\tthis._itemSize = (this._size + margin) / this._shapes[size] - margin;\n\t}\n\tprotected _layout(items: IInfiniteGridItem[], outline: number[] = [], isAppend?: boolean) {\n\t\tconst length = items.length;\n\t\tconst style = this._style;\n\t\tconst { margin, frameFill } = this.options;\n\t\tconst size1Name = style.size1;\n\t\tconst size2Name = style.size2;\n\t\tconst pos1Name = style.startPos1;\n\t\tconst pos2Name = style.startPos2;\n\t\tconst itemSize = this._getItemSize();\n\t\tconst isItemObject = typeof itemSize === \"object\";\n\t\tconst itemSize2 = isItemObject ? (itemSize as ISize)[size2Name] : itemSize as number;\n\t\tconst itemSize1 = isItemObject ? (itemSize as ISize)[size1Name] : itemSize as number;\n\t\tconst shapesSize = this._shapes[size2Name];\n\t\tconst shapes = this._shapes.shapes;\n\t\tconst shapesLength = shapes.length;\n\t\tconst startOutline = fill(new Array(shapesSize), DUMMY_POSITION);\n\t\tconst endOutline = fill(new Array(shapesSize), DUMMY_POSITION);\n\t\tlet dist = 0;\n\t\tlet end = 0;\n\n\t\tif (!shapesLength) {\n\t\t\treturn { start: outline, end: outline };\n\t\t}\n\t\tfor (let i = 0; i < length; i += shapesLength) {\n\t\t\tfor (let j = 0; j < shapesLength && i + j < length; ++j) {\n\t\t\t\tconst item = items[i + j];\n\t\t\t\tconst shape = shapes[j];\n\t\t\t\tconst shapePos1 = shape[pos1Name];\n\t\t\t\tconst shapePos2 = shape[pos2Name];\n\t\t\t\tconst shapeSize1 = shape[size1Name];\n\t\t\t\tconst shapeSize2 = shape[size2Name];\n\t\t\t\tconst pos1 = end - dist + shapePos1 * (itemSize1 + margin);\n\t\t\t\tconst pos2 = shapePos2 * (itemSize2 + margin);\n\t\t\t\tconst size1 = shapeSize1 * (itemSize1 + margin) - margin;\n\t\t\t\tconst size2 = shapeSize2 * (itemSize2 + margin) - margin;\n\n\t\t\t\tfor (let k = shapePos2; k < shapePos2 + shapeSize2 && k < shapesSize; ++k) {\n\t\t\t\t\tif (startOutline[k] === DUMMY_POSITION) {\n\t\t\t\t\t\tstartOutline[k] = pos1;\n\t\t\t\t\t}\n\t\t\t\t\tstartOutline[k] = Math.min(startOutline[k], pos1);\n\t\t\t\t\tendOutline[k] = Math.max(endOutline[k], pos1 + size1 + margin);\n\t\t\t\t}\n\t\t\t\titem.rect = {\n\t\t\t\t\t[pos1Name]: pos1,\n\t\t\t\t\t[pos2Name]: pos2,\n\t\t\t\t\t[size1Name]: size1,\n\t\t\t\t\t[size2Name]: size2,\n\t\t\t\t};\n\t\t\t}\n\t\t\tend = Math.max(...endOutline);\n\t\t\t// check dist once\n\t\t\tif (i !== 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// find & fill empty block\n\t\t\tif (!frameFill) {\n\t\t\t\tdist = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdist = end;\n\n\t\t\tfor (let j = 0; j < shapesSize; ++j) {\n\t\t\t\tif (startOutline[j] === DUMMY_POSITION) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// the dist between frame's end outline and next frame's start outline\n\t\t\t\t// expect that next frame's start outline is startOutline[j] + end\n\t\t\t\tdist = Math.min(startOutline[j] + end - endOutline[j], dist);\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < shapesSize; ++i) {\n\t\t\tif (startOutline[i] !== DUMMY_POSITION) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstartOutline[i] = Math.max(...startOutline);\n\t\t\tendOutline[i] = startOutline[i];\n\t\t}\n\t\t// The target outline is start outline when type is APPENDING\n\t\tconst targetOutline = isAppend ? startOutline : endOutline;\n\t\tconst prevOutlineEnd = outline.length === 0 ? 0 : Math[isAppend ? \"max\" : \"min\"](...outline);\n\t\tlet prevOutlineDist = isAppend ? 0 : end;\n\n\t\tif (frameFill && outline.length === shapesSize) {\n\t\t\tprevOutlineDist = -DUMMY_POSITION;\n\t\t\tfor (let i = 0; i < shapesSize; ++i) {\n\t\t\t\tif (startOutline[i] === endOutline[i]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// if appending type is PREPEND, subtract dist from appending group's height.\n\n\t\t\t\tprevOutlineDist = Math.min(targetOutline[i] + prevOutlineEnd - outline[i], prevOutlineDist);\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < shapesSize; ++i) {\n\t\t\tstartOutline[i] += prevOutlineEnd - prevOutlineDist;\n\t\t\tendOutline[i] += prevOutlineEnd - prevOutlineDist;\n\t\t}\n\t\titems.forEach(item => {\n\t\t\titem.rect[pos1Name] += prevOutlineEnd - prevOutlineDist;\n\t\t});\n\t\treturn {\n\t\t\tstart: startOutline.map(point => parseInt(point, 10)),\n\t\t\tend: endOutline.map(point => parseInt(point, 10)),\n\t\t};\n\t}\n\tprivate _insert(items: IInfiniteGridItem[] = [], outline: number[] = [], isAppend?: boolean, cache?: boolean) {\n\t\t// this only needs the size of the item.\n\t\tconst clone = cache ? items : cloneItems(items);\n\n\t\treturn {\n\t\t\titems: clone,\n\t\t\toutlines: this._layout(clone, outline, isAppend),\n\t\t};\n\t}\n}\n\nexport default FrameLayout;\n","import FrameLayout, { IFrameLayoutInterface, IFrameShape } from \"./FrameLayout\";\nimport { fill } from \"../utils\";\nimport { IInfiniteGridItem } from \"../types\";\n\nfunction makeShapeOutline(\n\toutline: number[],\n\titemSize: number,\n\tcolumnLength: number,\n\tisAppend: boolean,\n) {\n\tconst point = Math[isAppend ? \"min\" : \"max\"](...outline) || 0;\n\n\tif (outline.length !== columnLength) {\n\t\treturn fill(new Array(columnLength), 0);\n\t}\n\treturn outline.map(l => Math.floor((l - point) / itemSize));\n}\nfunction getColumn(item: IInfiniteGridItem) {\n\tif (item.column) {\n\t\treturn item.column;\n\t}\n\tlet column = 0;\n\n\tif (item.el) {\n\t\tconst dataset = item.el.dataset;\n\n\t\tif (dataset) {\n\t\t\tcolumn = parseInt(dataset.column, 10) || 1;\n\t\t} else {\n\t\t\tcolumn = parseInt(item.el.getAttribute(\"column\"), 10) || 1;\n\t\t}\n\t} else {\n\t\tcolumn = 1;\n\t}\n\titem.column = column;\n\treturn column;\n}\nexport interface ISquareLayoutOptions extends IFrameLayoutInterface {\n\tcolumn: number;\n}\n/**\n * @classdesc SquareLayout is a layout that places all cards like squares on a checkerboard, and important cards are n times larger. The main card can be enlarged, and then a small card can be placed to naturally show the relationship of the card.\n * @ko SquareLayout         N   .    ,           .\n * @class eg.InfiniteGrid.SquareLayout\n * @extends eg.InfiniteGrid.FrameLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.SquareLayout module <ko>eg.InfiniteGrid.SquareLayout   </ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>  </ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>   (false: , true: )</ko>\n * @param {Boolean} [options.itemSize=0] The size of the items. If it is 0, it is calculated as the size of the first item in items. <ko>  .    0,      . </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid(\"#grid\". {\n\thorizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.SquareLayout, {\n\tmargin: 10,\n\titemSize: 200,\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.SquareLayout({\n\tmargin: 10,\n\titemSize: 200,\n\thorizontal: true,\n});\n\nvar item1 = '<div data-column=\"2\"></div>';\nvar item2 = \"<div></div>\"\nlayout.append([item1, item2]);\n</script>\n```\n **/\nexport default class SquareLayout extends FrameLayout {\n\tpublic options: ISquareLayoutOptions;\n\n\tconstructor(options: Partial<ISquareLayoutOptions> = {}) {\n\t\tsuper(options);\n\t}\n\tprotected _checkItemSize() {\n\t\tconst column = this.options.column;\n\n\t\tif (!column) {\n\t\t\tsuper._checkItemSize();\n\t\t\treturn;\n\t\t}\n\t\tconst margin = this.options.margin;\n\n\t\t// if itemSize is not in options, caculate itemSize from size.\n\t\tthis._itemSize = (this._size + margin) / column - margin;\n\t}\n\tprotected _layout(\n\t\titems: IInfiniteGridItem[],\n\t\toutline: number[] = [],\n\t\tisAppend?: boolean,\n\t) {\n\t\tconst itemSize = this._getItemSize() as number;\n\t\tconst margin = this.options.margin;\n\t\tconst columnLength = this.options.column ||\n\t\t\tMath.floor((this._size + margin) / (itemSize + margin)) || 1;\n\t\tconst length = items.length;\n\t\tconst endOutline = makeShapeOutline(outline, itemSize, columnLength, isAppend);\n\t\tconst pointCaculateName = isAppend ? \"min\" : \"max\";\n\t\tconst shapes: IFrameShape[] = [];\n\t\tconst sign = isAppend ? 1 : -1;\n\t\tconst style = this._style;\n\t\tconst pos1Name = style.startPos1;\n\t\tconst pos2Name = style.startPos2;\n\n\t\tfor (let i = 0; i < length; ++i) {\n\t\t\tconst point = Math[pointCaculateName](...endOutline);\n\t\t\tlet index = endOutline[isAppend ? \"indexOf\" : \"lastIndexOf\"](point);\n\t\t\tconst item = items[i];\n\t\t\tconst columnWidth = item.columnWidth;\n\t\t\tconst column = (columnWidth && columnWidth[0] === columnLength &&\n\t\t\t\tcolumnWidth[1]) || getColumn(item);\n\t\t\tlet columnCount = 1;\n\n\t\t\tif (column > 1) {\n\t\t\t\tfor (let j = 1; j < column &&\n\t\t\t\t\t((isAppend && index + j < columnLength) || (!isAppend && index - j >= 0)); ++j) {\n\t\t\t\t\tif ((isAppend && endOutline[index + sign * j] <= point) ||\n\t\t\t\t\t\t(!isAppend && endOutline[index + sign * j] >= point)) {\n\t\t\t\t\t\t++columnCount;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!isAppend) {\n\t\t\t\t\tindex -= columnCount - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\titem.columnWidth = [columnLength, columnCount];\n\t\t\tshapes.push({\n\t\t\t\twidth: columnCount,\n\t\t\t\theight: columnCount,\n\t\t\t\t[pos1Name]: point - (!isAppend ? columnCount : 0),\n\t\t\t\t[pos2Name]: index,\n\t\t\t\ttype: i + 1,\n\t\t\t\tindex: i,\n\t\t\t});\n\t\t\tfor (let j = 0; j < columnCount; ++j) {\n\t\t\t\tendOutline[index + j] = point + sign * columnCount;\n\t\t\t}\n\t\t}\n\t\tthis._shapes = {\n\t\t\tshapes,\n\t\t\t[style.size2]: columnLength,\n\t\t};\n\n\t\tconst result = super._layout(items, outline, isAppend);\n\n\t\tif (!isAppend) {\n\t\t\tshapes.sort((shape1, shape2) => {\n\t\t\t\tconst item1pos1 = shape1[pos1Name];\n\t\t\t\tconst item1pos2 = shape1[pos2Name];\n\t\t\t\tconst item2pos1 = shape2[pos1Name];\n\t\t\t\tconst item2pos2 = shape2[pos2Name];\n\n\t\t\t\tif (item1pos1 - item2pos1) {\n\t\t\t\t\treturn item1pos1 - item2pos1;\n\t\t\t\t}\n\t\t\t\treturn item1pos2 - item2pos2;\n\t\t\t});\n\t\t\titems.sort((a, b) => {\n\t\t\t\tconst item1pos1 = a.rect[pos1Name];\n\t\t\t\tconst item1pos2 = a.rect[pos2Name];\n\t\t\t\tconst item2pos1 = b.rect[pos1Name];\n\t\t\t\tconst item2pos2 = b.rect[pos2Name];\n\n\t\t\t\tif (item1pos1 - item2pos1) {\n\t\t\t\t\treturn item1pos1 - item2pos1;\n\t\t\t\t}\n\t\t\t\treturn item1pos2 - item2pos2;\n\t\t\t});\n\t\t}\n\t\treturn result;\n\t}\n}\n","import { assign } from \"../../utils\";\n\nexport interface IBoxModel {\n\toriginWidth: number;\n\toriginHeight: number;\n\twidth: number;\n\theight: number;\n\tleft: number;\n\ttop: number;\n\titems: BoxModel[];\n}\n\nexport default class BoxModel implements IBoxModel {\n\tpublic originWidth: number;\n\tpublic originHeight: number;\n\tpublic width: number;\n\tpublic height: number;\n\tpublic left: number;\n\tpublic top: number;\n\tpublic items: BoxModel[];\n\tconstructor(options: Partial<IBoxModel>) {\n\t\tassign(this, {\n\t\t\toriginWidth: 0,\n\t\t\toriginHeight: 0,\n\t\t\twidth: 0,\n\t\t\theight: 0,\n\t\t\tleft: 0,\n\t\t\ttop: 0,\n\t\t\titems: [],\n\t\t}, options);\n\t}\n\tpublic scaleTo(width: number, height: number) {\n\t\tconst scaleX = this.width ? width / this.width : 0;\n\t\tconst scaleY = this.height ? height / this.height : 0;\n\n\t\tthis.items.forEach(v => {\n\t\t\tif (scaleX !== 0) {\n\t\t\t\tv.left *= scaleX;\n\t\t\t\tv.width *= scaleX;\n\t\t\t}\n\t\t\tif (scaleY !== 0) {\n\t\t\t\tv.top *= scaleY;\n\t\t\t\tv.height *= scaleY;\n\t\t\t}\n\t\t});\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t}\n\tpublic push(item: BoxModel) {\n\t\tthis.items.push(item);\n\t}\n\tpublic getOriginSize() {\n\t\treturn this.originWidth * this.originHeight;\n\t}\n\tpublic getSize() {\n\t\treturn this.width * this.height;\n\t}\n\tpublic getOriginRatio() {\n\t\treturn (this.originHeight === 0) ? 0 : this.originWidth / this.originHeight;\n\t}\n\tpublic getRatio() {\n\t\treturn (this.height === 0) ? 0 : this.width / this.height;\n\t}\n}\n","import BoxModel from \"./lib/BoxModel\";\nimport { APPEND, PREPEND } from \"../consts\";\nimport { getStyleNames, assignOptions, toZeroArray, cloneItems } from \"../utils\";\nimport { ILayout, IRectlProperties, ISize, IInfiniteGridItem, IInfiniteGridGroup } from \"../types\";\n\nfunction getCost(originLength: number, length: number) {\n\tlet cost = originLength / length;\n\n\tif (cost < 1) {\n\t\tcost = 1 / cost;\n\t}\n\n\treturn cost - 1;\n}\nfunction fitArea(\n\titem: BoxModel,\n\tbestFitArea: BoxModel,\n\titemFitSize: ISize,\n\tcontainerFitSize: ISize,\n\tlayoutVertical: boolean,\n) {\n\titem.height = itemFitSize.height;\n\titem.width = itemFitSize.width;\n\tbestFitArea.height = containerFitSize.height;\n\tbestFitArea.width = containerFitSize.width;\n\n\tif (layoutVertical) {\n\t\titem.top = bestFitArea.top + bestFitArea.height;\n\t\titem.left = bestFitArea.left;\n\t} else {\n\t\titem.left = bestFitArea.left + bestFitArea.width;\n\t\titem.top = bestFitArea.top;\n\t}\n}\n\n/**\n * @classdesc The PackingLayout is a layout that shows the important cards bigger without sacrificing the weight of the cards. Rows and columns are separated so that cards are dynamically placed within the horizontal and vertical space rather than arranged in an orderly fashion.\n * @ko PackingLayout              .              .\n * @class eg.InfiniteGrid.PackingLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.PackingLayout module <ko>eg.InfiniteGrid.PackingLayout   </ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>  </ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>   (false: , true: )</ko>\n * @param {Boolean} [options.aspectRatio=1] The aspect ratio of the group <ko>     </ko>\n * @param {Boolean} [options.sizeWeight=1] The size weight when placing an image <ko>      </ko>\n * @param {Boolean} [options.ratioWeight=1] The ratio weight when placing an image <ko>      </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid(\"#grid\". {\n  horizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.PackingLayout, {\n  margin: 10,\n  aspectRatio: 1,\n  sizeWeight: 1,\n  ratioWeight: 2,\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.PackingLayout({\n  horizontal: true,\n  margin: 10,\n  aspectRatio: 1,\n  sizeWeight: 1,\n  ratioWeight: 2,\n});\n\n</script>\n```\n **/\nclass PackingLayout implements ILayout {\n\tpublic options: {\n\t\thorizontal: boolean,\n\t\tmargin: number,\n\t\taspectRatio: number,\n\t\tsizeWeight: number,\n\t\tratioWeight: number,\n\t};\n\tprivate _size: number;\n\tprivate _style: IRectlProperties;\n\tconstructor(options: Partial<PackingLayout[\"options\"]> = {}) {\n\t\tthis.options = assignOptions({\n\t\t\tmargin: 0,\n\t\t\thorizontal: false,\n\t\t\taspectRatio: 1,\n\t\t\tsizeWeight: 1,\n\t\t\tratioWeight: 1,\n\t\t}, options);\n\t\tthis._size = 0;\n\t\tthis._style = getStyleNames(this.options.horizontal);\n\t}\n\t/**\n\t * Adds items at the bottom of a outline.\n\t * @ko    .\n\t * @method eg.InfiniteGrid.PackingLayout#append\n\t * @param {Array} items Array of items to be layouted <ko>  </ko>\n\t * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n\t * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n\t * @example\n\t * layout.prepend(items, [100]);\n\t */\n\tpublic append(items: IInfiniteGridItem[], outline?: number[], cache?: boolean) {\n\t\treturn this._insert(items, outline, APPEND, cache);\n\t}\n\t/**\n\t * Adds items at the top of a outline.\n\t * @ko    .\n\t * @method eg.InfiniteGrid.PackingLayout#prepend\n\t * @param {Array} items Array of items to be layouted <ko>  </ko>\n\t * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n\t * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n\t * @example\n\t * layout.prepend(items, [100]);\n\t */\n\tpublic prepend(items: IInfiniteGridItem[], outline?: number[], cache?: boolean) {\n\t\treturn this._insert(items, outline, PREPEND, cache);\n\t}\n\t/**\n\t * Adds items of groups at the bottom of a outline.\n\t * @ko     .\n\t * @method eg.InfiniteGrid.PackingLayout#layout\n\t * @param {Array} groups Array of groups to be layouted <ko>  </ko>\n\t * @param {Array} outline Array of outline points to be reference points <ko>    </ko>\n\t * @return {eg.InfiniteGrid.PackingLayout} An instance of a module itself<ko>  </ko>\n\t * @example\n\t * layout.layout(groups, [100, 200, 300, 400]);\n\t */\n\tpublic layout(groups: IInfiniteGridGroup[] = [], outline: number[] = []) {\n\t\tconst length = groups.length;\n\t\tlet point = outline;\n\n\t\tfor (let i = 0; i < length; ++i) {\n\t\t\tconst group = groups[i];\n\t\t\tconst outlines = this._layout(group.items, point, APPEND);\n\n\t\t\tgroup.outlines = outlines;\n\t\t\tpoint = outlines.end;\n\t\t}\n\t\treturn this;\n\t}\n\t/**\n\t * Set the viewport size of the layout.\n\t * @ko    .\n\t * @method eg.InfiniteGrid.PackingLayout#setSize\n\t * @param {Number} size The viewport size of container area where items are added to a layout <ko>      </ko>\n\t * @return {eg.InfiniteGrid.PackingLayout} An instance of a module itself<ko>  </ko>\n\t * @example\n\t * layout.setSize(800);\n\t */\n\tpublic setSize(size: number) {\n\t\tthis._size = size;\n\t\treturn this;\n\t}\n\tprivate _findBestFitArea(container: BoxModel, item: BoxModel) {\n\t\tif (container.getRatio() === 0) { //     \n\t\t\tcontainer.originWidth = item.width;\n\t\t\tcontainer.originHeight = item.height;\n\t\t\tcontainer.width = item.width;\n\t\t\tcontainer.height = item.height;\n\t\t\treturn;\n\t\t}\n\n\t\tlet bestFitArea = null;\n\t\tlet minCost = 10000000;\n\t\tlet layoutVertical = false;\n\t\tconst itemFitSize: ISize = {\n\t\t\twidth: 0,\n\t\t\theight: 0,\n\t\t};\n\t\tconst containerFitSize: ISize = {\n\t\t\twidth: 0,\n\t\t\theight: 0,\n\t\t};\n\t\tconst { sizeWeight, ratioWeight } = this.options;\n\n\t\tcontainer.items.forEach(v => {\n\t\t\tconst containerSizeCost = getCost(v.getOriginSize(), v.getSize()) * sizeWeight;\n\t\t\tconst containerRatioCost = getCost(v.getOriginRatio(), v.getRatio()) * ratioWeight;\n\t\t\tconst width = v.width;\n\t\t\tconst height = v.height;\n\t\t\tlet cost;\n\n\t\t\tfor (let i = 0; i < 2; ++i) {\n\t\t\t\tlet itemWidth;\n\t\t\t\tlet itemHeight;\n\t\t\t\tlet containerWidth;\n\t\t\t\tlet containerHeight;\n\n\t\t\t\tif (i === 0) {\n\t\t\t\t\t//   \n\t\t\t\t\titemWidth = width;\n\t\t\t\t\titemHeight = height * (item.height / (v.originHeight + item.height));\n\t\t\t\t\tcontainerWidth = width;\n\t\t\t\t\tcontainerHeight = height - itemHeight;\n\t\t\t\t} else {\n\t\t\t\t\t//   \n\t\t\t\t\titemHeight = height;\n\t\t\t\t\titemWidth = width * (item.width / (v.originWidth + item.width));\n\t\t\t\t\tcontainerHeight = height;\n\t\t\t\t\tcontainerWidth = width - itemWidth;\n\t\t\t\t}\n\n\t\t\t\tconst itemSize = itemWidth * itemHeight;\n\t\t\t\tconst itemRatio = itemWidth / itemHeight;\n\t\t\t\tconst containerSize = containerWidth * containerHeight;\n\t\t\t\tconst containerRatio = containerHeight / containerHeight;\n\n\t\t\t\tcost = getCost(item.getSize(), itemSize) * sizeWeight;\n\t\t\t\tcost += getCost(item.getRatio(), itemRatio) * ratioWeight;\n\t\t\t\tcost += getCost(v.getOriginSize(), containerSize) * sizeWeight - containerSizeCost;\n\t\t\t\tcost += getCost(v.getOriginRatio(), containerRatio) * ratioWeight - containerRatioCost;\n\n\t\t\t\tif (cost === Math.min(cost, minCost)) {\n\t\t\t\t\tminCost = cost;\n\t\t\t\t\tbestFitArea = v;\n\t\t\t\t\tlayoutVertical = (i === 0);\n\t\t\t\t\titemFitSize.width = itemWidth;\n\t\t\t\t\titemFitSize.height = itemHeight;\n\t\t\t\t\tcontainerFitSize.width = containerWidth;\n\t\t\t\t\tcontainerFitSize.height = containerHeight;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tfitArea(item, bestFitArea, itemFitSize, containerFitSize, layoutVertical);\n\t}\n\tprivate _layout(items: IInfiniteGridItem[], outline: number[] = [], isAppend?: boolean) {\n\t\tconst style = this._style;\n\t\tconst { horizontal, aspectRatio, margin } = this.options;\n\t\tconst pos1Name = style.startPos1;\n\t\tconst containerWidth = this._size * (horizontal ? aspectRatio : 1);\n\t\tconst containerHeight = this._size / (horizontal ? 1 : aspectRatio);\n\t\tconst containerSize1 = horizontal ? containerWidth : containerHeight;\n\t\tconst prevOutline = toZeroArray(outline);\n\t\tconst start = isAppend ? Math.max(...prevOutline) :\n\t\t\tMath.min(...prevOutline) - containerSize1 - margin;\n\t\tconst end = start + containerSize1 + margin;\n\t\tconst container = new BoxModel({});\n\n\t\titems.forEach(item => {\n\t\t\tconst { width, height } = item.orgSize;\n\t\t\tconst model = new BoxModel({\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t\toriginWidth: width,\n\t\t\t\toriginHeight: height,\n\t\t\t});\n\n\t\t\tthis._findBestFitArea(container, model);\n\t\t\tcontainer.push(model);\n\t\t\tcontainer.scaleTo(containerWidth + margin, containerHeight + margin);\n\t\t});\n\t\titems.forEach((item, i) => {\n\t\t\tconst boxItem = container.items[i];\n\t\t\tconst width = boxItem.width;\n\t\t\tconst height = boxItem.height;\n\t\t\tconst top = boxItem.top;\n\t\t\tconst left = boxItem.left;\n\n\t\t\titem.rect = { top, left, width: width - margin, height: height - margin };\n\t\t\titem.rect[pos1Name] += start;\n\t\t});\n\n\t\treturn {\n\t\t\tstart: [start],\n\t\t\tend: [end],\n\t\t};\n\t}\n\tprivate _insert(items: IInfiniteGridItem[] = [], outline: number[] = [], isAppend?: boolean, cache?: boolean) {\n\t\t// this only needs the size of the item.\n\t\tconst clone = cache ? items : cloneItems(items);\n\n\t\treturn {\n\t\t\titems: clone,\n\t\t\toutlines: this._layout(clone, outline, isAppend),\n\t\t};\n\t}\n}\n\nexport default PackingLayout;\n","/* eslint-disable */\n/******************************************************************************\n * Created 2008-08-19.\n *\n * Dijkstra path-finding functions. Adapted from the Dijkstar Python project.\n *\n * Copyright (C) 2008\n *   Wyatt Baldwin <self@wyattbaldwin.com>\n *   All rights reserved\n *\n * Licensed under the MIT license.\n *\n *   http://www.opensource.org/licenses/mit-license.php\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *****************************************************************************/\nfunction single_source_shortest_paths(\n\tgraph: (x: string) => ({ [key: string]: number }),\n\ts: string,\n\td: string,\n) {\n\t// Predecessor map for each node that has been encountered.\n\t// node ID => predecessor node ID\n\tconst predecessors: { [key: string]: string } = {};\n\t// Costs of shortest paths from s to all nodes encountered.\n\t// node ID => cost\n\tconst costs: { [key: string]: number } = {};\n\tcosts[s] = 0;\n\n\t// Costs of shortest paths from s to all nodes encountered; differs from\n\t// `costs` in that it provides easy access to the node that currently has\n\t// the known shortest path from s.\n\t// XXX: Do we actually need both `costs` and `open`?\n\tconst open = new BinaryHeap<{ value: string, cost: number }>(x => x.cost);\n\topen.push({ value: s, cost: 0 });\n\n\tlet closest;\n\tlet u;\n\tlet cost_of_s_to_u;\n\tlet adjacent_nodes;\n\tlet cost_of_e;\n\tlet cost_of_s_to_u_plus_cost_of_e;\n\tlet cost_of_s_to_v;\n\tlet first_visit: boolean;\n\n\twhile (open.size()) {\n\t\t// In the nodes remaining in graph that have a known cost from s,\n\t\t// find the node, u, that currently has the shortest path from s.\n\t\tclosest = open.pop();\n\t\tu = closest.value;\n\t\tcost_of_s_to_u = closest.cost;\n\n\t\t// Get nodes adjacent to u...\n\t\tadjacent_nodes = graph(u) || {};\n\n\t\t// ...and explore the edges that connect u to those nodes, updating\n\t\t// the cost of the shortest paths to any or all of those nodes as\n\t\t// necessary. v is the node across the current edge from u.\n\t\tfor (const v in adjacent_nodes) {\n\t\t\t// Get the cost of the edge running from u to v.\n\t\t\tcost_of_e = adjacent_nodes[v];\n\n\t\t\t// Cost of s to u plus the cost of u to v across e--this is *a*\n\t\t\t// cost from s to v that may or may not be less than the current\n\t\t\t// known cost to v.\n\t\t\tcost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;\n\n\t\t\t// If we haven't visited v yet OR if the current known cost from s to\n\t\t\t// v is greater than the new cost we just found (cost of s to u plus\n\t\t\t// cost of u to v across e), update v's cost in the cost list and\n\t\t\t// update v's predecessor in the predecessor list (it's now u).\n\t\t\tcost_of_s_to_v = costs[v];\n\t\t\tfirst_visit = (typeof costs[v] === \"undefined\");\n\t\t\tif (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {\n\t\t\t\tcosts[v] = cost_of_s_to_u_plus_cost_of_e;\n\t\t\t\topen.push({ value: v, cost: cost_of_s_to_u_plus_cost_of_e });\n\t\t\t\tpredecessors[v] = u;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (typeof costs[d] === \"undefined\") {\n\t\tconst msg = [\"Could not find a path from \", s, \" to \", d, \".\"].join(\"\");\n\t\tthrow new Error(msg);\n\t}\n\n\treturn predecessors;\n}\nfunction extract_shortest_path_from_predecessor_list(\n\tpredecessors: { [key: string]: string },\n\td: string,\n) {\n\tconst nodes: string[] = [];\n\tlet u = d;\n\n\twhile (u) {\n\t\tnodes.push(u);\n\t\tu = predecessors[u];\n\t}\n\tnodes.reverse();\n\treturn nodes;\n}\nfunction find_path(\n\tgraph: (x: string) => ({ [key: string]: number }),\n\ts: string,\n\td: string,\n) {\n\tconst predecessors = single_source_shortest_paths(graph, s, d);\n\n\treturn extract_shortest_path_from_predecessor_list(predecessors, d);\n}\n\nclass BinaryHeap<T> {\n\tprivate content: T[];\n\tprivate scoreFunction: (x: T) => number;\n\n\tconstructor(scoreFunction: (x: T) => number) {\n\t\tthis.content = [];\n\t\tthis.scoreFunction = scoreFunction;\n\t}\n\tpublic push(element: T) {\n\t\t// Add the new element to the end of the array.\n\t\tthis.content.push(element);\n\t\t// Allow it to bubble up.\n\t\tthis.bubbleUp(this.content.length - 1);\n\t}\n\tpublic pop() {\n\t\t// Store the first element so we can return it later.\n\t\tconst result = this.content[0];\n\t\t// Get the element at the end of the array.\n\t\tconst end = this.content.pop();\n\t\t// If there are any elements left, put the end element at the\n\t\t// start, and let it sink down.\n\t\tif (this.content.length > 0) {\n\t\t\tthis.content[0] = end;\n\t\t\tthis.sinkDown(0);\n\t\t}\n\t\treturn result;\n\t}\n\tpublic size() {\n\t\treturn this.content.length;\n\t}\n\tpublic bubbleUp(_n: number) {\n\t\tlet n = _n;\n\t\t// Fetch the element that has to be moved.\n\t\tconst element = this.content[n];\n\t\t// When at 0, an element can not go up any further.\n\t\twhile (n > 0) {\n\t\t\t// Compute the parent element's index, and fetch it.\n\t\t\tconst parentN = Math.floor((n + 1) / 2) - 1;\n\t\t\tconst parent = this.content[parentN];\n\n\t\t\t// Swap the elements if the parent is greater.\n\t\t\tif (this.scoreFunction(element) < this.scoreFunction(parent)) {\n\t\t\t\tthis.content[parentN] = element;\n\t\t\t\tthis.content[n] = parent;\n\t\t\t\t// Update 'n' to continue at the new position.\n\t\t\t\tn = parentN;\n\t\t\t} else {\n\t\t\t\t// Found a parent that is less, no need to move it further.\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tpublic sinkDown(n: number) {\n\t\t// Look up the target element and its score.\n\t\tconst length = this.content.length;\n\t\tconst element = this.content[n];\n\t\tconst elemScore = this.scoreFunction(element);\n\t\tlet child1Score;\n\n\t\twhile (true) {\n\t\t\t// Compute the indices of the child elements.\n\t\t\tconst child2N = (n + 1) * 2;\n\t\t\tconst child1N = child2N - 1;\n\t\t\t// This is used to store the new position of the element,\n\t\t\t// if any.\n\t\t\tlet swap = null;\n\t\t\t// If the first child exists (is inside the array)...\n\t\t\tif (child1N < length) {\n\t\t\t\t// Look it up and compute its score.\n\t\t\t\tconst child1 = this.content[child1N];\n\t\t\t\tchild1Score = this.scoreFunction(child1);\n\t\t\t\t// If the score is less than our element's, we need to swap.\n\t\t\t\tif (child1Score < elemScore) {\n\t\t\t\t\tswap = child1N;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Do the same checks for the other child.\n\t\t\tif (child2N < length) {\n\t\t\t\tconst child2 = this.content[child2N];\n\t\t\t\tconst child2Score = this.scoreFunction(child2);\n\n\t\t\t\tif (child2Score < (swap == null ? elemScore : child1Score)) {\n\t\t\t\t\tswap = child2N;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If the element needs to be moved, swap it, and continue.\n\t\t\tif (swap !== null) {\n\t\t\t\tthis.content[n] = this.content[swap];\n\t\t\t\tthis.content[swap] = element;\n\t\t\t\tn = swap;\n\t\t\t} else {\n\t\t\t\t// Otherwise, we are done.\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport { find_path };\n","import { find_path } from \"./lib/dijkstra\";\nimport { APPEND, PREPEND } from \"../consts\";\nimport { getStyleNames, assignOptions, cloneItems } from \"../utils\";\nimport { ILayout, IRectlProperties, SizeType, IInfiniteGridItem, IInfiniteGridGroup } from \"../types\";\n\n/**\n * @classdesc 'justified' is a printing term with the meaning that 'it fits in one row wide'. JustifiedLayout is a layout that the card is filled up on the basis of a line given a size.\n * @ko 'justified' '1    '    .           .\n * @class eg.InfiniteGrid.JustifiedLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.JustifiedLayout module <ko>eg.InfiniteGrid.JustifiedLayout   </ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>  </ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>   (false: , true: )</ko>\n * @param {Number} [options.minSize=0] Minimum size of item to be resized <ko>     </ko>\n * @param {Number} [options.maxSize=0] Maximum size of item to be resized <ko>     </ko>\n * @param {Array|Number} [options.column=[1, 8]] The number of items in a line <ko>      </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid(\"#grid\". {\n  horizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.JustifiedLayout, {\n  margin: 10,\n  minSize: 100,\n  maxSize: 300,\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.JustifiedLayout({\n  margin: 10,\n  minSize: 100,\n  maxSize: 300,\n  column: 5,\n  horizontal: true,\n});\n\n</script>\n```\n **/\nclass JustifiedLayout implements ILayout {\n\tpublic options: {\n\t\tmargin: number;\n\t\tminSize: number;\n\t\tmaxSize: number;\n\t\tcolumn: number | number[];\n\t\thorizontal: boolean;\n\t};\n\tprivate _style: IRectlProperties;\n\tprivate _size: number;\n\n\tconstructor(options: Partial<JustifiedLayout[\"options\"]> = {}) {\n\t\tthis.options = assignOptions({\n\t\t\tmargin: 0,\n\t\t\thorizontal: false,\n\t\t\tminSize: 0,\n\t\t\tmaxSize: 0,\n\t\t\tcolumn: [1, 8],\n\t\t}, options);\n\n\t\tthis._style = getStyleNames(this.options.horizontal);\n\t\tthis._size = 0;\n\t}\n\t/**\n\t * Set the viewport size of the layout.\n\t * @ko    .\n\t * @method eg.InfiniteGrid.JustifiedLayout#setSize\n\t * @param {Number} size The viewport size of container area where items are added to a layout <ko>      </ko>\n\t * @return {eg.InfiniteGrid.JustifiedLayout} An instance of a module itself<ko>  </ko>\n\t * @example\n\t * layout.setSize(800);\n\t */\n\tpublic setSize(size: number) {\n\t\tthis._size = size;\n\t\treturn this;\n\t}\n\t/**\n\t * Adds items at the bottom of a outline.\n\t * @ko    .\n\t * @method eg.InfiniteGrid.JustifiedLayout#append\n\t * @param {Array} items Array of items to be layouted <ko>  </ko>\n\t * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n\t * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n\t * @example\n\t * layout.prepend(items, [100]);\n\t */\n\tpublic append(items: IInfiniteGridItem[], outline?: number[], cache?: boolean) {\n\t\treturn this._insert(items, outline, APPEND, cache);\n\t}\n\t/**\n\t * Adds items at the top of a outline.\n\t * @ko    .\n\t * @method eg.InfiniteGrid.JustifiedLayout#prepend\n\t * @param {Array} items Array of items to be layouted <ko>  </ko>\n\t * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n\t * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n\t * @example\n\t * layout.prepend(items, [100]);\n\t */\n\tpublic prepend(items: IInfiniteGridItem[], outline?: number[], cache?: boolean) {\n\t\treturn this._insert(items, outline, PREPEND, cache);\n\t}\n\t/**\n\t * Adds items of groups at the bottom of a outline.\n\t * @ko     .\n\t * @method eg.InfiniteGrid.JustifiedLayout#layout\n\t * @param {Array} groups Array of groups to be layouted <ko>  </ko>\n\t * @param {Array} outline Array of outline points to be reference points <ko>    </ko>\n\t * @return {eg.InfiniteGrid.JustifiedLayout} An instance of a module itself<ko>  </ko>\n\t * @example\n\t * layout.layout(groups, [100]);\n\t */\n\tpublic layout(groups: IInfiniteGridGroup[] = [], outline: number[] = []) {\n\t\tconst length = groups.length;\n\t\tlet point = outline;\n\n\t\tfor (let i = 0; i < length; ++i) {\n\t\t\tconst group = groups[i];\n\t\t\tconst outlines = this._layout(group.items, point, APPEND);\n\n\t\t\tgroup.outlines = outlines;\n\t\t\tpoint = outlines.end;\n\t\t}\n\t\treturn this;\n\t}\n\tprivate _layout(items: IInfiniteGridItem[], outline: number[], isAppend?: boolean) {\n\t\tconst style = this._style;\n\t\tconst size1Name = style.size1;\n\t\tconst size2Name = style.size2;\n\t\tconst startIndex = 0;\n\t\tconst endIndex = items.length;\n\t\tconst column = this.options.column;\n\t\tconst columns: number[] = (typeof column === \"object\") ? column : [column, column];\n\n\t\tconst graph = (_start: string) => {\n\t\t\tconst results: { [key: string]: number } = {};\n\t\t\tconst start = +_start.replace(/[^0-9]/g, \"\");\n\t\t\tconst length = endIndex + 1;\n\n\t\t\tfor (let i = Math.min(start + columns[0], length - 1); i < length; ++i) {\n\t\t\t\tif (i - start > columns[1]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlet cost = this._getCost(items, start, i, size1Name, size2Name);\n\n\t\t\t\tif (cost === null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cost < 0 && i === length - 1) {\n\t\t\t\t\tcost = 0;\n\t\t\t\t}\n\t\t\t\tresults[`${i}`] = Math.pow(cost, 2);\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\t\t// shortest path for items' total height.\n\t\tconst path = find_path(graph, `${startIndex}`, `${endIndex}`);\n\n\t\treturn this._setStyle(items, path, outline, isAppend);\n\t}\n\tprivate _getSize(items: IInfiniteGridItem[], size1Name: SizeType, size2Name: SizeType) {\n\t\tconst margin = this.options.margin;\n\t\tconst size = items.reduce((sum, item) => sum +\n\t\t\t(item.orgSize[size2Name]) / item.orgSize[size1Name], 0);\n\n\t\treturn (this._size - margin * (items.length - 1)) / size;\n\t}\n\tprivate _getCost(\n\t\titems: IInfiniteGridItem[],\n\t\ti: number,\n\t\tj: number,\n\t\tsize1Name: SizeType,\n\t\tsize2Name: SizeType,\n\t) {\n\t\tconst size = this._getSize(items.slice(i, j), size1Name, size2Name);\n\t\tconst min = this.options.minSize || 0;\n\t\tconst max = this.options.maxSize || Infinity;\n\n\t\tif (isFinite(max)) {\n\t\t\t// if this size is not in range, the cost increases sharply.\n\t\t\tif (size < min) {\n\t\t\t\treturn Math.pow(size - min, 2) + Math.pow(max, 2);\n\t\t\t} else if (size > max) {\n\t\t\t\treturn Math.pow(size - max, 2) + Math.pow(max, 2);\n\t\t\t} else {\n\t\t\t\t// if this size in range, the cost is negative or low.\n\t\t\t\treturn Math.min(size - max, min - size);\n\t\t\t}\n\t\t}\n\t\t// if max is infinite type, caculate cost only with \"min\".\n\t\tif (size < min) {\n\t\t\treturn Math.max(Math.pow(min, 2), Math.pow(size, 2));\n\t\t}\n\t\treturn size - min;\n\t}\n\tprivate _setStyle(\n\t\titems: IInfiniteGridItem[],\n\t\tpath: string[],\n\t\toutline: number[] = [],\n\t\tisAppend?: boolean,\n\t) {\n\t\tconst style = this._style;\n\t\t// if direction is vertical\n\t\t// startPos1 : top, endPos1 : bottom\n\t\t// size1 : height\n\t\t// startPos2 : left, endPos2 : right\n\t\t// size2 : width\n\n\t\t// if direction is horizontal\n\t\t// startPos1 : left, endPos1 : right\n\t\t// size1 : width\n\t\t// startPos2 : top, endPos2 : bottom\n\t\t// size2 : height\n\t\tconst pos1Name = style.startPos1;\n\t\tconst size1Name = style.size1;\n\t\tconst pos2Name = style.startPos2;\n\t\tconst size2Name = style.size2;\n\t\tconst length = path.length;\n\t\tconst margin = this.options.margin;\n\t\tconst startPoint = outline[0] || 0;\n\t\tlet endPoint = startPoint;\n\t\tlet height = 0;\n\n\t\tfor (let i = 0; i < length - 1; ++i) {\n\t\t\tconst path1 = parseInt(path[i], 10);\n\t\t\tconst path2 = parseInt(path[i + 1], 10);\n\t\t\t// pathItems(path1 to path2) are in 1 line.\n\t\t\tconst pathItems = items.slice(path1, path2);\n\t\t\tconst pathItemsLength = pathItems.length;\n\t\t\tconst size1 = this._getSize(pathItems, size1Name, size2Name);\n\t\t\tconst pos1 = endPoint;\n\n\t\t\tfor (let j = 0; j < pathItemsLength; ++j) {\n\t\t\t\tconst item = pathItems[j];\n\t\t\t\tconst size2 = item.orgSize[size2Name] / item.orgSize[size1Name] * size1;\n\t\t\t\t// item has margin bottom and right.\n\t\t\t\t// first item has not margin.\n\t\t\t\tconst prevItemRect = j === 0 ? 0 : pathItems[j - 1].rect;\n\t\t\t\tconst pos2 = (prevItemRect ? prevItemRect[pos2Name] + prevItemRect[size2Name] + margin : 0);\n\n\t\t\t\titem.rect = {\n\t\t\t\t\t[pos1Name]: pos1,\n\t\t\t\t\t[pos2Name]: pos2,\n\t\t\t\t\t[size1Name]: size1,\n\t\t\t\t\t[size2Name]: size2,\n\t\t\t\t};\n\t\t\t}\n\t\t\theight += margin + size1;\n\t\t\tendPoint = startPoint + height;\n\t\t}\n\t\tconst itemsLength = items.length;\n\n\t\tif (isAppend) {\n\t\t\t// previous group's end outline is current group's start outline\n\t\t\treturn {\n\t\t\t\tstart: [startPoint],\n\t\t\t\tend: [endPoint],\n\t\t\t};\n\t\t}\n\t\t// for prepend, only substract height from position.\n\t\t// always start is lower than end.\n\n\t\tfor (let i = 0; i < itemsLength; ++i) {\n\t\t\tconst item = items[i];\n\n\t\t\t// move items as long as height for prepend\n\t\t\titem.rect[pos1Name] -= height;\n\t\t}\n\t\treturn {\n\t\t\tstart: [startPoint - height],\n\t\t\tend: [startPoint], // endPoint - height = startPoint\n\t\t};\n\t}\n\tprivate _insert(items: IInfiniteGridItem[] = [], outline: number[] = [], isAppend?: boolean, cache?: boolean) {\n\t\t// this only needs the size of the item.\n\t\tconst clone = cache ? items : cloneItems(items);\n\n\t\treturn {\n\t\t\titems: clone,\n\t\t\toutlines: this._layout(clone, outline, isAppend),\n\t\t};\n\t}\n}\n\nexport default JustifiedLayout;\n","/**\n * Copyright (c) NAVER Corp.\n * egjs-infinitegrid projects are licensed under the MIT license\n */\nimport InfiniteGrid from \"./InfiniteGrid\";\nimport GridLayout from \"./layouts/GridLayout\";\nimport FrameLayout from \"./layouts/FrameLayout\";\nimport SquareLayout from \"./layouts/SquareLayout\";\nimport PackingLayout from \"./layouts/PackingLayout\";\nimport JustifiedLayout from \"./layouts/JustifiedLayout\";\nimport ImageLoaded from \"./ImageLoaded\";\nimport AutoSizer from \"./AutoSizer\";\nimport DOMRenderer from \"./DOMRenderer\";\nimport Watcher from \"./Watcher\";\nimport ItemManager from \"./ItemManager\";\nimport Infinite from \"./Infinite\";\nimport LayoutManager from \"./LayoutManager\";\n\n// fix for IE8\n(InfiniteGrid as any).GridLayout = GridLayout;\n(InfiniteGrid as any).FrameLayout = FrameLayout;\n(InfiniteGrid as any).SquareLayout = SquareLayout;\n(InfiniteGrid as any).PackingLayout = PackingLayout;\n(InfiniteGrid as any).JustifiedLayout = JustifiedLayout;\n(InfiniteGrid as any).AutoSizer = AutoSizer;\n(InfiniteGrid as any).ImageLoaded = ImageLoaded;\n(InfiniteGrid as any).Watcher = Watcher;\n(InfiniteGrid as any).ItemManager = ItemManager;\n(InfiniteGrid as any).Infinite = Infinite;\n(InfiniteGrid as any).LayoutManager = LayoutManager;\n(InfiniteGrid as any).DOMRenderer = DOMRenderer;\n(InfiniteGrid as any).default = InfiniteGrid;\n\nexport default InfiniteGrid;\n"],"names":["win","document","window","navigator","userAgent","ua","SUPPORT_COMPUTEDSTYLE","SUPPORT_ADDEVENTLISTENER","SUPPORT_PASSIVE","supportsPassiveOption","Object","defineProperty","addEventListener","get","e","IS_IE","test","IS_IOS","IS_ANDROID2","IGNORE_CLASSNAME","TRANSITION_NAME","APPEND","PREPEND","VERTICAL","HORIZONTAL","DUMMY_POSITION","GROUPKEY_ATT","DEFAULT_OPTIONS","horizontal","margin","agent","toLowerCase","ALIGN","webkit","exec","WEBKIT_VERSION","parseInt","DEFENSE_BROWSER","TRANSFORM","TRANSITION","TRANSITION_END","nodes","array","i","len","length","push","html","match","param","multi","el","isWindow","jQuery","constructor","prototype","jquery","toArray","$","Array","isArray","map","v","undefined","nodeName","nodeType","matchHTML","dummy","createElement","innerHTML","childNodes","querySelectorAll","element","type","handler","eventListenerOptions","options","attachEvent","removeEventListener","detachEvent","getComputedStyle","currentStyle","name","isOffset","body","doc","documentElement","Math","max","size","clientRect","getBoundingClientRect","right","left","bottom","top","cssSize","getStyles","indexOf","parseFloat","_getSize","width","outerWidth","height","outerHeight","STYLE","vertical","startPos1","endPos1","size1","startPos2","endPos2","size2","isHorizontal","target","_i","sources","forEach","source","key","defaultOptions","assign","items","item","arr","value","clear","ItemManager","elements","selector","_a","groupKey","selectItems","content","outerHTML","rect","filter","classNames","className","split","some","c","data","property","reduce","acc","concat","startKey","endKey","datas","this","_data","startIndex","endIndex","slice","item2","data2","status","set","base","outlines","start","end","isUndefined","pluck","index","cursor","prop","targetValue","Infinity","getOutline","getEdgeIndex","startCursor","endCursor","group","groups","layouted","unshift","getAttribute","String","idx","splice","properties","styles","p","transitionDuration","pos1","pos2","isEqualSize","isConstantSize","container","view","viewport","_init","resize","DOMRenderer","callback","prevRect","style","setAttribute","position","render","setTransition","itemRect","addEvent","removeEvent","renderItem","removeElement","parentNode","removeChild","noElementItems","replace","join","cssText","_size","getSize","orgSize","_insert","isAppend","createElements","renderItems","_calcSize","isResize","innerWidth","innerHeight","_orgStyle","overflowX","overflowY","children","appendChild","createContainer","df","createDocumentFragment","insertBefore","firstChild","check","isOverflowScroll","_timer","reset","_containerOffset","_view","_isScrollIssue","_onCheck","bind","_onResize","setScrollPos","_prevPos","scrollPos","getOrgScrollPos","applyScrollPos","scrollTo","pos","x","y","arrPos","scrollBy","scrollLeft","scrollTop","scroll","rawPos","getContainerOffset","_getOffset","prevPos","getScrollPos","orgScrollPos","isForward","clearTimeout","setTimeout","_this","itemManger","useRecycle","threshold","append","prepend","recycle","_items","_status","endScrollPos","_b","visibles","min","isVisible","lastIndexOf","setCursor","getCursor","startEdgePos","endEdgePos","startPos","endPos","cache","getEdgeOutline","result","remove","AutoSizer","resizeAll","prefix","onResize","__PREFIX__","isFixed","fixed","elementPrefix","dataWidth","dataHeight","ImageLoaded","checklist","complete","error","checkCount","endCount","checkEnd","checkImage","onError","itemIndex","__ITEM_INDEX__","onCheck","srcElement","isDataAttribute","images","naturalWidth","add","tagName","checkImageLoaded","sum","waitImageLoaded","renderer","attributePrefix","_renderer","_layout","layout","setSize","callbacks","isUpdate","isRelayout","layoutGroups","outline","updateSize","itemManager","groupIndex","prevGroup","getData","groupOutline","every","groupItems","groupInfo","removeTarget","replaceTarget","errorIndex","removeItem","hasTarget","src","removeAttribute","replaceItem","removeTargetLength","replaceTargetLength","layoutedItems","_c","_d","_e","_f","checkGroups","reverse","_complete","_error","_end","_super","itemSelector","useFit","_reset","_loadingBar","_watcher","Watcher","_infinite","Infinite","_requestAppend","_requestPrepend","_recycle","tslib_1","_manager","LayoutKlass","LayoutMananger","setLayout","_setSize","getViewportSize","includeCached","getVisibleItems","infinite","getItems","isLayoutAll","isChildren","getContainerSize","setContainerSize","_fit","clearOutlines","_onLayoutComplete","fromCache","isTrusted","isLayout","getVisibleData","getStatus","watcher","processingStatus","setStatus","visibleItems","createAndInsert","isReLayout","isNeededResize","_postLayout","newItems","_appendLoadingBar","userLoadingBar","loadingBarObj","loadingSize","loadingStyle","loadingBar","_isProcessing","_isLoading","_getLoadingStatus","userStyle","display","_process","_renderLoading","_setContainerSize","_getEdgeValue","LOADING_APPEND","_fitItems","isProcessing","getItem","_updateItem","isInCursor","fit","_scrollTo","moveCache","moveItem","_postCache","destroy","getMaxEdgeValue","getViewSize","getEdgeValue","isAdd","from","method","removeItems","posName","trigger","requestStartCursor","requestEndCursor","_setScrollPos","_onImageError","getGroupKeys","pop","startLoading","endLoading","shift","viewSize","isScroll","InfiniteGrid","Component","START","CENTER","END","JUSTIFY","assignOptions","align","itemSize","_columnSize","_columnLength","_style","getStyleNames","startOutline","firstItem","checkColumn","fill","sizeName","columnSize","floor","size1Name","size2Name","pos1Name","pos2Name","columnLength","viewDist","pointCaculateName","endOutline","point","column","sort","a","b","item1pos1","item1pos2","item2pos1","item2pos2","clone","cloneItems","frame","j","disableFrame","frameFill","row","_itemSize","_shapes","shapes","searchShapeInFrame","getShapes","_checkItemSize","_getItemSize","isItemObject","itemSize2","itemSize1","shapesSize","shapesLength","dist","shape","shapePos1","shapePos2","shapeSize1","shapeSize2","k","targetOutline","prevOutlineEnd","prevOutlineDist","dataset","l","sign","columnWidth","getColumn","columnCount","shape1","shape2","FrameLayout","originWidth","originHeight","scaleX","scaleY","originLength","cost","aspectRatio","sizeWeight","ratioWeight","getRatio","bestFitArea","itemFitSize","containerFitSize","layoutVertical","minCost","containerSizeCost","getCost","getOriginSize","containerRatioCost","getOriginRatio","itemWidth","itemHeight","containerWidth","containerHeight","itemRatio","containerSize","containerRatio","containerSize1","prevOutline","BoxModel","model","_findBestFitArea","scaleTo","boxItem","graph","s","d","predecessors","u","extract_shortest_path_from_predecessor_list","costs","closest","cost_of_s_to_u","adjacent_nodes","cost_of_s_to_u_plus_cost_of_e","cost_of_s_to_v","open","BinaryHeap","msg","Error","single_source_shortest_paths","scoreFunction","bubbleUp","sinkDown","_n","n","parentN","parent","child1Score","elemScore","child2N","child1N","swap","child1","child2","minSize","maxSize","columns","path","find_path","_start","results","_getCost","pow","_setStyle","isFinite","startPoint","endPoint","path1","path2","pathItems","pathItemsLength","prevItemRect","itemsLength","GridLayout","SquareLayout","PackingLayout","JustifiedLayout","LayoutManager","default"],"mappings":"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"}