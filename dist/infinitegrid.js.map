{"version":3,"file":"infinitegrid.js","sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap bf22860e3ceb1f09eb1f","webpack:///./src/utils.js","webpack:///./src/consts.js","webpack:///./src/browser.js","webpack:///./src/ItemManager.js","webpack:///./src/DOMRenderer.js","webpack:///./src/AutoSizer.js","webpack:///./src/Watcher.js","webpack:///./src/Infinite.js","webpack:///./src/LayoutManager.js","webpack:///./src/ImageLoaded.js","webpack:///./src/layouts/FrameLayout.js","webpack:///./src/index.umd.js","webpack:///./src/index.js","webpack:///./src/InfiniteGrid.js","webpack:///external {\"commonjs\":\"@egjs/component\",\"commonjs2\":\"@egjs/component\",\"amd\":\"@egjs/component\",\"root\":[\"eg\",\"Component\"]}","webpack:///(webpack)/buildin/global.js","webpack:///./src/layouts/GridLayout.js","webpack:///./src/layouts/SquareLayout.js","webpack:///./src/layouts/PackingLayout.js","webpack:///./src/layouts/lib/BoxModel.js","webpack:///./src/layouts/JustifiedLayout.js","webpack:///./src/layouts/lib/dijkstra.js","webpack:///./src/version.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@egjs/component\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"@egjs/component\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"InfiniteGrid\"] = factory(require(\"@egjs/component\"));\n\telse\n\t\troot[\"eg\"] = root[\"eg\"] || {}, root[\"eg\"][\"InfiniteGrid\"] = factory(root[\"eg\"][\"Component\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_14__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 11);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap bf22860e3ceb1f09eb1f","\"use strict\";\n\nexports.__esModule = true;\nexports.toArray = toArray;\nexports.matchHTML = matchHTML;\nexports.$ = $;\nexports.addEvent = addEvent;\nexports.removeEvent = removeEvent;\nexports.addOnceEvent = addOnceEvent;\nexports.scroll = scroll;\nexports.scrollTo = scrollTo;\nexports.scrollBy = scrollBy;\nexports.getStyles = getStyles;\nexports.innerWidth = innerWidth;\nexports.innerHeight = innerHeight;\nexports.outerWidth = outerWidth;\nexports.outerHeight = outerHeight;\nexports.getSize = getSize;\nexports.getStyleNames = getStyleNames;\nexports.assignOptions = assignOptions;\nexports.toZeroArray = toZeroArray;\nexports.cloneItems = cloneItems;\nexports.isWindow = isWindow;\nexports.fill = fill;\nexports.isUndefined = isUndefined;\nexports.STYLE = void 0;\n\nvar _browser = require(\"./browser\");\n\nvar _consts = require(\"./consts\");\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction toArray(nodes) {\n  // SCRIPT5014 in IE8\n  var array = [];\n\n  if (nodes) {\n    for (var i = 0, len = nodes.length; i < len; i++) {\n      array.push(nodes[i]);\n    }\n  }\n\n  return array;\n}\n\nfunction matchHTML(html) {\n  return html.match(/^<([A-z]+)\\s*([^>]*)>/);\n}\n/**\n * Select or create element\n * @param {String|HTMLElement|jQuery} param\n *  when string given is as HTML tag, then create element\n *  otherwise it returns selected elements\n * @param {Boolean} multi\n * @returns {HTMLElement}\n */\n\n\nfunction $(param, multi) {\n  if (multi === void 0) {\n    multi = false;\n  }\n\n  var el;\n\n  if (typeof param === \"string\") {\n    // String (HTML, Selector)\n    // check if string is HTML tag format\n    var match = matchHTML(param); // creating element\n\n    if (match) {\n      // HTML\n      var dummy = _browser.document.createElement(\"div\");\n\n      dummy.innerHTML = param;\n      el = dummy.childNodes;\n    } else {\n      // Selector\n      el = _browser.document.querySelectorAll(param);\n    }\n\n    if (multi) {\n      el = toArray(el);\n    } else {\n      el = el && el.length > 0 && el[0] || undefined;\n    }\n  } else if (param === _browser.window) {\n    // window\n    el = param;\n  } else if (param.nodeName && (param.nodeType === 1 || param.nodeType === 9)) {\n    // HTMLElement, Document\n    el = param;\n  } else if (typeof _browser.window.jQuery === \"function\" && param instanceof _browser.window.jQuery || param.constructor.prototype.jquery) {\n    // jQuery\n    el = $(multi ? param.toArray() : param.get(0), multi);\n  } else if (Array.isArray(param)) {\n    el = param.map(function (v) {\n      return $(v);\n    });\n\n    if (!multi) {\n      el = el.length >= 1 ? el[0] : undefined;\n    }\n  }\n\n  return el;\n}\n\nfunction addEvent(element, type, handler, eventListenerOptions) {\n  if (_consts.SUPPORT_ADDEVENTLISTENER) {\n    var options = eventListenerOptions || false;\n\n    if (typeof eventListenerOptions === \"object\") {\n      options = _consts.SUPPORT_PASSIVE ? eventListenerOptions : false;\n    }\n\n    element.addEventListener(type, handler, options);\n  } else if (element.attachEvent) {\n    element.attachEvent(\"on\" + type, handler);\n  } else {\n    element[\"on\" + type] = handler;\n  }\n}\n\nfunction removeEvent(element, type, handler) {\n  if (element.removeEventListener) {\n    element.removeEventListener(type, handler, false);\n  } else if (element.detachEvent) {\n    element.detachEvent(\"on\" + type, handler);\n  } else {\n    element[\"on\" + type] = null;\n  }\n}\n\nfunction addOnceEvent(element, type, handler, eventListenerOptions) {\n  var callback = function callback(e) {\n    removeEvent(element, type, callback);\n    handler(e);\n  };\n\n  addEvent(element, type, callback, eventListenerOptions);\n}\n\nfunction scroll(el, horizontal) {\n  if (horizontal === void 0) {\n    horizontal = false;\n  }\n\n  var prop = \"scroll\" + (horizontal ? \"Left\" : \"Top\");\n\n  if (el === _browser.window) {\n    return _browser.window[horizontal ? \"pageXOffset\" : \"pageYOffset\"] || _browser.document.body[prop] || _browser.document.documentElement[prop];\n  } else {\n    return el[prop];\n  }\n}\n\nfunction scrollTo(el, x, y) {\n  if (el === _browser.window) {\n    el.scroll(x, y);\n  } else {\n    el.scrollLeft = x;\n    el.scrollTop = y;\n  }\n}\n\nfunction scrollBy(el, x, y) {\n  if (el === _browser.window) {\n    el.scrollBy(x, y);\n  } else {\n    el.scrollLeft += x;\n    el.scrollTop += y;\n  }\n}\n\nfunction getStyles(el) {\n  return (_consts.SUPPORT_COMPUTEDSTYLE ? _browser.window.getComputedStyle(el) : el.currentStyle) || {};\n}\n\nfunction _getSize(el, name, isOffset) {\n  if (el === _browser.window) {\n    // WINDOW\n    return _browser.window[\"inner\" + name] || _browser.document.body[\"client\" + name];\n  } else if (el.nodeType === 9) {\n    // DOCUMENT_NODE\n    var doc = el.documentElement;\n    return Math.max(el.body[\"scroll\" + name], doc[\"scroll\" + name], el.body[\"offset\" + name], doc[\"offset\" + name], doc[\"client\" + name]);\n  } else {\n    // NODE\n    var size = 0;\n\n    if (isOffset) {\n      var clientRect = el.getBoundingClientRect();\n      size = name === \"Width\" ? clientRect.right - clientRect.left : clientRect.bottom - clientRect.top;\n    } else {\n      size = el[\"client\" + name] || el[\"offset\" + name];\n    }\n\n    return parseFloat(size || getStyles(el)[name.toLowerCase()]) || 0;\n  }\n}\n\nfunction innerWidth(el) {\n  return _getSize(el, \"Width\", false);\n}\n\nfunction innerHeight(el) {\n  return _getSize(el, \"Height\", false);\n}\n\nfunction outerWidth(el) {\n  return _getSize(el, \"Width\", true);\n}\n\nfunction outerHeight(el) {\n  return _getSize(el, \"Height\", true);\n}\n\nfunction getSize(el) {\n  return {\n    width: outerWidth(el),\n    height: outerHeight(el)\n  };\n}\n\nvar STYLE = {\n  vertical: {\n    pos1: \"top\",\n    endPos1: \"bottom\",\n    size1: \"height\",\n    pos2: \"left\",\n    endPos2: \"right\",\n    size2: \"width\"\n  },\n  horizontal: {\n    pos1: \"left\",\n    endPos1: \"right\",\n    size1: \"width\",\n    pos2: \"top\",\n    endPos2: \"bottom\",\n    size2: \"height\"\n  }\n};\nexports.STYLE = STYLE;\n\nfunction getStyleNames(isHorizontal) {\n  return STYLE[isHorizontal ? _consts.HORIZONTAL : _consts.VERTICAL];\n}\n\nfunction assignOptions(defaultOptions, options) {\n  return _extends({}, _consts.DEFAULT_OPTIONS, defaultOptions, options);\n}\n\nfunction toZeroArray(outline) {\n  if (!outline || !outline.length) {\n    return [0];\n  }\n\n  return outline;\n}\n\nfunction cloneItems(items) {\n  return items.map(function (item) {\n    return _extends({}, item);\n  });\n}\n\nfunction isWindow(el) {\n  return el === _browser.window;\n}\n\nfunction fill(arr, value) {\n  var length = arr.length;\n\n  for (var i = length - 1; i >= 0; --i) {\n    arr[i] = value;\n  }\n\n  return arr;\n}\n\nfunction isUndefined(target) {\n  return typeof target === \"undefined\";\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/utils.js\n// module id = 0\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\nexports.TRANSITION_END = exports.TRANSITION = exports.TRANSFORM = exports.DEFENSE_BROWSER = exports.WEBKIT_VERSION = exports.PROCESSING = exports.LOADING_PREPEND = exports.LOADING_APPEND = exports.IDLE = exports.ALIGN = exports.isMobile = exports.agent = exports.DEFAULT_OPTIONS = exports.GROUPKEY_ATT = exports.DUMMY_POSITION = exports.SINGLE = exports.MULTI = exports.NO_TRUSTED = exports.TRUSTED = exports.NO_CACHE = exports.CACHE = exports.HORIZONTAL = exports.VERTICAL = exports.PREPEND = exports.APPEND = exports.TRANSITION_NAME = exports.IGNORE_CLASSNAME = exports.CONTAINER_CLASSNAME = exports.IS_ANDROID2 = exports.IS_IOS = exports.IS_IE = exports.SUPPORT_PASSIVE = exports.SUPPORT_ADDEVENTLISTENER = exports.SUPPORT_COMPUTEDSTYLE = void 0;\n\nvar _browser = require(\"./browser\");\n\nvar ua = _browser.window.navigator.userAgent;\nvar SUPPORT_COMPUTEDSTYLE = !!(\"getComputedStyle\" in _browser.window);\nexports.SUPPORT_COMPUTEDSTYLE = SUPPORT_COMPUTEDSTYLE;\nvar SUPPORT_ADDEVENTLISTENER = !!(\"addEventListener\" in _browser.document);\nexports.SUPPORT_ADDEVENTLISTENER = SUPPORT_ADDEVENTLISTENER;\n\nvar SUPPORT_PASSIVE = function () {\n  var supportsPassiveOption = false;\n\n  try {\n    if (SUPPORT_ADDEVENTLISTENER && Object.defineProperty) {\n      _browser.document.addEventListener(\"test\", null, Object.defineProperty({}, \"passive\", {\n        get: function get() {\n          supportsPassiveOption = true;\n        }\n      }));\n    }\n  } catch (e) {}\n\n  return supportsPassiveOption;\n}();\n\nexports.SUPPORT_PASSIVE = SUPPORT_PASSIVE;\nvar IS_IE = /MSIE|Trident|Windows Phone|Edge/.test(ua);\nexports.IS_IE = IS_IE;\nvar IS_IOS = /iPhone|iPad/.test(ua);\nexports.IS_IOS = IS_IOS;\nvar IS_ANDROID2 = /Android 2\\./.test(ua);\nexports.IS_ANDROID2 = IS_ANDROID2;\nvar CONTAINER_CLASSNAME = \"_eg-infinitegrid-container_\";\nexports.CONTAINER_CLASSNAME = CONTAINER_CLASSNAME;\nvar IGNORE_CLASSNAME = \"_eg-infinitegrid-ignore_\";\nexports.IGNORE_CLASSNAME = IGNORE_CLASSNAME;\nvar TRANSITION_NAME = \"_INFINITEGRID_TRANSITION\";\nexports.TRANSITION_NAME = TRANSITION_NAME;\nvar APPEND = true;\nexports.APPEND = APPEND;\nvar PREPEND = false;\nexports.PREPEND = PREPEND;\nvar VERTICAL = \"vertical\";\nexports.VERTICAL = VERTICAL;\nvar HORIZONTAL = \"horizontal\";\nexports.HORIZONTAL = HORIZONTAL;\nvar CACHE = true;\nexports.CACHE = CACHE;\nvar NO_CACHE = false;\nexports.NO_CACHE = NO_CACHE;\nvar TRUSTED = true;\nexports.TRUSTED = TRUSTED;\nvar NO_TRUSTED = false;\nexports.NO_TRUSTED = NO_TRUSTED;\nvar MULTI = true;\nexports.MULTI = MULTI;\nvar SINGLE = false;\nexports.SINGLE = SINGLE;\nvar DUMMY_POSITION = -100000;\nexports.DUMMY_POSITION = DUMMY_POSITION;\nvar GROUPKEY_ATT = \"data-groupkey\";\nexports.GROUPKEY_ATT = GROUPKEY_ATT;\nvar DEFAULT_OPTIONS = {\n  horizontal: false,\n  margin: 0\n};\nexports.DEFAULT_OPTIONS = DEFAULT_OPTIONS;\nvar agent = ua.toLowerCase();\nexports.agent = agent;\nvar isMobile = /mobi|ios|android/.test(agent);\nexports.isMobile = isMobile;\nvar ALIGN = {\n  START: \"start\",\n  CENTER: \"center\",\n  END: \"end\",\n  JUSTIFY: \"justify\"\n};\nexports.ALIGN = ALIGN;\nvar IDLE = 0;\nexports.IDLE = IDLE;\nvar LOADING_APPEND = 1;\nexports.LOADING_APPEND = LOADING_APPEND;\nvar LOADING_PREPEND = 2;\nexports.LOADING_PREPEND = LOADING_PREPEND;\nvar PROCESSING = 4;\nexports.PROCESSING = PROCESSING;\nvar webkit = /applewebkit\\/([\\d|.]*)/g.exec(agent);\nvar WEBKIT_VERSION = webkit && parseInt(webkit[1], 10) || 0;\nexports.WEBKIT_VERSION = WEBKIT_VERSION;\nvar DEFENSE_BROWSER = WEBKIT_VERSION && WEBKIT_VERSION < 537;\nexports.DEFENSE_BROWSER = DEFENSE_BROWSER;\n\nvar _ref = function () {\n  var properties = {\n    transitionend: \"\",\n    webkitTransitionEnd: \"-webkit-\",\n    oTransitionEnd: \"-o-\",\n    mozTransitionEnd: \"-moz-\"\n  };\n\n  for (var property in properties) {\n    var prefix = properties[property];\n\n    if (\"on\" + property.toLowerCase() in _browser.window) {\n      return [prefix + \"transform\", prefix + \"transition\", property];\n    }\n  }\n\n  return [];\n}(),\n    TRANSFORM = _ref[0],\n    TRANSITION = _ref[1],\n    TRANSITION_END = _ref[2];\n\nexports.TRANSITION_END = TRANSITION_END;\nexports.TRANSITION = TRANSITION;\nexports.TRANSFORM = TRANSFORM;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/consts.js\n// module id = 1\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\nexports.document = exports.window = void 0;\n\n/* eslint-disable no-new-func, no-nested-ternary */\nif (typeof window === \"undefined\") {\n  global.window = {\n    document: {},\n    navigator: {\n      userAgent: \"\"\n    }\n  };\n}\n\nvar win = window;\n/* eslint-enable no-new-func, no-nested-ternary */\n\nexports.window = win;\nvar document = win.document;\nexports.document = document;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/browser.js\n// module id = 2\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _consts = require(\"./consts\");\n\nvar _utils = require(\"./utils\");\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nvar ItemManager =\n/*#__PURE__*/\nfunction () {\n  ItemManager.from = function from(elements, selector, _ref) {\n    var groupKey = _ref.groupKey,\n        isAppend = _ref.isAppend;\n    var filted = ItemManager.selectItems((0, _utils.$)(elements, _consts.MULTI), selector); // Item Structure\n\n    return (0, _utils.toArray)(filted).map(function (el) {\n      return {\n        el: el,\n        groupKey: groupKey,\n        content: el.outerHTML,\n        rect: {\n          top: _consts.DUMMY_POSITION,\n          left: _consts.DUMMY_POSITION\n        }\n      };\n    });\n  };\n\n  ItemManager.selectItems = function selectItems(elements, selector) {\n    return elements.filter(function (v) {\n      var classNames = v.className.split(\" \");\n\n      if (classNames.some(function (c) {\n        return c === _consts.IGNORE_CLASSNAME;\n      })) {\n        return false;\n      } else if (!selector || selector === \"*\") {\n        return v;\n      } else {\n        return classNames.some(function (c) {\n          return c === selector;\n        });\n      }\n    });\n  };\n\n  ItemManager.pluck = function pluck(data, property) {\n    return data.reduce(function (acc, v) {\n      return acc.concat(v[property]);\n    }, []);\n  };\n\n  function ItemManager() {\n    this.clear();\n  }\n\n  var _proto = ItemManager.prototype;\n\n  _proto.getStatus = function getStatus(startKey, endKey) {\n    var datas = this._data;\n    var startIndex = Math.max(this.indexOf(startKey), 0);\n    var endIndex = this.indexOf(endKey) + 1 || datas.length;\n    return {\n      _data: datas.slice(startIndex, endIndex).map(function (data) {\n        var items = data.items.map(function (item) {\n          var item2 = _extends({}, item);\n\n          delete item2.el;\n          return item2;\n        });\n\n        var data2 = _extends({}, data);\n\n        data2.items = items;\n        return data2;\n      })\n    };\n  };\n\n  _proto.setStatus = function setStatus(status) {\n    var data = status._data;\n    this.set(data);\n  };\n\n  _proto.size = function size() {\n    return this._data.length;\n  };\n\n  _proto.fit = function fit(base, horizontal) {\n    if (!this._data.length) {\n      return;\n    }\n\n    var property = horizontal ? \"left\" : \"top\";\n\n    if (base !== 0) {\n      this._data = this._data.map(function (v) {\n        v.items = v.items.map(function (item) {\n          item.rect[property] -= base;\n          return item;\n        });\n        v.outlines.start = v.outlines.start.map(function (start) {\n          return start - base;\n        });\n        v.outlines.end = v.outlines.end.map(function (end) {\n          return end - base;\n        });\n        return v;\n      });\n    }\n  };\n\n  _proto.pluck = function pluck(property, start, end) {\n    var data = (0, _utils.isUndefined)(start) ? this._data : this._data.slice(start, ((0, _utils.isUndefined)(end) ? start : end) + 1);\n    return ItemManager.pluck(data, property);\n  };\n\n  _proto.getOutline = function getOutline(index, property) {\n    var data = this._data[index];\n    return data ? data.outlines[property] : [];\n  };\n\n  _proto.getEdgeIndex = function getEdgeIndex(cursor, start, end) {\n    var prop = cursor === \"start\" ? \"min\" : \"max\";\n    var index = -1;\n    var targetValue = cursor === \"start\" ? Infinity : -Infinity;\n\n    for (var i = start; i <= end; i++) {\n      var value = Math[prop].apply(Math, this.getOutline(i, cursor));\n\n      if (cursor === \"start\" && targetValue > value || cursor === \"end\" && targetValue < value) {\n        targetValue = value;\n        index = i;\n      }\n    }\n\n    return index;\n  };\n\n  _proto.getEdgeValue = function getEdgeValue(cursor, start, end) {\n    var outlines = this.pluck(\"outlines\", this.getEdgeIndex(cursor, start, end)).reduce(function (acc, v) {\n      return acc.concat(v[cursor]);\n    }, []);\n    return outlines.length ? Math[cursor === \"start\" ? \"min\" : \"max\"].apply(Math, outlines) : 0;\n  };\n\n  _proto.clearOutlines = function clearOutlines(startCursor, endCursor) {\n    if (startCursor === void 0) {\n      startCursor = -1;\n    }\n\n    if (endCursor === void 0) {\n      endCursor = -1;\n    }\n\n    var datas = this.get();\n    datas.forEach(function (group, cursor) {\n      if (startCursor <= cursor && cursor <= endCursor) {\n        return;\n      }\n\n      group.items.forEach(function (item) {\n        item.rect.top = _consts.DUMMY_POSITION;\n        item.rect.left = _consts.DUMMY_POSITION;\n      });\n      group.outlines.start = [];\n      group.outlines.end = [];\n    });\n  };\n\n  _proto.getMaxEdgeValue = function getMaxEdgeValue() {\n    var groups = this.get();\n    var length = groups.length;\n\n    for (var i = length - 1; i >= 0; --i) {\n      var end = groups[i].outlines.end;\n\n      if (end.length) {\n        var pos = Math.max.apply(Math, end);\n        return pos;\n      }\n    }\n\n    return 0;\n  };\n\n  _proto.append = function append(layouted) {\n    this._data.push(layouted);\n\n    return layouted.items;\n  };\n\n  _proto.prepend = function prepend(layouted) {\n    this._data.unshift(layouted);\n\n    return layouted.items;\n  };\n\n  _proto.clear = function clear() {\n    this._data = [];\n  };\n\n  _proto.remove = function remove(element, start, end) {\n    var items = [];\n    var key = element.getAttribute(_consts.GROUPKEY_ATT);\n    var data = this.get(start, end).filter(function (v) {\n      return String(v.groupKey) === key;\n    });\n\n    if (!data.length) {\n      return items;\n    }\n\n    data = data[0];\n    var len = data.items.length;\n    var idx = -1;\n\n    for (var i = 0; i < len; i++) {\n      if (data.items[i].el === element) {\n        idx = i;\n        break;\n      }\n    }\n\n    if (~idx) {\n      // remove item information\n      data.items.splice(idx, 1);\n      this.set(data, key);\n      items = data.items;\n    }\n\n    return items;\n  };\n\n  _proto.indexOf = function indexOf(data) {\n    var groupKey = typeof data === \"object\" ? data.groupKey : data;\n    var datas = this._data;\n    var length = datas.length;\n\n    for (var i = 0; i < length; ++i) {\n      if (groupKey === datas[i].groupKey) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  _proto.get = function get(start, end) {\n    return (0, _utils.isUndefined)(start) ? this._data : this._data.slice(start, ((0, _utils.isUndefined)(end) ? start : end) + 1);\n  };\n\n  _proto.set = function set(data, key) {\n    if (!(0, _utils.isUndefined)(key) && !Array.isArray(data)) {\n      var len = this._data.length;\n      var idx = -1;\n\n      for (var i = 0; i < len; i++) {\n        if (this._data[i].groupKey === key) {\n          idx = i;\n          break;\n        }\n      }\n\n      ~idx && (this._data[idx] = data);\n    } else {\n      this._data = data.concat();\n    }\n  };\n\n  _proto.getData = function getData(index) {\n    return this._data[index];\n  };\n\n  return ItemManager;\n}();\n\nexports[\"default\"] = ItemManager;\nmodule.exports = exports[\"default\"];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ItemManager.js\n// module id = 3\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _consts = require(\"./consts\");\n\nvar _browser = require(\"./browser\");\n\nvar _utils = require(\"./utils\");\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction createContainer(element) {\n  var container = _browser.document.createElement(\"div\");\n\n  container.className = _consts.CONTAINER_CLASSNAME;\n  container.style.position = \"relative\";\n  container.style.height = \"100%\";\n  var children = element.children;\n  var length = children.length; // for IE8\n\n  for (var i = 0; i < length; i++) {\n    container.appendChild(children[0]);\n  }\n\n  element.appendChild(container);\n  return container;\n}\n\nfunction render(properties, rect, styles) {\n  properties.forEach(function (p) {\n    p in rect && (styles[p] = rect[p] + \"px\");\n  });\n}\n\nfunction setTransition(styles, transitionDuration, pos1, pos2) {\n  styles[_consts.TRANSITION + \"-property\"] = transitionDuration ? _consts.TRANSFORM + \",width,height\" : \"\";\n  styles[_consts.TRANSITION + \"-duration\"] = transitionDuration ? transitionDuration + \"s\" : \"\";\n  styles[_consts.TRANSITION + \"-delay\"] = transitionDuration ? \"0s\" : \"\";\n  styles[_consts.TRANSFORM] = transitionDuration ? \"translate(\" + (pos1.left - pos2.left) + \"px,\" + (pos1.top - pos2.top) + \"px)\" : \"\";\n}\n\nvar DOMRenderer =\n/*#__PURE__*/\nfunction () {\n  DOMRenderer.renderItem = function renderItem(item, rect, transitionDuration) {\n    if (!item.el) {\n      return;\n    }\n\n    var el = item.el,\n        prevRect = item.prevRect;\n    var styles = el.style; // for debugging\n\n    el.setAttribute(_consts.GROUPKEY_ATT, item.groupKey);\n    styles.position = \"absolute\";\n    render([\"width\", \"height\"], rect, styles);\n\n    if (transitionDuration && _consts.TRANSITION && prevRect) {\n      setTransition(styles, transitionDuration, rect, prevRect);\n\n      if (el[_consts.TRANSITION_NAME]) {\n        return;\n      }\n\n      el[_consts.TRANSITION_NAME] = true;\n      (0, _utils.addOnceEvent)(el, _consts.TRANSITION_END, function () {\n        var itemRect = item.rect;\n        setTransition(styles);\n        render([\"left\", \"top\"], itemRect, styles);\n        item.prevRect = itemRect;\n        el[_consts.TRANSITION_NAME] = false;\n      });\n    } else {\n      render([\"left\", \"top\"], rect, styles);\n      item.prevRect = rect;\n    }\n  };\n\n  DOMRenderer.renderItems = function renderItems(items, transitionDuration) {\n    items.forEach(function (item) {\n      DOMRenderer.renderItem(item, item.rect, transitionDuration);\n    });\n  };\n\n  DOMRenderer.removeItems = function removeItems(items) {\n    items.forEach(function (item) {\n      if (item.el) {\n        DOMRenderer.removeElement(item.el);\n        item.el = null;\n      }\n    });\n  };\n\n  DOMRenderer.removeElement = function removeElement(element) {\n    var parentNode = element && element.parentNode;\n\n    if (!parentNode) {\n      return;\n    }\n\n    parentNode.removeChild(element);\n  };\n\n  DOMRenderer.createElements = function createElements(items) {\n    if (!items.length) {\n      return;\n    }\n\n    var noElementItems = items.filter(function (item) {\n      return !item.el;\n    });\n\n    if (!noElementItems.length) {\n      return;\n    }\n\n    var elements = (0, _utils.$)(noElementItems.map(function (_ref) {\n      var content = _ref.content;\n      return content.replace(/^[\\s\\uFEFF]+|[\\s\\uFEFF]+$/g, \"\");\n    }).join(\"\"), _consts.MULTI);\n    noElementItems.forEach(function (item, index) {\n      item.el = elements[index];\n    });\n  };\n\n  function DOMRenderer(element, options) {\n    _extends(this.options = {\n      isEqualSize: false,\n      isConstantSize: false,\n      horizontal: false,\n      container: false\n    }, options);\n\n    this._size = {\n      container: -1,\n      view: -1,\n      viewport: -1,\n      item: null\n    };\n\n    this._init(element);\n\n    this.resize();\n  }\n\n  var _proto = DOMRenderer.prototype;\n\n  _proto.getStatus = function getStatus() {\n    return {\n      cssText: this.container.style.cssText,\n      _size: _extends({}, this._size)\n    };\n  };\n\n  _proto.setStatus = function setStatus(status) {\n    this.container.style.cssText = status.cssText;\n\n    _extends(this._size, status._size);\n  };\n\n  _proto.updateSize = function updateSize(items) {\n    var _this$options = this.options,\n        isEqualSize = _this$options.isEqualSize,\n        isConstantSize = _this$options.isConstantSize;\n    var size = this._size;\n    return items.map(function (item) {\n      if (!item.el) {\n        return item;\n      }\n\n      if (isEqualSize && !size.item) {\n        size.item = (0, _utils.getSize)(item.el);\n      }\n\n      item.size = isEqualSize && _extends(size.item) || isConstantSize && item.orgSize && _extends(item.orgSize) || (0, _utils.getSize)(item.el);\n\n      if (!item.orgSize) {\n        item.orgSize = _extends({}, item.size);\n      }\n\n      return item;\n    });\n  };\n\n  _proto._init = function _init(el) {\n    var element = (0, _utils.$)(el);\n    var style = (0, _utils.getStyles)(element);\n    var _this$options2 = this.options,\n        container = _this$options2.container,\n        horizontal = _this$options2.horizontal;\n    this._orgStyle = {};\n\n    if (style.position === \"static\") {\n      this._orgStyle.position = element.style.position;\n      element.style.position = \"relative\";\n    }\n\n    if (container) {\n      var target = horizontal ? [\"X\", \"Y\"] : [\"Y\", \"X\"];\n      this._orgStyle.overflowX = element.style.overflowX;\n      this._orgStyle.overflowY = element.style.overflowY;\n      element.style[\"overflow\" + target[0]] = \"scroll\";\n      element.style[\"overflow\" + target[1]] = \"hidden\";\n      this.view = element;\n      this.container = container === true ? createContainer(this.view) : container;\n    } else {\n      this.view = _browser.window;\n      this.container = element;\n    }\n  };\n\n  _proto.append = function append(items) {\n    this._insert(items, _consts.APPEND, {\n      top: _consts.DUMMY_POSITION,\n      left: _consts.DUMMY_POSITION\n    });\n  };\n\n  _proto.prepend = function prepend(items) {\n    this._insert(items, _consts.PREPEND, {\n      top: _consts.DUMMY_POSITION,\n      left: _consts.DUMMY_POSITION\n    });\n  };\n\n  _proto.createAndInsert = function createAndInsert(items, isAppend) {\n    DOMRenderer.createElements(items);\n    DOMRenderer.renderItems(items);\n\n    this._insert(items, isAppend);\n  };\n\n  _proto._insert = function _insert(items, isAppend, styles) {\n    var container = this.container;\n\n    var df = _browser.document.createDocumentFragment();\n\n    items.forEach(function (item) {\n      styles && DOMRenderer.renderItem(item, styles);\n      isAppend ? df.appendChild(item.el) : df.insertBefore(item.el, df.firstChild);\n    });\n    isAppend ? container.appendChild(df) : container.insertBefore(df, container.firstChild);\n  };\n\n  _proto._calcSize = function _calcSize() {\n    return this.options.horizontal ? (0, _utils.innerHeight)(this.container) : (0, _utils.innerWidth)(this.container);\n  };\n\n  _proto.getViewSize = function getViewSize() {\n    return this._size.view;\n  };\n\n  _proto.getViewportSize = function getViewportSize() {\n    return this._size.viewport;\n  };\n\n  _proto.setContainerSize = function setContainerSize(size) {\n    this.container.style[this.options.horizontal ? \"width\" : \"height\"] = size + \"px\";\n  };\n\n  _proto.resize = function resize() {\n    var horizontal = this.options.horizontal;\n    var view = this.view;\n    var isResize = this.isNeededResize();\n\n    if (isResize) {\n      this._size = {\n        viewport: this._calcSize(),\n        item: null\n      };\n    }\n\n    this._size.view = horizontal ? (0, _utils.innerWidth)(view) : (0, _utils.innerHeight)(view);\n    return isResize;\n  };\n\n  _proto.isNeededResize = function isNeededResize() {\n    return this._calcSize() !== this._size.viewport;\n  };\n\n  _proto.clear = function clear() {\n    this.container.innerHTML = \"\";\n    this.container.style[this.options.horizontal ? \"width\" : \"height\"] = \"\";\n    this._size = {\n      item: null,\n      viewport: -1,\n      container: -1,\n      view: -1\n    };\n  };\n\n  _proto.destroy = function destroy() {\n    this.clear();\n    var container = this.options.container;\n\n    for (var p in this._orgStyle) {\n      this[container ? \"view\" : \"container\"].style[p] = this._orgStyle[p];\n    }\n\n    container && this.container.parentNode.removeChild(this.container);\n  };\n\n  return DOMRenderer;\n}();\n\nexports[\"default\"] = DOMRenderer;\nmodule.exports = exports[\"default\"];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/DOMRenderer.js\n// module id = 4\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _browser = require(\"./browser\");\n\nvar _utils = require(\"./utils\");\n\nvar elements = [];\n/* eslint-disable */\n\nfunction onResize(e) {\n  AutoSizer.resizeAll();\n}\n/* eslint-enable */\n\n\nvar AutoSizer =\n/*#__PURE__*/\nfunction () {\n  function AutoSizer() {}\n\n  AutoSizer.add = function add(element, prefix) {\n    if (prefix === void 0) {\n      prefix = \"data-\";\n    }\n\n    if (!element.length) {\n      (0, _utils.addEvent)(_browser.window, \"resize\", onResize);\n    }\n\n    element.__PREFIX__ = prefix;\n    elements.push(element);\n    AutoSizer.resize(element);\n  };\n\n  AutoSizer.remove = function remove(element, isFixed) {\n    if (isFixed === void 0) {\n      isFixed = false;\n    }\n\n    var fixed = element.getAttribute(element.__PREFIX__ + \"fixed\") || \"width\";\n\n    if (!isFixed) {\n      element.style[fixed === \"width\" ? \"height\" : \"width\"] = \"\";\n    }\n\n    var index = elements.indexOf(element);\n\n    if (!~index) {\n      return;\n    }\n\n    elements.splice(index, 1);\n\n    if (!elements.length) {\n      (0, _utils.removeEvent)(_browser.window, \"reisze\", onResize);\n    }\n  };\n\n  AutoSizer.resize = function resize(element, prefix) {\n    if (prefix === void 0) {\n      prefix = \"data-\";\n    }\n\n    var elementPrefix = typeof element.__PREFIX__ === \"string\" ? element.__PREFIX__ : prefix;\n    var dataWidth = element.getAttribute(elementPrefix + \"width\");\n    var dataHeight = element.getAttribute(elementPrefix + \"height\");\n    var fixed = element.getAttribute(elementPrefix + \"fixed\");\n\n    if (fixed === \"height\") {\n      var size = (0, _utils.innerHeight)(element) || dataHeight;\n      element.style.width = dataWidth / dataHeight * size + \"px\";\n    } else {\n      var _size = (0, _utils.innerWidth)(element) || dataWidth;\n\n      element.style.height = dataHeight / dataWidth * _size + \"px\";\n    }\n  };\n\n  AutoSizer.resizeAll = function resizeAll() {\n    elements.forEach(function (element) {\n      return AutoSizer.resize(element);\n    });\n  };\n\n  return AutoSizer;\n}();\n\nexports[\"default\"] = AutoSizer;\nmodule.exports = exports[\"default\"];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/AutoSizer.js\n// module id = 5\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _consts = require(\"./consts\");\n\nvar _utils = require(\"./utils\");\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nvar Watcher =\n/*#__PURE__*/\nfunction () {\n  function Watcher(view, options) {\n    _extends(this.options = {\n      container: view,\n      resize: function resize() {},\n      check: function check() {},\n      isOverflowScroll: false,\n      horizontal: false\n    }, options);\n\n    this._timer = {\n      resize: null // doubleCheck: null,\n      // doubleCheckCount: RETRY,\n\n    };\n    this.reset();\n    this._containerOffset = 0;\n    this._view = view;\n    this._scrollIssue = _consts.IS_IOS;\n    this._onCheck = this._onCheck.bind(this);\n    this._onResize = this._onResize.bind(this);\n    this.attachEvent();\n    this.setScrollPos();\n    this.resize();\n  }\n\n  var _proto = Watcher.prototype;\n\n  _proto.getStatus = function getStatus() {\n    return {\n      _prevPos: this._prevPos,\n      scrollPos: this.getOrgScrollPos()\n    };\n  };\n\n  _proto.setStatus = function setStatus(status, applyScrollPos) {\n    if (applyScrollPos === void 0) {\n      applyScrollPos = true;\n    }\n\n    this._prevPos = status._prevPos;\n    applyScrollPos && this.scrollTo(status.scrollPos);\n  };\n\n  _proto.scrollBy = function scrollBy(pos) {\n    var arrPos = this.options.horizontal ? [pos, 0] : [0, pos];\n\n    _utils.scrollBy.apply(void 0, [this._view].concat(arrPos));\n\n    this.setScrollPos();\n  };\n\n  _proto.scrollTo = function scrollTo(pos) {\n    var arrPos = this.options.horizontal ? [pos, 0] : [0, pos];\n\n    _utils.scrollTo.apply(void 0, [this._view].concat(arrPos));\n  };\n\n  _proto.getScrollPos = function getScrollPos() {\n    return this._prevPos;\n  };\n\n  _proto.setScrollPos = function setScrollPos(pos) {\n    var rawPos = pos;\n\n    if (typeof pos === \"undefined\") {\n      rawPos = this.getOrgScrollPos();\n    }\n\n    this._prevPos = rawPos - this.getContainerOffset();\n  };\n\n  _proto.attachEvent = function attachEvent() {\n    (0, _utils.addEvent)(this._view, \"scroll\", this._onCheck);\n    (0, _utils.addEvent)(window, \"resize\", this._onResize);\n  };\n\n  _proto.getOrgScrollPos = function getOrgScrollPos() {\n    return (0, _utils.scroll)(this._view, this.options.horizontal);\n  };\n\n  _proto.reset = function reset() {\n    this._prevPos = null;\n  };\n\n  _proto._onCheck = function _onCheck() {\n    var prevPos = this.getScrollPos();\n    var orgScrollPos = this.getOrgScrollPos();\n    this.setScrollPos(orgScrollPos);\n    var scrollPos = this.getScrollPos();\n\n    if (prevPos === null || this._scrollIssue && orgScrollPos === 0 || prevPos === scrollPos) {\n      orgScrollPos && (this._scrollIssue = false);\n      return;\n    }\n\n    this._scrollIssue = false;\n    this.options.check({\n      isForward: prevPos < scrollPos,\n      scrollPos: scrollPos,\n      orgScrollPos: orgScrollPos,\n      horizontal: this.options.horizontal\n    });\n  };\n\n  _proto.getContainerOffset = function getContainerOffset() {\n    return this._containerOffset;\n  };\n\n  _proto._getOffset = function _getOffset() {\n    var _this$options = this.options,\n        container = _this$options.container,\n        horizontal = _this$options.horizontal;\n    var rect = container.getBoundingClientRect();\n    return rect[horizontal ? \"left\" : \"top\"] + this.getOrgScrollPos();\n  };\n\n  _proto.resize = function resize() {\n    this._containerOffset = this.options.isOverflowScroll ? 0 : this._getOffset();\n  };\n\n  _proto._onResize = function _onResize() {\n    var _this = this;\n\n    if (this._timer.resize) {\n      clearTimeout(this._timer.resize);\n    }\n\n    this._timer.resize = setTimeout(function () {\n      _this.resize();\n\n      _this.options.resize();\n\n      _this._timer.resize = null;\n\n      _this.reset();\n    }, 100);\n  };\n\n  _proto.detachEvent = function detachEvent() {\n    (0, _utils.removeEvent)(this._view, \"scroll\", this._onCheck);\n    (0, _utils.removeEvent)(window, \"resize\", this._onResize);\n  };\n\n  _proto.destroy = function destroy() {\n    this.detachEvent();\n    this.reset();\n  };\n\n  return Watcher;\n}();\n\nexports[\"default\"] = Watcher;\nmodule.exports = exports[\"default\"];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Watcher.js\n// module id = 6\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction isVisible(group, threshold, scrollPos, endScrollPos) {\n  var items = group.items,\n      outlines = group.outlines;\n  var start = outlines.start;\n  var end = outlines.end;\n\n  if (start.legnth === 0 || end.length === 0 || !items.length || !items[0].el) {\n    return 2;\n  }\n\n  var min = Math.min.apply(Math, start);\n  var max = Math.max.apply(Math, end);\n\n  if (endScrollPos + threshold < min) {\n    return +1;\n  } else if (scrollPos - threshold > max) {\n    return -1;\n  }\n\n  return 0;\n}\n\nvar Infinite =\n/*#__PURE__*/\nfunction () {\n  function Infinite(itemManger, options) {\n    this.options = _extends({\n      useRecycle: true,\n      threshold: 100,\n      append: function append() {},\n      prepend: function prepend() {},\n      recycle: function recycle() {}\n    }, options);\n    this._items = itemManger;\n    this.clear();\n  }\n\n  var _proto = Infinite.prototype;\n\n  _proto.setSize = function setSize(size) {\n    this._status.size = size;\n  };\n\n  _proto.recycle = function recycle(scrollPos, isForward) {\n    if (!this.options.useRecycle) {\n      return;\n    }\n\n    var _this$_status = this._status,\n        startCursor = _this$_status.startCursor,\n        endCursor = _this$_status.endCursor,\n        size = _this$_status.size;\n\n    if (startCursor === -1 || endCursor === -1) {\n      return;\n    }\n\n    var endScrollPos = scrollPos + size;\n    var _this$options = this.options,\n        threshold = _this$options.threshold,\n        recycle = _this$options.recycle;\n\n    var visibles = this._items.get(startCursor, endCursor).map(function (group) {\n      return isVisible(group, threshold, scrollPos, endScrollPos);\n    });\n\n    var length = visibles.length;\n    var start = isForward ? 0 : visibles.lastIndexOf(0);\n    var end = isForward ? visibles.indexOf(0) - 1 : visibles.length - 1;\n\n    if (!isForward && start !== -1) {\n      start += 1;\n    }\n\n    if (start < 0 || end < 0 || start > end || end - start + 1 >= length) {\n      return;\n    }\n\n    start = startCursor + start;\n    end = startCursor + end;\n    recycle({\n      start: start,\n      end: end\n    });\n\n    if (isForward) {\n      this.setCursor(\"start\", end + 1);\n    } else {\n      this.setCursor(\"end\", start - 1);\n    }\n  };\n\n  _proto.scroll = function scroll(scrollPos) {\n    var startCursor = this.getCursor(\"start\");\n    var endCursor = this.getCursor(\"end\");\n    var items = this._items;\n\n    if (typeof scrollPos !== \"number\" || startCursor === -1 || endCursor === -1 || !items.size()) {\n      return;\n    }\n\n    var size = this._status.size;\n    var _this$options2 = this.options,\n        threshold = _this$options2.threshold,\n        append = _this$options2.append,\n        prepend = _this$options2.prepend;\n    var datas = items.get();\n    var endScrollPos = scrollPos + size;\n    var startEdgePos = Math.max.apply(Math, datas[startCursor].outlines.start);\n    var endEdgePos = Math.min.apply(Math, datas[endCursor].outlines.end);\n    var visibles = datas.map(function (group, i) {\n      var _group$outlines = group.outlines,\n          start = _group$outlines.start,\n          end = _group$outlines.end;\n\n      if (!start.length || !end.length) {\n        return false;\n      }\n\n      var startPos = Math.min.apply(Math, start);\n      var endPos = Math.max.apply(Math, end);\n\n      if (startPos - threshold <= endScrollPos && scrollPos <= endPos + threshold) {\n        return true;\n      }\n\n      return false;\n    });\n    var start = visibles.indexOf(true);\n    var end = visibles.lastIndexOf(true);\n\n    if (~start && start < startCursor) {\n      prepend({\n        cache: datas.slice(start, Math.min(startCursor, end + 1))\n      });\n    } else if (endCursor < end) {\n      append({\n        cache: datas.slice(Math.max(start, endCursor + 1), end + 1)\n      });\n    } else if (endScrollPos >= endEdgePos - threshold) {\n      append({\n        cache: datas.slice(endCursor + 1, endCursor + 2)\n      });\n    } else if (scrollPos <= startEdgePos + threshold) {\n      prepend({\n        cache: datas.slice(startCursor - 1, startCursor)\n      });\n    }\n  };\n\n  _proto.setCursor = function setCursor(cursor, index) {\n    var status = this._status;\n    var items = this._items;\n    var size = items.size();\n\n    if (!this.options.useRecycle) {\n      status.startCursor = 0;\n\n      if (items.getOutline(size - 1, \"end\").length) {\n        status.endCursor = size - 1;\n        return;\n      }\n\n      if (cursor !== \"end\") {\n        return;\n      }\n    }\n\n    if (cursor === \"start\") {\n      status.startCursor = index;\n    } else {\n      status.endCursor = Math.min(size - 1, index);\n    }\n\n    status.startCursor = Math.max(0, status.startCursor);\n  };\n\n  _proto.setStatus = function setStatus(status) {\n    this._status = _extends(this._status, status);\n  };\n\n  _proto.getStatus = function getStatus(startKey, endKey) {\n    var _this$_status2 = this._status,\n        startCursor = _this$_status2.startCursor,\n        endCursor = _this$_status2.endCursor,\n        size = _this$_status2.size;\n    var startIndex = Math.max(this._items.indexOf(startKey), 0);\n    var endIndex = (this._items.indexOf(endKey) + 1 || this._items.size()) - 1;\n    var start = Math.max(startCursor - startIndex, ~startCursor ? 0 : -1);\n    var end = Math.max(Math.min(endCursor - startIndex, endIndex - startIndex), start);\n    return {\n      startCursor: start,\n      endCursor: end,\n      size: size\n    };\n  };\n\n  _proto.getEdgeOutline = function getEdgeOutline(cursor) {\n    var _this$_status3 = this._status,\n        startCursor = _this$_status3.startCursor,\n        endCursor = _this$_status3.endCursor;\n\n    if (startCursor === -1 || endCursor === -1) {\n      return [];\n    }\n\n    return this._items.getOutline(cursor === \"start\" ? startCursor : endCursor, cursor);\n  };\n\n  _proto.getEdgeValue = function getEdgeValue(cursor) {\n    var outlines = this.getEdgeOutline(cursor);\n    return outlines.length ? Math[cursor === \"start\" ? \"min\" : \"max\"].apply(Math, outlines) : 0;\n  };\n\n  _proto.getVisibleItems = function getVisibleItems() {\n    return this._items.pluck(\"items\", this._status.startCursor, this._status.endCursor);\n  };\n\n  _proto.getCursor = function getCursor(cursor) {\n    return this._status[cursor === \"start\" ? \"startCursor\" : \"endCursor\"];\n  };\n\n  _proto.getVisibleData = function getVisibleData() {\n    return this._items.get(this._status.startCursor, this._status.endCursor);\n  };\n\n  _proto.remove = function remove(element) {\n    return this._items.remove(element, this._status.startCursor, this._status.endCursor);\n  };\n\n  _proto.clear = function clear() {\n    this._status = {\n      startCursor: -1,\n      endCursor: -1,\n      size: -1\n    };\n  };\n\n  return Infinite;\n}();\n\nvar _default = Infinite;\nexports[\"default\"] = _default;\nmodule.exports = exports[\"default\"];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Infinite.js\n// module id = 7\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _AutoSizer = _interopRequireDefault(require(\"./AutoSizer\"));\n\nvar _ImageLoaded = _interopRequireWildcard(require(\"./ImageLoaded\"));\n\nvar _ItemManager = _interopRequireDefault(require(\"./ItemManager\"));\n\nvar _utils = require(\"./utils\");\n\nvar _consts = require(\"./consts\");\n\nvar _DOMRenderer = _interopRequireDefault(require(\"./DOMRenderer\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj[\"default\"] = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction hasTarget(target, value) {\n  return ~target.indexOf(value);\n}\n\nvar LayoutMananger =\n/*#__PURE__*/\nfunction () {\n  function LayoutMananger(items, renderer, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    _extends(this.options = {\n      attributePrefix: \"data-\",\n      isEqualSize: false,\n      isConstantSize: false,\n      horizontal: false\n    }, options);\n\n    this._items = items;\n    this._renderer = renderer;\n    this._layout = null;\n  }\n\n  var _proto = LayoutMananger.prototype;\n\n  _proto.setLayout = function setLayout(layout) {\n    this._layout = layout;\n  };\n\n  _proto.setSize = function setSize(size) {\n    this._layout.setSize(size);\n  };\n\n  _proto._complete = function _complete(groups, items, isAppend, isUpdate, callback) {\n    var _this = this;\n\n    var itemManager = this._items;\n    var cursor = isAppend ? \"end\" : \"start\";\n    var groupIndex = itemManager.indexOf(groups[0]);\n    var prevGroup = itemManager.getData(groupIndex + (isAppend ? -1 : 1));\n    var outline = prevGroup ? prevGroup.outlines[cursor] : [0];\n\n    this._renderer.updateSize(items);\n\n    var groupInfos = groups.map(function (group) {\n      var groupOutline = group.outlines[isAppend ? \"start\" : \"end\"];\n      var isRelayout = isUpdate || !outline.length || (outline.length === groupOutline.length ? !outline.every(function (v, index) {\n        return v === groupOutline[index];\n      }) : true);\n\n      if (!isRelayout) {\n        outline = group.outlines[isAppend ? \"end\" : \"start\"];\n\n        _DOMRenderer[\"default\"].renderItems(group.items);\n\n        return group;\n      }\n\n      var groupItems = group.items;\n\n      var groupInfo = _this._layout[isAppend ? \"append\" : \"prepend\"](groupItems, outline, true);\n\n      _extends(group, groupInfo);\n\n      _DOMRenderer[\"default\"].renderItems(groupInfo.items);\n\n      outline = groupInfo.outlines[isAppend ? \"end\" : \"start\"];\n      return groupInfo;\n    });\n    callback({\n      groups: groupInfos,\n      items: items,\n      isAppend: isAppend\n    });\n  };\n\n  _proto._error = function _error(removeTarget, replaceTarget, target, items, errorIndex, callback) {\n    var item = items[errorIndex];\n    var element = item.el;\n    var prefix = this.options.attributePrefix; // remove item\n\n    var removeItem = function removeItem() {\n      if (hasTarget(removeTarget, element)) {\n        return;\n      }\n\n      removeTarget.push(element);\n      var index = replaceTarget.indexOf(errorIndex);\n      index !== -1 && replaceTarget.splice(index, 1);\n    }; // remove image\n\n\n    var remove = function remove() {\n      if (target === element) {\n        removeItem();\n        return;\n      }\n\n      if (hasTarget(removeTarget, element)) {\n        return;\n      }\n\n      target.parentNode.removeChild(target);\n      item.content = element.outerHTML;\n\n      if (hasTarget(replaceTarget, errorIndex)) {\n        return;\n      }\n\n      replaceTarget.push(errorIndex);\n    }; // replace image\n\n\n    var replace = function replace(src) {\n      if (hasTarget(removeTarget, element)) {\n        return;\n      }\n\n      if (src) {\n        if ((0, _utils.matchHTML)(src) || typeof src === \"object\") {\n          var parentNode = target.parentNode;\n          parentNode.insertBefore((0, _utils.$)(src), target);\n          parentNode.removeChild(target);\n          item.content = element.outerHTML;\n        } else {\n          target.src = src;\n\n          if (target.getAttribute(prefix + \"width\")) {\n            _AutoSizer[\"default\"].remove(target);\n\n            target.removeAttribute(prefix + \"width\");\n            target.removeAttribute(prefix + \"height\");\n          }\n        }\n      }\n\n      item.content = element.outerHTML;\n\n      if (hasTarget(replaceTarget, errorIndex)) {\n        return;\n      }\n\n      replaceTarget.push(errorIndex);\n    }; // replace item\n\n\n    var replaceItem = function replaceItem(content) {\n      if (hasTarget(removeTarget, element)) {\n        return;\n      }\n\n      element.innerHTML = content;\n      item.content = element.outerHTML;\n\n      if (hasTarget(replaceTarget, errorIndex)) {\n        return;\n      }\n\n      replaceTarget.push(errorIndex);\n    };\n\n    callback({\n      target: target,\n      element: element,\n      items: items,\n      item: item,\n      itemIndex: errorIndex,\n      replace: replace,\n      replaceItem: replaceItem,\n      remove: remove,\n      removeItem: removeItem\n    });\n  };\n\n  _proto._end = function _end(removeTarget, replaceTarget, items, callback) {\n    var _this2 = this;\n\n    var attributePrefix = this.options.attributePrefix;\n    var removeTargetLength = removeTarget.length;\n    var replaceTargetLength = replaceTarget.length;\n\n    if (!removeTargetLength && !replaceTargetLength) {\n      callback({\n        remove: []\n      });\n      return;\n    }\n\n    var layoutedItems = replaceTarget.map(function (itemIndex) {\n      return items[itemIndex];\n    });\n\n    if (!replaceTargetLength) {\n      callback({\n        remove: removeTarget,\n        layout: true\n      });\n      return;\n    } // wait layoutComplete beacause of error event.\n\n\n    _ImageLoaded[\"default\"].check(layoutedItems.map(function (v) {\n      return v.el;\n    }), {\n      prefix: attributePrefix,\n      complete: function complete() {\n        _this2._renderer.updateSize(layoutedItems);\n\n        callback({\n          remove: removeTarget,\n          layout: true\n        });\n      }\n    });\n  };\n\n  _proto._insert = function _insert(_ref, _ref2) {\n    var _this3 = this;\n\n    var groups = _ref.groups,\n        _ref$items = _ref.items,\n        items = _ref$items === void 0 ? _ItemManager[\"default\"].pluck(groups, \"items\") : _ref$items,\n        isAppend = _ref.isAppend,\n        isUpdate = _ref.isUpdate;\n\n    var _ref2$error = _ref2.error,\n        _error2 = _ref2$error === void 0 ? function () {} : _ref2$error,\n        _ref2$complete = _ref2.complete,\n        _complete2 = _ref2$complete === void 0 ? function () {} : _ref2$complete,\n        _ref2$end = _ref2.end,\n        _end2 = _ref2$end === void 0 ? function () {} : _ref2$end;\n\n    if (!groups.length) {\n      return;\n    }\n\n    var checkGroups = isAppend ? groups : groups.reverse();\n    var replaceTarget = [];\n    var removeTarget = [];\n    var elements = items.map(function (item) {\n      return item.el;\n    });\n    var type = this.options.isEqualSize && this._renderer._size.item ? _ImageLoaded.CHECK_ONLY_ERROR : _ImageLoaded.CHECK_ALL;\n    var prefix = this.options.attributePrefix;\n\n    _ImageLoaded[\"default\"].check(elements, {\n      prefix: prefix,\n      type: type,\n      complete: function complete() {\n        if (!_this3._items) {\n          return;\n        }\n\n        _this3._complete(checkGroups, items, isAppend, isUpdate, _complete2);\n      },\n      error: function error(_ref3) {\n        var target = _ref3.target,\n            itemIndex = _ref3.itemIndex;\n\n        if (!_this3._items) {\n          return;\n        }\n\n        _this3._error(removeTarget, replaceTarget, target, items, itemIndex, _error2);\n      },\n      end: function end() {\n        if (!_this3._items) {\n          return;\n        }\n\n        _this3._end(removeTarget, replaceTarget, items, _end2);\n      }\n    });\n  };\n\n  _proto.append = function append(_ref4, callbacks) {\n    var groups = _ref4.groups,\n        items = _ref4.items,\n        isUpdate = _ref4.isUpdate;\n\n    if (callbacks === void 0) {\n      callbacks = {};\n    }\n\n    this._insert({\n      groups: groups,\n      items: items,\n      isUpdate: isUpdate,\n      isAppend: true\n    }, callbacks);\n  };\n\n  _proto.prepend = function prepend(_ref5, callbacks) {\n    var groups = _ref5.groups,\n        items = _ref5.items,\n        isUpdate = _ref5.isUpdate;\n\n    if (callbacks === void 0) {\n      callbacks = {};\n    }\n\n    this._insert({\n      groups: groups,\n      items: items,\n      isUpdate: isUpdate,\n      isAppend: false\n    }, callbacks);\n  };\n\n  _proto.layout = function layout(isRelayout, groups, items) {\n    var renderer = this._renderer;\n    var _renderer$options = renderer.options,\n        isEqualSize = _renderer$options.isEqualSize,\n        isConstantSize = _renderer$options.isConstantSize;\n    var layoutGroups = groups.filter(function (group) {\n      var item = group.items[0];\n      return item.orgSize && item.rect.top > _consts.DUMMY_POSITION / 10;\n    });\n\n    if (!layoutGroups.length) {\n      return [];\n    }\n\n    var outline = layoutGroups[0].outlines.start;\n\n    if (isRelayout) {\n      outline = [outline.length ? Math.min.apply(Math, outline) : 0];\n\n      if (!isConstantSize && items.length) {\n        renderer.updateSize(items); // update invisible items' size\n\n        if (isEqualSize && items[0].size) {\n          _ItemManager[\"default\"].pluck(layoutGroups, \"items\").forEach(function (item) {\n            item.size = _extends({}, items[0].size);\n          });\n        }\n      }\n    }\n\n    this._layout.layout(layoutGroups, outline);\n\n    return layoutGroups;\n  };\n\n  _proto.destroy = function destroy() {\n    this._items = null;\n    this._renderer = null;\n  };\n\n  return LayoutMananger;\n}();\n\nexports[\"default\"] = LayoutMananger;\nmodule.exports = exports[\"default\"];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/LayoutManager.js\n// module id = 8\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = exports.CHECK_ONLY_ERROR = exports.CHECK_ALL = void 0;\n\nvar _consts = require(\"./consts\");\n\nvar _utils = require(\"./utils\");\n\nvar _AutoSizer = _interopRequireDefault(require(\"./AutoSizer\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar CHECK_ALL = 1;\nexports.CHECK_ALL = CHECK_ALL;\nvar CHECK_ONLY_ERROR = 2;\nexports.CHECK_ONLY_ERROR = CHECK_ONLY_ERROR;\n\nfunction isDataAttribute(target, prefix) {\n  return !!target.getAttribute(prefix + \"width\");\n}\n\nvar ImageLoaded =\n/*#__PURE__*/\nfunction () {\n  function ImageLoaded() {}\n\n  ImageLoaded.waitImageLoaded = function waitImageLoaded(needCheck, _ref) {\n    var _ref$prefix = _ref.prefix,\n        prefix = _ref$prefix === void 0 ? \"\" : _ref$prefix,\n        length = _ref.length,\n        type = _ref.type,\n        complete = _ref.complete,\n        error = _ref.error,\n        end = _ref.end;\n    var checkCount = 0;\n    var endCount = length;\n\n    if (type !== CHECK_ONLY_ERROR) {\n      checkCount = endCount;\n    }\n\n    var checkEnd = function checkEnd() {\n      if (--endCount !== 0) {\n        return;\n      }\n\n      end && end();\n    };\n\n    var checkImage = function checkImage() {\n      checkCount--;\n\n      if (checkCount !== 0) {\n        return;\n      }\n\n      complete && complete();\n    };\n\n    var onError = function onError(target, itemIndex) {\n      if (itemIndex === void 0) {\n        itemIndex = target.__ITEM_INDEX__;\n      }\n\n      error && error({\n        target: target,\n        itemIndex: itemIndex\n      });\n    };\n\n    var onCheck = function onCheck(e) {\n      var target = e.target || e.srcElement;\n      (0, _utils.removeEvent)(target, \"error\", onCheck);\n      (0, _utils.removeEvent)(target, \"load\", onCheck);\n\n      if (type === CHECK_ALL && isDataAttribute(target, prefix)) {\n        _AutoSizer[\"default\"].remove(target, e.type === \"error\");\n      } else {\n        checkImage();\n      }\n\n      if (e.type === \"error\") {\n        onError(target);\n      }\n\n      delete target.__ITEM_INDEX__;\n      checkEnd();\n    };\n\n    needCheck.forEach(function (images, i) {\n      images.forEach(function (v) {\n        // workaround for IE\n        if (v.complete && (!_consts.IS_IE || _consts.IS_IE && v.naturalWidth)) {\n          if (!v.naturalWidth) {\n            onError(v, i);\n          }\n\n          checkImage();\n          checkEnd();\n          return;\n        }\n\n        v.__ITEM_INDEX__ = i;\n\n        if (type === CHECK_ALL && isDataAttribute(v, prefix)) {\n          _AutoSizer[\"default\"].add(v, prefix);\n\n          checkImage();\n        }\n\n        (0, _utils.addEvent)(v, \"load\", onCheck);\n        (0, _utils.addEvent)(v, \"error\", onCheck);\n        _consts.IS_IE && v.setAttribute(\"src\", v.getAttribute(\"src\"));\n      });\n    });\n  };\n\n  ImageLoaded.checkImageLoaded = function checkImageLoaded(el) {\n    if (el.tagName === \"IMG\") {\n      return el.complete ? [] : [el];\n    } else {\n      return (0, _utils.toArray)(el.querySelectorAll(\"img\"));\n    }\n  };\n\n  ImageLoaded.check = function check(elements, _ref2) {\n    var _this = this;\n\n    var prefix = _ref2.prefix,\n        _ref2$type = _ref2.type,\n        type = _ref2$type === void 0 ? CHECK_ALL : _ref2$type,\n        complete = _ref2.complete,\n        error = _ref2.error,\n        end = _ref2.end;\n    var images = elements.map(function (element) {\n      return _this.checkImageLoaded(element);\n    });\n    var length = images.reduce(function (sum, element) {\n      return sum + element.length;\n    }, 0);\n\n    if (type === CHECK_ONLY_ERROR || length === 0) {\n      // convert to async\n      setTimeout(function () {\n        complete && complete();\n\n        if (length === 0) {\n          end && end();\n        }\n      }, 0);\n    }\n\n    if (length > 0) {\n      setTimeout(function () {\n        _this.waitImageLoaded(images, {\n          prefix: prefix,\n          length: length,\n          type: type,\n          complete: complete,\n          error: error,\n          end: end\n        });\n      }, 0);\n    }\n  };\n\n  return ImageLoaded;\n}();\n\nvar _default = ImageLoaded;\nexports[\"default\"] = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ImageLoaded.js\n// module id = 9\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _consts = require(\"../consts\");\n\nvar _utils = require(\"../utils\");\n\n/*\nFrame\n[\n[1, 1, 1, 1, 1],\n[0, 0, 2, 2, 2],\n[0, 0, 2, 2, 2],\n[3, 4, 5, 5, 5],\n]\n*/\nfunction disableFrame(frame, type, x, y, width, height) {\n  for (var i = y; i < y + height; ++i) {\n    for (var j = x; j < x + width; ++j) {\n      if (type !== frame[i][j]) {\n        continue;\n      }\n\n      frame[i][j] = 0;\n    }\n  }\n}\n\nfunction searchShapeInFrame(frame, type, top, left, width, height) {\n  var size = {\n    left: left,\n    top: top,\n    type: type,\n    width: 1,\n    height: 1\n  };\n\n  for (var i = left; i < width; ++i) {\n    if (frame[top][i] === type) {\n      size.width = i - left + 1;\n      continue;\n    }\n\n    break;\n  }\n\n  for (var _i = top; _i < height; ++_i) {\n    if (frame[_i][left] === type) {\n      size.height = _i - top + 1;\n      continue;\n    }\n\n    break;\n  } // After finding the shape, it will not find again.\n\n\n  disableFrame(frame, type, left, top, size.width, size.height);\n  return size;\n}\n\nfunction getShapes(frame) {\n  var height = frame.length;\n  var width = height ? frame[0].length : 0;\n  var shapes = [];\n\n  for (var i = 0; i < height; ++i) {\n    for (var j = 0; j < width; ++j) {\n      var type = frame[i][j];\n\n      if (!type) {\n        continue;\n      } // Separate shapes with other numbers.\n\n\n      shapes.push(searchShapeInFrame(frame, type, i, j, width, height));\n    }\n  }\n\n  shapes.sort(function (a, b) {\n    return a.type < b.type ? -1 : 1;\n  });\n  return {\n    shapes: shapes,\n    width: width,\n    height: height\n  };\n}\n/**\n * @classdesc FrameLayout is a layout that allows you to place cards in a given frame. It is a layout that corresponds to a level intermediate between the placement of the image directly by the designer and the layout using the algorithm.\n * @ko FrameLayout      .             .\n * @class eg.InfiniteGrid.FrameLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.FrameLayout module <ko>eg.InfiniteGrid.FrameLayout   </ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>  </ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>   (false: , true: )</ko>\n * @param {Boolean} [options.itemSize=0] The size of the items. If it is 0, it is calculated as the size of the first item in items. <ko>  .    0,      . </ko>\n * @param {Boolean} [options.frame=[]] The size of the items. If it is 0, it is calculated as the size of the first item in items. <ko>  .    0,      . </ko>\n * @param {Boolean} [options.frameFill=true] Make sure that the frame can be attached after the previous frame. <ko>          . </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid(\"#grid\". {\n\thorizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.FrameLayout, {\n\tmargin: 10,\n\titemSize: 200,\n\tframe: [\n\t\t[1, 1, 1, 1, 1],\n\t\t[0, 0, 2, 2, 2],\n\t\t[0, 0, 2, 2, 2],\n\t\t[3, 4, 5, 5, 5],\n\t],\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.FrameLayout({\n\tmargin: 10,\n\titemSize: 200,\n\thorizontal: true,\n\tframe: [\n\t\t[1, 1, 1, 1, 1],\n\t\t[0, 0, 2, 2, 2],\n\t\t[0, 0, 2, 2, 2],\n\t\t[3, 4, 5, 5, 5],\n\t],\n});\n\n</script>\n```\n **/\n\n\nvar FrameLayout =\n/*#__PURE__*/\nfunction () {\n  function FrameLayout(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.options = (0, _utils.assignOptions)({\n      margin: 0,\n      horizontal: false,\n      itemSize: 0,\n      frame: [],\n      frameFill: true\n    }, options);\n    var frame = this.options.frame.map(function (row) {\n      return row.slice();\n    });\n    this._itemSize = this.options.itemSize || 0; // divide frame into shapes.\n\n    this._shapes = getShapes(frame);\n    this._size = 0;\n    this._style = (0, _utils.getStyleNames)(this.options.horizontal);\n  }\n\n  var _proto = FrameLayout.prototype;\n\n  _proto._getItemSize = function _getItemSize() {\n    this._checkItemSize();\n\n    return this._itemSize;\n  };\n\n  _proto._checkItemSize = function _checkItemSize() {\n    if (this.options.itemSize) {\n      this._itemSize = this.options.itemSize;\n      return;\n    }\n\n    var style = this._style;\n    var size = style.size2;\n    var margin = this.options.margin; // if itemSize is not in options, caculate itemSize from size.\n\n    this._itemSize = (this._size + margin) / this._shapes[size] - margin;\n  };\n\n  _proto._layout = function _layout(items, outline, isAppend) {\n    if (outline === void 0) {\n      outline = [];\n    }\n\n    var length = items.length;\n    var style = this._style;\n    var _this$options = this.options,\n        margin = _this$options.margin,\n        frameFill = _this$options.frameFill;\n    var size1Name = style.size1;\n    var size2Name = style.size2;\n    var pos1Name = style.pos1;\n    var pos2Name = style.pos2;\n\n    var itemSize = this._getItemSize();\n\n    var isItemObject = typeof itemSize === \"object\";\n    var itemSize2 = isItemObject ? itemSize[size2Name] : itemSize;\n    var itemSize1 = isItemObject ? itemSize[size1Name] : itemSize;\n    var shapesSize = this._shapes[size2Name];\n    var shapes = this._shapes.shapes;\n    var shapesLength = shapes.length;\n    var startOutline = (0, _utils.fill)(new Array(shapesSize), _consts.DUMMY_POSITION);\n    var endOutline = (0, _utils.fill)(new Array(shapesSize), _consts.DUMMY_POSITION);\n    var dist = 0;\n    var end = 0;\n\n    if (!shapesLength) {\n      return {\n        start: outline,\n        end: outline\n      };\n    }\n\n    for (var i = 0; i < length; i += shapesLength) {\n      for (var j = 0; j < shapesLength && i + j < length; ++j) {\n        var _item$rect;\n\n        var item = items[i + j];\n        var shape = shapes[j];\n        var shapePos1 = shape[pos1Name];\n        var shapePos2 = shape[pos2Name];\n        var shapeSize1 = shape[size1Name];\n        var shapeSize2 = shape[size2Name];\n        var pos1 = end - dist + shapePos1 * (itemSize1 + margin);\n        var pos2 = shapePos2 * (itemSize2 + margin);\n        var size1 = shapeSize1 * (itemSize1 + margin) - margin;\n        var size2 = shapeSize2 * (itemSize2 + margin) - margin;\n\n        for (var k = shapePos2; k < shapePos2 + shapeSize2 && k < shapesSize; ++k) {\n          if (startOutline[k] === _consts.DUMMY_POSITION) {\n            startOutline[k] = pos1;\n          }\n\n          startOutline[k] = Math.min(startOutline[k], pos1);\n          endOutline[k] = Math.max(endOutline[k], pos1 + size1 + margin);\n        }\n\n        item.rect = (_item$rect = {}, _item$rect[pos1Name] = pos1, _item$rect[pos2Name] = pos2, _item$rect[size1Name] = size1, _item$rect[size2Name] = size2, _item$rect);\n      }\n\n      end = Math.max.apply(Math, endOutline); // check dist once\n\n      if (i !== 0) {\n        continue;\n      } // find & fill empty block\n\n\n      if (!frameFill) {\n        dist = 0;\n        continue;\n      }\n\n      dist = end;\n\n      for (var _j = 0; _j < shapesSize; ++_j) {\n        if (startOutline[_j] === _consts.DUMMY_POSITION) {\n          continue;\n        } // the dist between frame's end outline and next frame's start outline\n        // expect that next frame's start outline is startOutline[j] + end\n\n\n        dist = Math.min(startOutline[_j] + end - endOutline[_j], dist);\n      }\n    }\n\n    for (var _i2 = 0; _i2 < shapesSize; ++_i2) {\n      if (startOutline[_i2] !== _consts.DUMMY_POSITION) {\n        continue;\n      }\n\n      startOutline[_i2] = Math.max.apply(Math, startOutline);\n      endOutline[_i2] = startOutline[_i2];\n    } // The target outline is start outline when type is APPENDING\n\n\n    var targetOutline = isAppend ? startOutline : endOutline;\n    var prevOutlineEnd = outline.length === 0 ? 0 : Math[isAppend ? \"max\" : \"min\"].apply(Math, outline);\n    var prevOutlineDist = isAppend ? 0 : end;\n\n    if (frameFill && outline.length === shapesSize) {\n      prevOutlineDist = -_consts.DUMMY_POSITION;\n\n      for (var _i3 = 0; _i3 < shapesSize; ++_i3) {\n        if (startOutline[_i3] === endOutline[_i3]) {\n          continue;\n        } // if appending type is PREPEND, subtract dist from appending group's height.\n\n\n        prevOutlineDist = Math.min(targetOutline[_i3] + prevOutlineEnd - outline[_i3], prevOutlineDist);\n      }\n    }\n\n    for (var _i4 = 0; _i4 < shapesSize; ++_i4) {\n      startOutline[_i4] += prevOutlineEnd - prevOutlineDist;\n      endOutline[_i4] += prevOutlineEnd - prevOutlineDist;\n    }\n\n    items.forEach(function (item) {\n      item.rect[pos1Name] += prevOutlineEnd - prevOutlineDist;\n    });\n    return {\n      start: startOutline.map(function (point) {\n        return parseInt(point, 10);\n      }),\n      end: endOutline.map(function (point) {\n        return parseInt(point, 10);\n      })\n    };\n  };\n\n  _proto._insert = function _insert(items, outline, type, cache) {\n    if (items === void 0) {\n      items = [];\n    }\n\n    if (outline === void 0) {\n      outline = [];\n    }\n\n    // this only needs the size of the item.\n    var clone = cache ? items : (0, _utils.cloneItems)(items);\n    return {\n      items: clone,\n      outlines: this._layout(clone, outline, type)\n    };\n  };\n  /**\n   * Adds items of groups at the bottom of a outline.\n   * @ko     .\n   * @method eg.InfiniteGrid.FrameLayout#layout\n   * @param {Array} groups Array of groups to be layouted <ko>  </ko>\n   * @param {Array} outline Array of outline points to be reference points <ko>    </ko>\n   * @return {eg.InfiniteGrid.FrameLayout} An instance of a module itself<ko>  </ko>\n   * @example\n   * layout.layout(groups, [100, 200, 300, 400]);\n   */\n\n\n  _proto.layout = function layout(groups, outline) {\n    if (groups === void 0) {\n      groups = [];\n    }\n\n    if (outline === void 0) {\n      outline = [];\n    }\n\n    var length = groups.length;\n    var point = outline;\n\n    for (var i = 0; i < length; ++i) {\n      var group = groups[i];\n      point = this._layout(group.items, point, _consts.APPEND);\n      group.outlines = point;\n      point = point.end;\n    }\n\n    return this;\n  };\n  /**\n   * Set the viewport size of the layout.\n   * @ko    .\n   * @method eg.InfiniteGrid.FrameLayout#setSize\n   * @param {Number} size The viewport size of container area where items are added to a layout <ko>      </ko>\n   * @return {eg.InfiniteGrid.FrameLayout} An instance of a module itself<ko>  </ko>\n   * @example\n   * layout.setSize(800);\n   */\n\n\n  _proto.setSize = function setSize(size) {\n    this._size = size;\n    return this;\n  };\n  /**\n   * Adds items at the bottom of a outline.\n   * @ko    .\n   * @method eg.InfiniteGrid.FrameLayout#append\n   * @param {Array} items Array of items to be layouted <ko>  </ko>\n   * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n   * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n   * @example\n   * layout.prepend(items, [100]);\n   */\n\n\n  _proto.append = function append(items, outline, cache) {\n    return this._insert(items, outline, _consts.APPEND, cache);\n  };\n  /**\n   * Adds items at the top of a outline.\n   * @ko    .\n   * @method eg.InfiniteGrid.FrameLayout#prepend\n   * @param {Array} items Array of items to be layouted <ko>  </ko>\n   * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n   * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n   * @example\n   * layout.prepend(items, [100]);\n   */\n\n\n  _proto.prepend = function prepend(items, outline, cache) {\n    return this._insert(items, outline, _consts.PREPEND, cache);\n  };\n\n  return FrameLayout;\n}();\n\nvar _default = FrameLayout;\nexports[\"default\"] = _default;\nmodule.exports = exports[\"default\"];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/layouts/FrameLayout.js\n// module id = 10\n// module chunks = 0 1","\"use strict\";\n\nvar modules = _interopRequireWildcard(require(\"./index\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj[\"default\"] = obj; return newObj; } }\n\n/**\n * Copyright (c) NAVER Corp.\n * egjs-infinitegrid projects are licensed under the MIT license\n */\nfor (var name in modules) {\n  modules[\"default\"][name] = modules[name];\n}\n\nmodule.exports = modules[\"default\"];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.umd.js\n// module id = 11\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\nexports.VERSION = void 0;\n\nvar _InfiniteGrid = _interopRequireDefault(require(\"./InfiniteGrid\"));\n\nexports[\"default\"] = _InfiniteGrid[\"default\"];\n\nvar _GridLayout = _interopRequireDefault(require(\"./layouts/GridLayout\"));\n\nexports.GridLayout = _GridLayout[\"default\"];\n\nvar _FrameLayout = _interopRequireDefault(require(\"./layouts/FrameLayout\"));\n\nexports.FrameLayout = _FrameLayout[\"default\"];\n\nvar _SquareLayout = _interopRequireDefault(require(\"./layouts/SquareLayout\"));\n\nexports.SquareLayout = _SquareLayout[\"default\"];\n\nvar _PackingLayout = _interopRequireDefault(require(\"./layouts/PackingLayout\"));\n\nexports.PackingLayout = _PackingLayout[\"default\"];\n\nvar _JustifiedLayout = _interopRequireDefault(require(\"./layouts/JustifiedLayout\"));\n\nexports.JustifiedLayout = _JustifiedLayout[\"default\"];\n\nvar _ImageLoaded = _interopRequireDefault(require(\"./ImageLoaded\"));\n\nexports.ImageLoaded = _ImageLoaded[\"default\"];\n\nvar _AutoSizer = _interopRequireDefault(require(\"./AutoSizer\"));\n\nexports.AutoSizer = _AutoSizer[\"default\"];\n\nvar _DOMRenderer = _interopRequireDefault(require(\"./DOMRenderer\"));\n\nexports.DOMRenderer = _DOMRenderer[\"default\"];\n\nvar _Watcher = _interopRequireDefault(require(\"./Watcher\"));\n\nexports.Watcher = _Watcher[\"default\"];\n\nvar _ItemManager = _interopRequireDefault(require(\"./ItemManager\"));\n\nexports.ItemManager = _ItemManager[\"default\"];\n\nvar _Infinite = _interopRequireDefault(require(\"./Infinite\"));\n\nexports.Infinite = _Infinite[\"default\"];\n\nvar _LayoutManager = _interopRequireDefault(require(\"./LayoutManager\"));\n\nexports.LayoutManager = _LayoutManager[\"default\"];\n\nvar _version = _interopRequireDefault(require(\"./version\"));\n\nexports.VERSION = _version[\"default\"];\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.js\n// module id = 12\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _component = _interopRequireDefault(require(\"@egjs/component\"));\n\nvar _ItemManager = _interopRequireDefault(require(\"./ItemManager\"));\n\nvar _DOMRenderer = _interopRequireDefault(require(\"./DOMRenderer\"));\n\nvar _Watcher = _interopRequireDefault(require(\"./Watcher\"));\n\nvar _consts = require(\"./consts\");\n\nvar _Infinite = _interopRequireDefault(require(\"./Infinite\"));\n\nvar _utils = require(\"./utils\");\n\nvar _LayoutManager = _interopRequireDefault(require(\"./LayoutManager\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n// IE8\n// https://stackoverflow.com/questions/43216659/babel-ie8-inherit-issue-with-object-create\n\n/* eslint-disable */\nif (typeof Object.create !== \"function\") {\n  Object.create = function (o, properties) {\n    if (typeof o !== \"object\" && typeof o !== \"function\") {\n      throw new TypeError(\"Object prototype may only be an Object: \" + o);\n    } else if (o === null) {\n      throw new Error(\"This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument.\");\n    }\n\n    function F() {}\n\n    F.prototype = o;\n    return new F();\n  };\n}\n/* eslint-enable */\n\n/**\n * A module used to arrange card elements including content infinitely according to layout type. With this module, you can implement various layouts composed of different card elements whose sizes vary. It guarantees performance by maintaining the number of DOMs the module is handling under any circumstance\n * @ko          .         .        DOM      \n * @alias eg.InfiniteGrid\n * @extends eg.Component\n *\n * @example\n```\n<ul id=\"grid\">\n\t<li class=\"card\">\n\t\t<div>test1</div>\n\t</li>\n\t<li class=\"card\">\n\t\t<div>test2</div>\n\t</li>\n\t<li class=\"card\">\n\t\t<div>test3</div>\n\t</li>\n\t<li class=\"card\">\n\t\t<div>test4</div>\n\t</li>\n\t<li class=\"card\">\n\t\t<div>test5</div>\n\t</li>\n\t<li class=\"card\">\n\t\t<div>test6</div>\n\t</li>\n</ul>\n<script>\nvar some = new eg.InfiniteGrid(\"#grid\").on(\"layoutComplete\", function(e) {\n\t// ...\n});\n\n// If you already have items in the container, call \"layout\" method.\nsome.layout();\n</script>\n```\n *\n * @support {\"ie\": \"8+\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\", \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"2.1+ (except 3.x)\"}\n **/\n\n\nvar InfiniteGrid =\n/*#__PURE__*/\nfunction (_Component) {\n  _inheritsLoose(InfiniteGrid, _Component);\n\n  /**\n   * @param {HTMLElement|String|jQuery} element A base element for a module <ko>   </ko>\n   * @param {Object} [options] The option object of the eg.InfiniteGrid module <ko>eg.InfiniteGrid   </ko>\n   * @param {String} [options.itemSelector] A selector to select card elements that make up the layout<ko>     (selector)</ko>\n   * @param {Boolean} [options.useRecycle=true] Indicates whether keep the number of DOMs is maintained. If the useRecycle value is 'true', keep the number of DOMs is maintained. If the useRecycle value is 'false', the number of DOMs will increase as card elements are added. <ko>DOM    . useRecycle  'true' DOM   . useRecycle  'false'     DOM   .</ko>\n   * @param {Boolean} [options.isOverflowScroll=false] Indicates whether overflow:scroll is applied<ko>overflow:scroll  .</ko>\n   * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (true: horizontal, false: vertical) <ko>   (true , false )</ko>\n   * @param {Boolean} [options.useFit=true] The useFit option scrolls upwards so that no space is visible until an item is added <ko>          .</ko>\n   * @param {Boolean} [options.isEqualSize=false] Indicates whether sizes of all card elements are equal to one another. If sizes of card elements to be arranged are all equal and this option is set to \"true\", the performance of layout arrangement can be improved. <ko>    .          'true'       </ko>\n   * @param {Boolean} [options.isConstantSize=false] Indicates whether sizes of all card elements does not change, the performance of layout arrangement can be improved. <ko>        'true'       </ko>\n   * @param {Number} [options.transitionDruation=0] Indicates how many seconds a transition effect takes to complete. <ko>     .</ko>\n   * @param {Number} [options.threshold=100] The threshold size of an event area where card elements are added to a layout.<ko>        .</ko>\n   * @param {String} [options.attributePrefix=\"data-\"] The prefix to use element's data attribute.<ko>    .</ko>\n   */\n  function InfiniteGrid(element, options) {\n    var _this;\n\n    _this = _Component.call(this) || this;\n\n    _extends(_this.options = {\n      itemSelector: \"*\",\n      isOverflowScroll: false,\n      threshold: 100,\n      isEqualSize: false,\n      isConstantSize: false,\n      useRecycle: true,\n      horizontal: false,\n      transitionDuration: 0,\n      useFit: true,\n      attributePrefix: \"data-\"\n    }, options);\n\n    _consts.DEFENSE_BROWSER && (_this.options.useFit = false);\n    _consts.IS_ANDROID2 && (_this.options.isOverflowScroll = false);\n\n    _this._reset();\n\n    _this._loadingBar = {};\n    var _this$options = _this.options,\n        isOverflowScroll = _this$options.isOverflowScroll,\n        isEqualSize = _this$options.isEqualSize,\n        isConstantSize = _this$options.isConstantSize,\n        horizontal = _this$options.horizontal,\n        threshold = _this$options.threshold,\n        useRecycle = _this$options.useRecycle;\n    _this._items = new _ItemManager[\"default\"]();\n    _this._renderer = new _DOMRenderer[\"default\"](element, {\n      isEqualSize: isEqualSize,\n      isConstantSize: isConstantSize,\n      horizontal: horizontal,\n      container: isOverflowScroll\n    });\n    _this._watcher = new _Watcher[\"default\"](_this._renderer.view, {\n      isOverflowScroll: isOverflowScroll,\n      horizontal: horizontal,\n      container: _this._renderer.container,\n      resize: function resize() {\n        return _this._onResize();\n      },\n      check: function check(param) {\n        return _this._onCheck(param);\n      }\n    });\n    _this._infinite = new _Infinite[\"default\"](_this._items, {\n      horizontal: horizontal,\n      useRecycle: useRecycle,\n      threshold: threshold,\n      append: function append(param) {\n        return _this._requestAppend(param);\n      },\n      prepend: function prepend(param) {\n        return _this._requestPrepend(param);\n      },\n      recycle: function recycle(param) {\n        return _this._recycle(param);\n      }\n    });\n    return _this;\n  }\n  /**\n   * Adds a card element at the bottom of a layout. This method is available only if the isProcessing() method returns false.\n   * @ko     . isProcessing()   'false'      \n   *   isProcessing()  false   .\n   * @param {Array|jQuery} elements Array of the card elements to be added <ko>   </ko>\n   * @param {Number|String} [groupKey] The group key to be configured in a card element. It is automatically generated by default.\n   * <ko>     .    .</ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n   * @example\n   * infinitegrid.append(\"&lt;div class='item'&gt;test1&lt;/div&gt;&lt;div class='item'&gt;test2&lt;/div&gt;\");\n   * infinitegrid.append([\"&lt;div class='item'&gt;test1&lt;/div&gt;\", \"&lt;div class='item'&gt;test2&lt;/div&gt;\"]);\n   * infinitegrid.append([HTMLElement1, HTMLElement2]);\n   * infinitegrid.append(jQuery([\"&lt;div class='item'&gt;test1&lt;/div&gt;\", \"&lt;div class='item'&gt;test2&lt;/div&gt;\"]));\n   */\n\n\n  var _proto = InfiniteGrid.prototype;\n\n  _proto.append = function append(elements, groupKey) {\n    this._manager && this._insert(elements, _consts.APPEND, groupKey);\n    return this;\n  };\n  /**\n   * Adds a card element at the top of a layout. This method is available only if the isProcessing() method returns false.\n   * @ko     . isProcessing()   'false'      \n   * @param {Array|jQuery} elements Array of the card elements to be added <ko>   </ko>\n   * @param {Number|String} [groupKey] The group key to be configured in a card element. It is automatically generated by default.\n   * <ko>     .    .</ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n   * @example\n   * infinitegrid.prepend(\"&lt;div class='item'&gt;test1&lt;/div&gt;&lt;div class='item'&gt;test2&lt;/div&gt;\");\n   * infinitegrid.prepend([\"&lt;div class='item'&gt;test1&lt;/div&gt;\", \"&lt;div class='item'&gt;test2&lt;/div&gt;\"]);\n   * infinitegrid.prepend([HTMLElement1, HTMLElement2]);\n   * infinitegrid.prepend(jQuery([\"&lt;div class='item'&gt;test1&lt;/div&gt;\", \"&lt;div class='item'&gt;test2&lt;/div&gt;\"]));\n   */\n\n\n  _proto.prepend = function prepend(elements, groupKey) {\n    this._manager && this._insert(elements, _consts.PREPEND, groupKey);\n    return this;\n  };\n  /**\n   * Specifies the Layout class to use.\n   * @ko  Layout  .\n   * @param {Class|Object} LayoutKlass The Layout class to use or an instance of a layout moudle<ko> Layout     </ko>\n   * @param {Object} options Options to apply to the Layout.<ko>Layout  </ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n   * @example\n   * infinitegrid.setLayout(eg.InfiniteGrid.GridLayout, {\n   *  margin: 10,\n   *  align: \"start\"\n   * });\n    * infinitegrid.setLayout(eg.InfiniteGrid.JustifiedLayout, {\n   *  margin: 10,\n   *  minSize: 100,\n   *  maxSize: 200\n   * });\n    * infinitegrid.setLayout(eg.InfiniteGrid.SquareLayout, {\n   *  margin: 10,\n   *  column: 2\n   * });\n   * infinitegrid.setLayout(eg.InfiniteGrid.FrameLayout, {\n   *  margin: 10,\n   *  frame: [\n   *   [1, 2],\n    *   [4, 3],\n   *  ]\n   * });\n   * infinitegrid.setLayout(eg.InfiniteGrid.PackingLayout, {\n   *  margin: 10,\n   *  aspectRatio: 1.5\n   * });\n   * var layout = new eg.InfiniteGrid.GridLayout({\n   * \tmargin: 10,\n   *\talign: \"start\"\n   * });\n   * infinitegrid.setLayout(layout);\n   */\n\n\n  _proto.setLayout = function setLayout(LayoutKlass, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _this$options2 = this.options,\n        isEqualSize = _this$options2.isEqualSize,\n        isConstantSize = _this$options2.isConstantSize,\n        attributePrefix = _this$options2.attributePrefix,\n        horizontal = _this$options2.horizontal;\n\n    if (!this._manager) {\n      this._manager = new _LayoutManager[\"default\"](this._items, this._renderer, {\n        attributePrefix: attributePrefix,\n        isEqualSize: isEqualSize,\n        isConstantSize: isConstantSize\n      });\n    }\n\n    if (typeof LayoutKlass === \"function\") {\n      this._manager.setLayout(new LayoutKlass(_extends(options, {\n        horizontal: horizontal\n      })));\n    } else {\n      LayoutKlass.options.horizontal = horizontal;\n\n      this._manager.setLayout(LayoutKlass);\n    }\n\n    this._renderer.resize();\n\n    this._setSize(this._renderer.getViewportSize());\n\n    return this;\n  };\n\n  _proto._setSize = function _setSize(size) {\n    this._infinite.setSize(this._renderer.getViewSize());\n\n    this._manager.setSize(size);\n  };\n  /**\n   * Returns the layouted items.\n   * @ko   .\n   * @param {Boolean} includeCached Indicates whether to include the cached items. <ko>    .</ko>\n   * @returns {Array} List of items <ko> </ko>\n   */\n\n\n  _proto.getItems = function getItems(includeCached) {\n    if (includeCached === void 0) {\n      includeCached = false;\n    }\n\n    return includeCached ? this._items.pluck(\"items\") : this._infinite.getVisibleItems();\n  };\n\n  _proto._fitItems = function _fitItems(base, margin) {\n    if (margin === void 0) {\n      margin = 0;\n    }\n\n    base > 0 && this._watcher.scrollBy(-base);\n\n    this._items.fit(base, this.options.horizontal);\n\n    _DOMRenderer[\"default\"].renderItems(this.getItems());\n\n    this._setContainerSize(this._getEdgeValue(\"end\") || margin);\n\n    base < 0 && this._watcher.scrollBy(-base);\n  }; // called by visible\n\n\n  _proto._fit = function _fit(useFit) {\n    if (useFit === void 0) {\n      useFit = this.options.useFit;\n    }\n\n    var base = this._getEdgeValue(\"start\");\n\n    var margin = this._getLoadingStatus() === _consts.LOADING_PREPEND && this._status.loadingSize || 0;\n    var _this$options3 = this.options,\n        isConstantSize = _this$options3.isConstantSize,\n        isEqualSize = _this$options3.isEqualSize,\n        useRecycle = _this$options3.useRecycle;\n\n    if (!useRecycle || !useFit || isConstantSize || isEqualSize) {\n      if (base < margin) {\n        this._fitItems(base - margin, margin);\n      }\n\n      base = 0;\n    } else if (base !== 0 || margin) {\n      this._fitItems(base - margin, margin);\n    } else {\n      return 0;\n    }\n\n    this._isLoading() && this._renderLoading();\n    return base;\n  };\n\n  _proto._getEdgeValue = function _getEdgeValue(cursor) {\n    return this._infinite.getEdgeValue(cursor);\n  };\n  /**\n   * Rearranges a layout.\n   * @ko   .\n   * @param {Boolean} [isRelayout=true] Indicates whether a card element is being relayouted <ko>   </ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n   */\n\n\n  _proto.layout = function layout(isRelayout) {\n    if (isRelayout === void 0) {\n      isRelayout = true;\n    }\n\n    if (!this._manager) {\n      return this;\n    }\n\n    var renderer = this._renderer;\n    var itemManager = this._items;\n    var infinite = this._infinite;\n    var isResize = renderer.resize();\n    var items = this.getItems();\n    var _this$options4 = this.options,\n        isEqualSize = _this$options4.isEqualSize,\n        isConstantSize = _this$options4.isConstantSize,\n        transitionDuration = _this$options4.transitionDuration;\n    var isLayoutAll = isRelayout && (isEqualSize || isConstantSize);\n    var size = itemManager.size();\n\n    if (isRelayout) {\n      this._watcher.resize();\n\n      if (isResize) {\n        this._setSize(renderer.getViewportSize());\n      }\n    } // check childElement\n\n\n    if (!size || !items.length) {\n      var children = (0, _utils.toArray)(renderer.container.children);\n\n      if (children.length) {\n        this._insert(children, true);\n      } else {\n        this._requestAppend({});\n      }\n\n      return this;\n    } // layout datas\n\n\n    var startCursor = infinite.getCursor(\"start\");\n    var endCursor = infinite.getCursor(\"end\");\n    var data = isLayoutAll || !(isRelayout && isResize) ? itemManager.get() : itemManager.get(startCursor, endCursor); // LayoutManger interface\n\n    this._manager.layout(isRelayout, data, isResize ? items : []);\n\n    if (isLayoutAll) {\n      this._fit();\n    } else if (isRelayout && isResize) {\n      itemManager.clearOutlines(startCursor, endCursor);\n    }\n\n    _DOMRenderer[\"default\"].renderItems(items, transitionDuration);\n\n    isRelayout && this._watcher.setScrollPos();\n\n    this._onLayoutComplete({\n      items: items,\n      isAppend: _consts.APPEND,\n      fromCache: _consts.CACHE,\n      isTrusted: _consts.NO_TRUSTED,\n      useRecycle: false,\n      isLayout: true\n    });\n\n    return this;\n  };\n  /**\n   * Removes a item element on a grid layout.\n   * @ko     .\n   * @param {HTMLElement} item element to be removed <ko>  </ko>\n   * @return {Object}  Removed item element <ko>   </ko>\n   */\n\n\n  _proto.remove = function remove(element, isLayout) {\n    if (isLayout === void 0) {\n      isLayout = true;\n    }\n\n    if (element) {\n      var items = this._infinite.remove(element);\n\n      items && _DOMRenderer[\"default\"].removeElement(element);\n      isLayout && this.layout(false);\n      return items;\n    }\n\n    return null;\n  };\n  /**\n   * Returns the list of group keys which belongs to card elements currently being maintained. You can use the append() or prepend() method to configure group keys so that multiple card elements can be managed at once. If you do not use these methods to configure group keys, groupkey is automatically generated.\n   * @ko         .         append()  prepend()      . append()  prepend()        .\n   * @param {Boolean} includeCached Indicates whether to include the cached groups. <ko>    .</ko>\n   * @return {Array} List of group keys <ko>  </ko>\n   */\n\n\n  _proto.getGroupKeys = function getGroupKeys(includeCached) {\n    var data = includeCached ? this._items.get() : this._infinite.getVisibleData();\n    return data.map(function (v) {\n      return v.groupKey;\n    });\n  };\n  /**\n   * Returns the current state of a module such as location information. You can use the setStatus() method to restore the information returned through a call to this method.\n   * @ko         .       setStatus()    \n   * @return {Object} State object of the eg.InfiniteGrid module<ko>eg.InfiniteGrid   </ko>\n   */\n\n\n  _proto.getStatus = function getStatus(startKey, endKey) {\n    return {\n      _status: _extends({}, this._status),\n      _items: this._items.getStatus(startKey, endKey),\n      _renderer: this._renderer.getStatus(),\n      _watcher: this._watcher.getStatus(),\n      _infinite: this._infinite.getStatus(startKey, endKey)\n    };\n  };\n  /**\n   * Sets the state of the eg.InfiniteGrid module with the information returned through a call to the getStatue() method.\n   * @ko getStatue()    eg.InfiniteGrid   .\n   * @param {Object} status State object of the eg.InfiniteGrid module <ko>eg.InfiniteGrid   </ko>\n   * @param {boolean} [applyScrollPos=true] Checks whether to scroll<ko>   .</ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n   */\n\n\n  _proto.setStatus = function setStatus(status, applyScrollPos) {\n    if (applyScrollPos === void 0) {\n      applyScrollPos = true;\n    }\n\n    if (!status) {\n      return this;\n    }\n\n    var _status = status._status,\n        _renderer = status._renderer,\n        _items = status._items,\n        _watcher = status._watcher,\n        _infinite = status._infinite;\n\n    if (!_status || !_renderer || !_items || !_watcher || !_infinite) {\n      return this;\n    }\n\n    var items = this._items;\n    var renderer = this._renderer;\n    var watcher = this._watcher;\n    var infinite = this._infinite;\n    watcher.detachEvent();\n\n    _extends(this._status, _status);\n\n    this._status.processingStatus = _consts.IDLE;\n    items.setStatus(_items);\n    renderer.setStatus(_renderer);\n    infinite.setStatus(_infinite);\n    var visibleItems = this.getItems();\n    var length = visibleItems.length;\n    renderer.createAndInsert(visibleItems, true);\n    var isReLayout = renderer.isNeededResize();\n    watcher.setStatus(_watcher, applyScrollPos);\n    watcher.attachEvent();\n    var _this$options5 = this.options,\n        isConstantSize = _this$options5.isConstantSize,\n        isEqualSize = _this$options5.isEqualSize;\n\n    if (!length) {\n      this._requestAppend({\n        cache: visibleItems.slice(0, 1)\n      });\n    } else if (isReLayout) {\n      renderer.resize();\n\n      this._setSize(renderer.getViewportSize());\n\n      if (isConstantSize) {\n        this.layout(true);\n      } else {\n        this._items.clearOutlines();\n\n        this._postLayout({\n          fromCache: true,\n          groups: isEqualSize ? items.get() : infinite.getVisibleData(),\n          items: visibleItems,\n          newItems: visibleItems,\n          isAppend: true,\n          isTrusted: false\n        });\n      }\n    } else {\n      this.layout(false);\n    }\n\n    return this;\n  };\n  /**\n   * Clears added card elements and data.\n   * @ko      .\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n   */\n\n\n  _proto.clear = function clear() {\n    this._items.clear();\n\n    this._renderer.clear();\n\n    this._infinite.clear();\n\n    this._reset();\n\n    this._appendLoadingBar();\n\n    return this;\n  };\n  /**\n   * Specifies the Loading Bar to use for append or prepend items.\n   * @ko  append  prepend      .\n   * @param {String|Object} [userLoadingBar={}] The loading bar HTML markup or element or element selector <ko>   HTML  element  selector </ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n   */\n\n\n  _proto.setLoadingBar = function setLoadingBar(userLoadingBar) {\n    if (userLoadingBar === void 0) {\n      userLoadingBar = {};\n    }\n\n    var loadingBarObj = typeof userLoadingBar === \"object\" ? userLoadingBar : {\n      \"append\": userLoadingBar,\n      \"prepend\": userLoadingBar\n    };\n    this._status.loadingSize = 0;\n    this._status.loadingStyle = {};\n    var loadingBar = this._loadingBar;\n\n    for (var type in loadingBarObj) {\n      loadingBar[type] = (0, _utils.$)(loadingBarObj[type]);\n      loadingBar[type].className += \" \" + _consts.IGNORE_CLASSNAME;\n    }\n\n    this._appendLoadingBar();\n\n    return this;\n  };\n\n  _proto._appendLoadingBar = function _appendLoadingBar() {\n    var loadingBar = this._loadingBar;\n    var container = this._renderer.container;\n\n    for (var type in loadingBar) {\n      container.appendChild(loadingBar[type]);\n    }\n  };\n  /**\n   * Checks whether a card element or data is being added.\n   * @ko         \n   * @return {Boolean} Indicates whether a card element or data is being added <ko>        </ko>\n   */\n\n\n  _proto.isProcessing = function isProcessing() {\n    return this._isProcessing() || this._isLoading();\n  };\n\n  _proto._isProcessing = function _isProcessing() {\n    return (this._status.processingStatus & _consts.PROCESSING) > 0;\n  };\n\n  _proto._isLoading = function _isLoading() {\n    return this._getLoadingStatus() > 0;\n  };\n\n  _proto._getLoadingStatus = function _getLoadingStatus() {\n    return this._status.processingStatus & (_consts.LOADING_APPEND | _consts.LOADING_PREPEND);\n  };\n\n  _proto._process = function _process(status, isAdd) {\n    if (isAdd === void 0) {\n      isAdd = true;\n    }\n\n    if (isAdd) {\n      this._status.processingStatus |= status;\n    } else {\n      this._status.processingStatus -= this._status.processingStatus & status;\n    }\n  };\n\n  _proto._insert = function _insert(elements, isAppend, groupKey) {\n    if (this._isProcessing() || elements.length === 0) {\n      return;\n    }\n\n    var key = typeof groupKey === \"undefined\" ? new Date().getTime() + Math.floor(Math.random() * 1000) : groupKey;\n\n    var items = _ItemManager[\"default\"].from(elements, this.options.itemSelector, {\n      isAppend: isAppend,\n      groupKey: key,\n      outlines: {\n        start: [],\n        end: []\n      }\n    });\n\n    if (!items.length) {\n      return;\n    }\n\n    var group = {\n      groupKey: key,\n      items: items,\n      outlines: {\n        start: [],\n        end: []\n      }\n    };\n    var method = isAppend ? \"append\" : \"prepend\";\n\n    this._items[method](group);\n\n    if (!isAppend) {\n      var infinite = this._infinite;\n      var startCursor = infinite.getCursor(\"start\");\n      var endCursor = infinite.getCursor(\"end\");\n      infinite.setCursor(\"start\", startCursor + 1);\n      infinite.setCursor(\"end\", endCursor + 1);\n    }\n\n    this._postLayout({\n      fromCache: _consts.NO_CACHE,\n      groups: [group],\n      items: items,\n      newItems: items,\n      isAppend: isAppend,\n      isTrusted: _consts.NO_TRUSTED\n    });\n  }; // add items, and remove items for recycling\n\n\n  _proto._recycle = function _recycle(_ref) {\n    var start = _ref.start,\n        end = _ref.end;\n\n    if (!this.options.useRecycle) {\n      return;\n    }\n\n    _DOMRenderer[\"default\"].removeItems(this._items.pluck(\"items\", start, end));\n  };\n  /**\n   * Returns the element of loading bar.\n   * @ko   element .\n   * @param {Boolean} [isAppend=currentLoadingBar|true] Checks whether the card element is added to the append () method. <ko>  append()     .</ko>\n   * @return {Element} The element of loading bar. <ko>  element</ko>\n   */\n\n\n  _proto.getLoadingBar = function getLoadingBar(isAppend) {\n    if (isAppend === void 0) {\n      isAppend = this._getLoadingStatus() !== _consts.LOADING_PREPEND;\n    }\n\n    return this._loadingBar[isAppend ? \"append\" : \"prepend\"];\n  };\n  /**\n   * Start loading for append/prepend during loading data.\n   * @ko    append/prepend   .\n   * @param {Boolean} [isAppend=true] Checks whether the card element is added to the append () method. <ko>  append()     .</ko>\n   * @param {Object} [userStyle = {display: \"block\"}] custom style to apply to this loading bar for start. <ko>         </ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n   */\n\n\n  _proto.startLoading = function startLoading(isAppend, userStyle) {\n    if (userStyle === void 0) {\n      userStyle = {\n        display: \"block\"\n      };\n    }\n\n    if (this._isLoading()) {\n      return this;\n    }\n\n    var type = isAppend ? \"append\" : \"prepend\";\n\n    this._process(isAppend ? _consts.LOADING_APPEND : _consts.LOADING_PREPEND);\n\n    if (!this._loadingBar[type]) {\n      return this;\n    }\n\n    this._renderLoading(userStyle);\n\n    this._status.loadingStyle = userStyle;\n\n    if (!isAppend) {\n      this._fit();\n    } else {\n      this._setContainerSize(this._getEdgeValue(\"end\") + this._status.loadingSize);\n    }\n\n    return this;\n  };\n\n  _proto._renderLoading = function _renderLoading(userStyle) {\n    if (userStyle === void 0) {\n      userStyle = this._status.loadingStyle;\n    }\n\n    if (!this._isLoading()) {\n      return;\n    }\n\n    var isAppend = this._getLoadingStatus() === _consts.LOADING_APPEND;\n\n    var el = this._loadingBar[isAppend ? \"append\" : \"prepend\"];\n\n    if (!el) {\n      return;\n    }\n\n    var style = _extends({\n      position: \"absolute\"\n    }, userStyle);\n\n    for (var property in style) {\n      el.style[property] = style[property];\n    }\n\n    this._status.loadingSize = this.options.horizontal ? (0, _utils.outerWidth)(el) : (0, _utils.outerHeight)(el);\n    var posName = this.options.horizontal ? \"left\" : \"top\";\n\n    if (!(posName in style)) {\n      var pos = isAppend ? this._getEdgeValue(\"end\") : this._getEdgeValue(\"start\") - this._status.loadingSize;\n      el.style[posName] = pos + \"px\";\n    }\n  };\n  /**\n   * End loading after startLoading() for append/prepend\n   * @ko  append/prepend  startLoading()    .\n   * @param {Object} [userStyle = {display: \"none\"}] custom style to apply to this loading bar for end <ko>         </ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n   */\n\n\n  _proto.endLoading = function endLoading(userStyle) {\n    if (userStyle === void 0) {\n      userStyle = {\n        display: \"none\"\n      };\n    }\n\n    if (!this._isLoading()) {\n      return this;\n    }\n\n    var isAppend = this._getLoadingStatus() === _consts.LOADING_APPEND;\n\n    var type = isAppend ? \"append\" : \"prepend\";\n    var el = this._loadingBar[type];\n    var status = this._status;\n    var size = status.loadingSize;\n\n    this._process(_consts.LOADING_APPEND | _consts.LOADING_PREPEND, false);\n\n    status.loadingSize = 0;\n    status.loadingStyle = {};\n\n    if (el) {\n      var _extends2;\n\n      var style = _extends((_extends2 = {}, _extends2[this.options.horizontal ? \"left\" : \"top\"] = -size + \"px\", _extends2), userStyle);\n\n      for (var property in style) {\n        el.style[property] = style[property];\n      }\n\n      if (!isAppend) {\n        this._fitItems(size);\n      } else {\n        this._setContainerSize(this._getEdgeValue(\"end\"));\n      }\n    }\n\n    if (this.options.useRecycle && !this.isProcessing()) {\n      this._infinite.recycle(this._watcher.getScrollPos(), isAppend);\n    }\n\n    return this;\n  };\n\n  _proto._setContainerSize = function _setContainerSize(size) {\n    this._renderer.setContainerSize(Math.max(this._items.getMaxEdgeValue(), size));\n  };\n  /**\n   * Move to some group or item position.\n   * @ko      .\n   * @param {Number} [index] group's index <ko>  index</ko>\n   * @param {Number} [itemIndex=-1] item's index <ko>  index</ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n   */\n\n\n  _proto.moveTo = function moveTo(index, itemIndex) {\n    if (itemIndex === void 0) {\n      itemIndex = 0;\n    }\n\n    if (this.isProcessing()) {\n      return this;\n    }\n\n    var data = this._items.getData(index);\n\n    if (!data) {\n      return this;\n    }\n\n    var infinite = this._infinite;\n    var outlines = data.outlines;\n    var items = data.items;\n    var item = items[itemIndex];\n    var isResize = outlines.start && outlines.start.length === 0;\n    var startCursor = infinite.getCursor(\"start\");\n    var endCursor = infinite.getCursor(\"end\");\n    var isInCursor = startCursor <= index && index <= endCursor;\n    var _this$options6 = this.options,\n        useRecycle = _this$options6.useRecycle,\n        horizontal = _this$options6.horizontal;\n\n    if (isInCursor || !useRecycle || !isResize) {\n      var pos = item ? item.rect[horizontal ? \"left\" : \"top\"] : Math.max.apply(Math, outlines.start);\n      var fit = Math.min.apply(Math, outlines.start);\n\n      if (fit < 0) {\n        // base < 0\n        this._fitItems(fit, 0);\n\n        pos -= fit;\n      }\n\n      var isAppend = index > startCursor;\n\n      if (isInCursor || isAppend) {\n        this._scrollTo(pos);\n\n        return this;\n      }\n\n      this._postLayout({\n        fromCache: true,\n        groups: [data],\n        items: items,\n        newItems: [],\n        isAppend: isAppend,\n        isTrusted: false,\n        moveCache: true,\n        moveItem: itemIndex\n      });\n\n      return this;\n    } else {\n      var _isAppend = index > endCursor || index < startCursor - 1;\n\n      this._postCache({\n        isAppend: _isAppend,\n        cache: [data],\n        isTrusted: false,\n        moveItem: itemIndex\n      });\n    }\n\n    return this;\n  };\n\n  _proto._setScrollPos = function _setScrollPos(pos) {\n    this._watcher.setScrollPos(this._watcher.getContainerOffset() + pos);\n  };\n\n  _proto._scrollTo = function _scrollTo(pos) {\n    this._watcher.scrollTo(this._watcher.getContainerOffset() + pos);\n  };\n\n  _proto._onImageError = function _onImageError(e) {\n    /**\n     * This event is fired when an error occurs in the image.\n     * @ko       .\n     * @event eg.InfiniteGrid#imageError\n     * @param {Object} param The object of data to be sent to an event <ko>   </ko>\n     * @param {Element} param.target Appending card's image element.<ko>    </ko>\n     * @param {Element} param.elememt The item's element with error images.<ko>     </ko>\n     * @param {Object} param.items The items being added.<ko>  </ko>\n     * @param {Object} param.item The item with error images.<ko>    </ko>\n     * @param {Number} param.itemIndex The item's index with error images.<ko>     </ko>\n     * @param {Function} param.remove In the imageError event, this method expects to remove the error image.<ko>       .</ko>\n     * @param {Function} param.removeItem In the imageError event, this method expects to remove the item with the error image.<ko>          .</ko>\n     * @param {Function} param.replace In the imageError event, this method expects to replace the error image's source or element.<ko>          .</ko>\n     * @param {Function} param.replaceItem In the imageError event, this method expects to replace the item's contents with the error image.<ko>           .</ko>\n     * @example\n    ig.on(\"imageError\", e => {\n    e.remove();\n    e.removeItem();\n    e.replace(\"http://...jpg\");\n    e.replace(imageElement);\n    e.replaceItem(\"item html\");\n    });\n     */\n    this.trigger(\"imageError\", _extends(e, {\n      element: e.item.el\n    }));\n  };\n\n  _proto._postCache = function _postCache(_ref2) {\n    var cache = _ref2.cache,\n        isAppend = _ref2.isAppend,\n        _ref2$isTrusted = _ref2.isTrusted,\n        isTrusted = _ref2$isTrusted === void 0 ? true : _ref2$isTrusted,\n        _ref2$moveItem = _ref2.moveItem,\n        moveItem = _ref2$moveItem === void 0 ? -1 : _ref2$moveItem;\n    var isConstantSize = this.options.isConstantSize;\n\n    var items = _ItemManager[\"default\"].pluck(cache, \"items\");\n\n    var fromCache = true;\n    var newItems = items.filter(function (item) {\n      if (!item.orgSize) {\n        fromCache = false;\n        return true;\n      }\n\n      return !isConstantSize && item.rect.top < _consts.DUMMY_POSITION / 10;\n    });\n\n    this._postLayout({\n      fromCache: fromCache,\n      groups: cache,\n      items: items,\n      newItems: newItems,\n      isAppend: isAppend,\n      isTrusted: isTrusted,\n      moveItem: moveItem\n    });\n  };\n\n  _proto._postLayout = function _postLayout(_ref3) {\n    var _this2 = this;\n\n    var fromCache = _ref3.fromCache,\n        groups = _ref3.groups,\n        _ref3$items = _ref3.items,\n        items = _ref3$items === void 0 ? _ItemManager[\"default\"].pluck(groups, \"items\") : _ref3$items,\n        newItems = _ref3.newItems,\n        isAppend = _ref3.isAppend,\n        isTrusted = _ref3.isTrusted,\n        moveCache = _ref3.moveCache,\n        _ref3$moveItem = _ref3.moveItem,\n        moveItem = _ref3$moveItem === void 0 ? -2 : _ref3$moveItem;\n\n    this._process(_consts.PROCESSING);\n\n    var method = isAppend ? \"append\" : \"prepend\";\n    var itemManager = this._items;\n    var horizontal = this.options.horizontal;\n\n    _DOMRenderer[\"default\"].createElements(items);\n\n    this._renderer[method](items);\n\n    this._manager[method]({\n      groups: groups,\n      items: newItems,\n      isAppend: isAppend\n    }, {\n      complete: function complete() {\n        var infinite = _this2._infinite;\n        var startCursor = Math.max(infinite.getCursor(\"start\"), 0);\n        var endCursor = Math.max(infinite.getCursor(\"end\"), 0);\n        var requestStartCursor = itemManager.indexOf(groups[0].groupKey);\n        var requestEndCursor = itemManager.indexOf(groups[groups.length - 1].groupKey);\n        var isInCursor = true;\n\n        if (requestStartCursor > endCursor + 1 || requestEndCursor < startCursor - 1) {\n          isInCursor = false;\n        }\n\n        if (isInCursor) {\n          if (isAppend) {\n            requestStartCursor = startCursor;\n            requestEndCursor = Math.max(endCursor, requestEndCursor);\n          } else {\n            requestStartCursor = Math.max(Math.min(startCursor, requestStartCursor), 0);\n            requestEndCursor = endCursor;\n          }\n        }\n\n        !isInCursor && _this2._recycle({\n          start: startCursor,\n          end: endCursor\n        });\n        infinite.setCursor(\"start\", requestStartCursor);\n        infinite.setCursor(\"end\", requestEndCursor);\n\n        if (moveItem > -1) {\n          var pos = items[moveItem].rect[horizontal ? \"left\" : \"top\"];\n\n          if (!isInCursor && !moveCache) {\n            itemManager.clearOutlines(requestStartCursor, requestEndCursor);\n          }\n\n          _this2._scrollTo(pos);\n\n          _this2._setScrollPos(pos);\n        }\n\n        _this2._onLayoutComplete({\n          groups: groups,\n          items: items,\n          isAppend: isAppend,\n          fromCache: fromCache,\n          isTrusted: isTrusted,\n          useRecycle: false\n        });\n      },\n      error: function error(e) {\n        return _this2._onImageError(e);\n      },\n      end: function end(_ref4) {\n        var remove = _ref4.remove,\n            layout = _ref4.layout;\n        remove.forEach(function (el) {\n          return _this2.remove(el, false);\n        });\n\n        if (layout) {\n          _this2.layout(false);\n        } else if (!_this2.isProcessing() && _this2.options.useRecycle) {\n          var watcher = _this2._watcher;\n          var scrollPos = watcher.getScrollPos();\n\n          _this2._infinite.recycle(scrollPos, isAppend);\n        }\n      }\n    });\n\n    return this;\n  }; // called by visible\n\n\n  _proto._requestAppend = function _requestAppend(_ref5) {\n    var _this3 = this;\n\n    var cache = _ref5.cache;\n\n    if (this._isProcessing()) {\n      return;\n    }\n\n    if (cache && cache.length) {\n      this._postCache({\n        cache: cache,\n        isAppend: _consts.APPEND\n      });\n    } else {\n      /**\n       * This event is fired when a card element must be added at the bottom or right of a layout because there is no card to be displayed on screen when a user scrolls near bottom or right.\n       * @ko          .          \n       * @event eg.InfiniteGrid#append\n       * @param {Object} param The object of data to be sent to an event <ko>   </ko>\n       * @param {String|Number} groupKey The group key of the first group visible on the screen <ko>    </ko>\n       * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>     true,  API    false .</ko>\n       * @param {Function} param.startLoading Start loading for append loading data. <ko>     . </ko>\n       * @param {Object} param.startLoading.userStyle The custom style to apply to this loading bar for start. <ko>         </ko>\n       * @param {Function} param.endLoading End loading after startLoading() for append/prepend loading data. <ko>   append/prepend startLoading()    .</ko>\n       * @param {Object} param.endLoading.userStyle The custom style to apply to this loading bar for start. <ko>         </ko>\n       */\n      this.trigger(\"append\", {\n        isTrusted: _consts.TRUSTED,\n        groupKey: this.getGroupKeys().pop() || \"\",\n        startLoading: function startLoading(userStyle) {\n          _this3.startLoading(true, userStyle);\n        },\n        endLoading: function endLoading(userStyle) {\n          _this3.endLoading(userStyle);\n        }\n      });\n    }\n  }; // called by visible\n\n\n  _proto._requestPrepend = function _requestPrepend(_ref6) {\n    var _this4 = this;\n\n    var cache = _ref6.cache;\n\n    this._fit(this.options.useFit || !cache.length);\n\n    if (this._isProcessing()) {\n      return;\n    }\n\n    if (cache && cache.length) {\n      this._postCache({\n        cache: cache,\n        isAppend: _consts.PREPEND\n      });\n    } else {\n      /**\n       * This event is fired when a card element must be added at the top or left of a layout because there is no card to be displayed on screen when a user scrolls near top or left.\n       * @ko         .          .\n       * @event eg.InfiniteGrid#prepend\n       * @param {Object} param The object of data to be sent to an event <ko>   </ko>\n       * @param {String|Number} groupKey The group key of the first group visible on the screen <ko>    </ko>\n       * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>     true,  API    false .</ko>\n       * @param {Function} param.startLoading Start loading for prepend loading data. <ko>     . </ko>\n       * @param {Object} param.startLoading.userStyle The custom style to apply to this loading bar for start. <ko>         </ko>\n       * @param {Function} param.endLoading End loading after startLoading() for append/prepend loading data. <ko>   append/prepend startLoading()    .</ko>\n       * @param {Object} param.endLoading.userStyle The custom style to apply to this loading bar for start. <ko>         </ko>\n       */\n      this.trigger(\"prepend\", {\n        isTrusted: _consts.TRUSTED,\n        groupKey: this.getGroupKeys().shift(),\n        startLoading: function startLoading(userStyle) {\n          _this4.startLoading(false, userStyle);\n        },\n        endLoading: function endLoading(userStyle) {\n          _this4.endLoading(userStyle);\n        }\n      });\n    }\n  };\n\n  _proto._onResize = function _onResize() {\n    this.layout(true);\n  };\n\n  _proto._onCheck = function _onCheck(_ref7) {\n    var isForward = _ref7.isForward,\n        scrollPos = _ref7.scrollPos,\n        horizontal = _ref7.horizontal,\n        orgScrollPos = _ref7.orgScrollPos;\n\n    /**\n     * This event is fired when the user scrolls.\n     * @ko      .\n     * @event eg.InfiniteGrid#change\n     * @param {Object} param The object of data to be sent to an event <ko>   </ko>\n     * @param {Boolean} param.isForward Indicates whether the scroll progression direction is forward or backword. <ko>    ,   .</ko>\n     * @param {Number} param.scrollPos Current scroll position value relative to the infiniteGrid container element. <ko>infiniteGrid      </ko>\n     * @param {Boolean} param.orgScrollPos Current position of the scroll <ko>  </ko>\n     * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>     true,  API    false .</ko>\n     * @param {Boolean} options.horizontal Direction of the scroll movement (true: horizontal, false: vertical) <ko>   (true , false </ko>\n     */\n    this.trigger(\"change\", {\n      isForward: isForward,\n      horizontal: horizontal,\n      scrollPos: scrollPos,\n      orgScrollPos: orgScrollPos\n    });\n\n    this._infinite.scroll(scrollPos);\n  };\n\n  _proto._onLayoutComplete = function _onLayoutComplete(_ref8) {\n    var _this5 = this;\n\n    var items = _ref8.items,\n        isAppend = _ref8.isAppend,\n        _ref8$isTrusted = _ref8.isTrusted,\n        isTrusted = _ref8$isTrusted === void 0 ? false : _ref8$isTrusted,\n        _ref8$useRecycle = _ref8.useRecycle,\n        useRecycle = _ref8$useRecycle === void 0 ? this.options.useRecycle : _ref8$useRecycle,\n        _ref8$fromCache = _ref8.fromCache,\n        fromCache = _ref8$fromCache === void 0 ? false : _ref8$fromCache,\n        _ref8$isLayout = _ref8.isLayout,\n        isLayout = _ref8$isLayout === void 0 ? false : _ref8$isLayout;\n\n    var viewSize = this._renderer.getViewSize();\n\n    if (!isAppend) {\n      this._fit();\n    } else {\n      this._isLoading() && this._renderLoading();\n    }\n\n    var watcher = this._watcher;\n    var scrollPos = watcher.getScrollPos(); // recycle after _fit beacause prepend and append are occured simultaneously by scroll.\n\n    if (!isLayout && useRecycle && !this._isLoading()) {\n      this._infinite.recycle(scrollPos, isAppend);\n    }\n\n    var size = this._getEdgeValue(\"end\");\n\n    if (isAppend) {\n      this._setContainerSize(size + this._status.loadingSize || 0);\n\n      this._scrollTo(scrollPos);\n    }\n\n    !isLayout && this._process(_consts.PROCESSING, false);\n    /**\n     * This event is fired when layout is successfully arranged through a call to the append(), prepend(), or layout() method.\n     * @ko      . append()  prepend() , layout()        \n     * @event eg.InfiniteGrid#layoutComplete\n     *\n     * @param {Object} param The object of data to be sent to an event <ko>   </ko>\n     * @param {Array} param.target Rearranged card elements<ko>  </ko>\n     * @param {Boolean} param.fromCache Check whether these items are cache or not <ko>    .</ko>\n     * @param {Boolean} param.isLayout Returns true if this is an event called by resize event or layout method. Returns false if this is an event called by adding an item. <ko>     layout()    true,    false .</ko>\n     * @param {Boolean} param.isAppend Checks whether the append() method is used to add a card element. It returns true even though the layoutComplete event is fired after the layout() method is called. <ko>  append()   . layout()    layoutComplete   'true' .</ko>\n     * @param {Boolean} param.isScroll Checks whether scrolling has occurred after the append(), prepend(), ..., etc method is called <ko>append, prend      .</ko>\n     * @param {Number} param.scrollPos Current scroll position value relative to the infiniteGrid container element. <ko>infiniteGrid      </ko>\n     * @param {Number} param.orgScrollPos Current position of the scroll <ko>  </ko>\n     * @param {Number} param.size The size of container element <ko>  </ko>\n     * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>     true,  API    false .</ko>\n     * @param {Function} param.endLoading End loading after startLoading() for append/prepend loading data. <ko>   append/prepend startLoading()    .</ko>\n     * @param {Object} param.endLoading.userStyle The custom style to apply to this loading bar for start. <ko>         </ko>\n     */\n\n    this.trigger(\"layoutComplete\", {\n      target: items.concat(),\n      isAppend: isAppend,\n      isTrusted: isTrusted,\n      fromCache: fromCache,\n      isLayout: isLayout,\n      isScroll: viewSize < watcher.getContainerOffset() + size,\n      scrollPos: scrollPos,\n      orgScrollPos: watcher.getOrgScrollPos(),\n      size: size,\n      endLoading: function endLoading(userStyle) {\n        _this5.endLoading(userStyle);\n      }\n    });\n\n    this._infinite.scroll(scrollPos, isAppend);\n  };\n\n  _proto._reset = function _reset() {\n    this._status = {\n      processingStatus: _consts.IDLE,\n      loadingSize: 0\n    };\n  };\n  /**\n   * Destroys elements, properties, and events used on a grid layout.\n   * @ko     ,  \n   */\n\n\n  _proto.destroy = function destroy() {\n    this._infinite.clear();\n\n    this._watcher.destroy();\n\n    this._manager.destroy();\n\n    this._reset();\n\n    this._items.clear();\n\n    this._renderer.destroy();\n  };\n\n  return InfiniteGrid;\n}(_component[\"default\"]);\n\nvar _default = InfiniteGrid;\nexports[\"default\"] = _default;\nmodule.exports = exports[\"default\"];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/InfiniteGrid.js\n// module id = 13\n// module chunks = 0 1","module.exports = __WEBPACK_EXTERNAL_MODULE_14__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"commonjs\":\"@egjs/component\",\"commonjs2\":\"@egjs/component\",\"amd\":\"@egjs/component\",\"root\":[\"eg\",\"Component\"]}\n// module id = 14\n// module chunks = 0 1","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 15\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _consts = require(\"../consts\");\n\nvar _utils = require(\"../utils\");\n\n// ALIGN\nvar START = _consts.ALIGN.START,\n    CENTER = _consts.ALIGN.CENTER,\n    END = _consts.ALIGN.END,\n    JUSTIFY = _consts.ALIGN.JUSTIFY;\n/**\n * @classdesc The GridLayout is a layout that stacks cards with the same width as a stack of bricks. Adjust the width of all images to the same size, find the lowest height column, and insert a new card.\n * @ko GridLayout          .      ,        .            .\n * @class eg.InfiniteGrid.GridLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.GridLayout module <ko>eg.InfiniteGrid.GridLayout   </ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>  </ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>   (false: , true: )</ko>\n * @param {Boolean} [options.align=START] Align of the position of the items (START, CENTER, END, JUSTIFY) <ko>   (START, CENTER, END, JUSTIFY)</ko>\n * @param {Boolean} [options.itemSize=0] The size of the items. If it is 0, it is calculated as the size of the first item in items. <ko>  .    0,      . </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid(\"#grid\". {\n\thorizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.GridLayout, {\n\tmargin: 10,\n\talign: \"start\",\n\titemSize: 200\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.GridLayout({\n\tmargin: 10,\n\talign: \"center\",\n\titemSize: 200,\n\thorizontal: true,\n});\n\n</script>\n```\n **/\n\nvar GridLayout =\n/*#__PURE__*/\nfunction () {\n  function GridLayout(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.options = (0, _utils.assignOptions)({\n      margin: 0,\n      horizontal: false,\n      align: START,\n      itemSize: 0\n    }, options);\n    this._size = 0;\n    this._columnSize = 0;\n    this._columnLength = 0;\n    this._style = (0, _utils.getStyleNames)(this.options.horizontal);\n  }\n\n  var _proto = GridLayout.prototype;\n\n  _proto.checkColumn = function checkColumn(item) {\n    var _this$options = this.options,\n        itemSize = _this$options.itemSize,\n        margin = _this$options.margin,\n        horizontal = _this$options.horizontal;\n    var sizeName = horizontal ? \"height\" : \"width\";\n    var columnSize = parseInt(itemSize || item && item.size[sizeName], 10) || 0;\n    this._columnSize = columnSize;\n\n    if (!columnSize) {\n      this._columnLength = 1;\n      return;\n    }\n\n    this._columnLength = Math.max(parseInt((this._size + margin) / (columnSize + margin), 10), 1);\n  };\n\n  _proto._layout = function _layout(items, outline, isAppend) {\n    var length = items.length;\n    var margin = this.options.margin;\n    var align = this.options.align;\n    var style = this._style;\n    var size1Name = style.size1;\n    var size2Name = style.size2;\n    var pos1Name = style.pos1;\n    var pos2Name = style.pos2;\n    var columnSize = this._columnSize;\n    var columnLength = this._columnLength;\n    var size = this._size;\n    var viewDist = size - (columnSize + margin) * columnLength + margin;\n    var pointCaculateName = isAppend ? \"min\" : \"max\";\n    var startOutline = outline.slice();\n    var endOutline = outline.slice();\n\n    for (var i = 0; i < length; ++i) {\n      var _item$rect;\n\n      var point = Math[pointCaculateName].apply(Math, endOutline) || 0;\n      var index = endOutline.indexOf(point);\n      var item = items[isAppend ? i : length - 1 - i];\n      var size1 = item.size[size1Name];\n      var size2 = item.size[size2Name];\n      var pos1 = isAppend ? point : point - margin - size1;\n      var endPos1 = pos1 + size1 + margin;\n\n      if (index === -1) {\n        index = 0;\n      }\n\n      var pos2 = (columnSize + margin) * index; // ALIGN\n\n      if (align === CENTER) {\n        pos2 += viewDist / 2;\n      } else if (align === END) {\n        pos2 += viewDist + columnSize - size2;\n      } else if (align === JUSTIFY) {\n        if (columnLength <= 1) {\n          pos2 += viewDist / 2;\n        } else {\n          pos2 = (size - columnSize) / (columnLength - 1) * index;\n        }\n      } // tetris\n\n\n      item.rect = (_item$rect = {}, _item$rect[pos1Name] = pos1, _item$rect[pos2Name] = pos2, _item$rect);\n      item.column = index;\n      endOutline[index] = isAppend ? endPos1 : pos1;\n    }\n\n    if (!isAppend) {\n      items.sort(function (a, b) {\n        var item1pos1 = a.rect[pos1Name];\n        var item1pos2 = a.rect[pos2Name];\n        var item2pos1 = b.rect[pos1Name];\n        var item2pos2 = b.rect[pos2Name];\n\n        if (item1pos1 - item2pos1) {\n          return item1pos1 - item2pos1;\n        }\n\n        return item1pos2 - item2pos2;\n      });\n    } // if append items, startOutline is low, endOutline is high\n    // if prepend items, startOutline is high, endOutline is low\n\n\n    return {\n      start: isAppend ? startOutline : endOutline,\n      end: isAppend ? endOutline : startOutline\n    };\n  };\n\n  _proto._insert = function _insert(items, outline, type, cache) {\n    if (items === void 0) {\n      items = [];\n    }\n\n    if (outline === void 0) {\n      outline = [];\n    }\n\n    var clone = cache ? items : (0, _utils.cloneItems)(items);\n    var startOutline = outline;\n\n    if (!this._columnLength) {\n      this.checkColumn(items[0]);\n    }\n\n    if (outline.length !== this._columnLength) {\n      startOutline = (0, _utils.fill)(new Array(this._columnLength), outline.length === 0 ? 0 : Math[type === _consts.APPEND ? \"min\" : \"max\"].apply(Math, outline) || 0);\n    }\n\n    var result = this._layout(clone, startOutline, type);\n\n    return {\n      items: clone,\n      outlines: result\n    };\n  };\n  /**\n   * Adds items at the bottom of a outline.\n   * @ko    .\n   * @method eg.InfiniteGrid.GridLayout#append\n   * @param {Array} items Array of items to be layouted <ko>  </ko>\n   * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n   * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n   * @example\n   * layout.prepend(items, [100, 200, 300, 400]);\n   */\n\n\n  _proto.append = function append(items, outline, cache) {\n    return this._insert(items, outline, _consts.APPEND, cache);\n  };\n  /**\n   * Adds items at the top of a outline.\n   * @ko    .\n   * @method eg.InfiniteGrid.GridLayout#prepend\n   * @param {Array} items Array of items to be layouted <ko>  </ko>\n   * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n   * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n   * @example\n   * layout.prepend(items, [100, 200, 300, 400]);\n   */\n\n\n  _proto.prepend = function prepend(items, outline, cache) {\n    return this._insert(items, outline, _consts.PREPEND, cache);\n  };\n  /**\n   * Adds items of groups at the bottom of a outline.\n   * @ko     .\n   * @method eg.InfiniteGrid.GridLayout#layout\n   * @param {Array} groups Array of groups to be layouted <ko>  </ko>\n   * @param {Array} outline Array of outline points to be reference points <ko>    </ko>\n   * @return {eg.InfiniteGrid.GridLayout} An instance of a module itself<ko>  </ko>\n   * @example\n   * layout.layout(groups, [100, 200, 300, 400]);\n   */\n\n\n  _proto.layout = function layout(groups, outline) {\n    var _this = this;\n\n    if (groups === void 0) {\n      groups = [];\n    }\n\n    if (outline === void 0) {\n      outline = [];\n    }\n\n    var firstItem = groups.length && groups[0].items.length && groups[0].items[0] || 0;\n    this.checkColumn(firstItem); // if outlines' length and columns' length are now same, re-caculate outlines.\n\n    var startOutline;\n\n    if (outline.length !== this._columnLength) {\n      var pos = outline.length === 0 ? 0 : Math.min.apply(Math, outline); // re-layout items.\n\n      startOutline = (0, _utils.fill)(new Array(this._columnLength), pos);\n    } else {\n      startOutline = outline.slice();\n    }\n\n    groups.forEach(function (group) {\n      var items = group.items;\n\n      var result = _this._layout(items, startOutline, _consts.APPEND);\n\n      group.outlines = result;\n      startOutline = result.end;\n    });\n    return this;\n  };\n  /**\n   * Set the viewport size of the layout.\n   * @ko    .\n   * @method eg.InfiniteGrid.GridLayout#setSize\n   * @param {Number} size The viewport size of container area where items are added to a layout <ko>      </ko>\n   * @return {eg.InfiniteGrid.GridLayout} An instance of a module itself<ko>  </ko>\n   * @example\n   * layout.setSize(800);\n   */\n\n\n  _proto.setSize = function setSize(size) {\n    this._size = size;\n    return this;\n  };\n\n  return GridLayout;\n}();\n\nvar _default = GridLayout;\nexports[\"default\"] = _default;\nmodule.exports = exports[\"default\"];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/layouts/GridLayout.js\n// module id = 16\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _FrameLayout2 = _interopRequireDefault(require(\"./FrameLayout\"));\n\nvar _utils = require(\"../utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nfunction makeShapeOutline(outline, itemSize, columnLength, isAppend) {\n  var point = Math[isAppend ? \"min\" : \"max\"].apply(Math, outline) || 0;\n\n  if (outline.length !== columnLength) {\n    return (0, _utils.fill)(new Array(columnLength), 0);\n  }\n\n  return outline.map(function (l) {\n    return parseInt((l - point) / itemSize, 10);\n  });\n}\n\nfunction getColumn(item) {\n  if (item.column) {\n    return item.column;\n  }\n\n  var column = 0;\n\n  if (item.el) {\n    var dataset = item.el.dataset;\n\n    if (dataset) {\n      column = dataset.column || 1;\n    } else {\n      column = item.el.getAttribute(\"column\") || 1;\n    }\n  } else {\n    column = 1;\n  }\n\n  item.column = column;\n  return column;\n}\n/**\n * @classdesc SquareLayout is a layout that places all cards like squares on a checkerboard, and important cards are n times larger. The main card can be enlarged, and then a small card can be placed to naturally show the relationship of the card.\n * @ko SquareLayout         N   .    ,           .\n * @class eg.InfiniteGrid.SquareLayout\n * @extends eg.InfiniteGrid.FrameLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.SquareLayout module <ko>eg.InfiniteGrid.SquareLayout   </ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>  </ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>   (false: , true: )</ko>\n * @param {Boolean} [options.itemSize=0] The size of the items. If it is 0, it is calculated as the size of the first item in items. <ko>  .    0,      . </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid(\"#grid\". {\n\thorizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.SquareLayout, {\n\tmargin: 10,\n\titemSize: 200,\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.SquareLayout({\n\tmargin: 10,\n\titemSize: 200,\n\thorizontal: true,\n});\n\n\nvar item1 = '<div data-column=\"2\"></div>';\nvar item2 = \"<div></div>\"\nlayout.append([item1, item2]);\n</script>\n```\n **/\n\n\nvar SquareLayout =\n/*#__PURE__*/\nfunction (_FrameLayout) {\n  _inheritsLoose(SquareLayout, _FrameLayout);\n\n  function SquareLayout() {\n    return _FrameLayout.apply(this, arguments) || this;\n  }\n\n  var _proto = SquareLayout.prototype;\n\n  _proto._checkItemSize = function _checkItemSize() {\n    var column = this.options.column;\n\n    if (!column) {\n      _FrameLayout.prototype._checkItemSize.call(this);\n\n      return;\n    }\n\n    var margin = this.options.margin; // if itemSize is not in options, caculate itemSize from size.\n\n    this._itemSize = (this._size + margin) / column - margin;\n  };\n\n  _proto._layout = function _layout(items, outline, isAppend) {\n    var _this$_shapes;\n\n    if (outline === void 0) {\n      outline = [];\n    }\n\n    var itemSize = this._getItemSize();\n\n    var margin = this.options.margin;\n    var columnLength = this.options.column || parseInt((this._size + margin) / (itemSize + margin), 10) || 1;\n    var length = items.length;\n    var endOutline = makeShapeOutline(outline, itemSize, columnLength, isAppend);\n    var pointCaculateName = isAppend ? \"min\" : \"max\";\n    var shapes = [];\n    var sign = isAppend ? 1 : -1;\n    var style = this._style;\n    var pos1Name = style.pos1;\n    var pos2Name = style.pos2;\n\n    for (var i = 0; i < length; ++i) {\n      var _shapes$push;\n\n      var point = Math[pointCaculateName].apply(Math, endOutline);\n      var index = endOutline[isAppend ? \"indexOf\" : \"lastIndexOf\"](point);\n      var item = items[i];\n      var columnWidth = item.columnWidth;\n      var column = columnWidth && columnWidth[0] === columnLength && columnWidth[1] || getColumn(item);\n      var columnCount = 1;\n\n      if (column > 1) {\n        for (var j = 1; j < column && (isAppend && index + j < columnLength || !isAppend && index - j >= 0); ++j) {\n          if (isAppend && endOutline[index + sign * j] <= point || !isAppend && endOutline[index + sign * j] >= point) {\n            ++columnCount;\n            continue;\n          }\n\n          break;\n        }\n\n        if (!isAppend) {\n          index -= columnCount - 1;\n        }\n      }\n\n      item.columnWidth = [columnLength, columnCount];\n      shapes.push((_shapes$push = {\n        width: columnCount,\n        height: columnCount\n      }, _shapes$push[pos1Name] = point - (!isAppend ? columnCount : 0), _shapes$push[pos2Name] = index, _shapes$push.index = i, _shapes$push));\n\n      for (var _j = 0; _j < columnCount; ++_j) {\n        endOutline[index + _j] = point + sign * columnCount;\n      }\n    }\n\n    this._shapes = (_this$_shapes = {\n      shapes: shapes\n    }, _this$_shapes[style.size2] = columnLength, _this$_shapes);\n\n    var result = _FrameLayout.prototype._layout.call(this, items, outline, isAppend);\n\n    if (!isAppend) {\n      shapes.sort(function (shape1, shape2) {\n        var item1pos1 = shape1[pos1Name];\n        var item1pos2 = shape1[pos2Name];\n        var item2pos1 = shape2[pos1Name];\n        var item2pos2 = shape2[pos2Name];\n\n        if (item1pos1 - item2pos1) {\n          return item1pos1 - item2pos1;\n        }\n\n        return item1pos2 - item2pos2;\n      });\n      items.sort(function (a, b) {\n        var item1pos1 = a.rect[pos1Name];\n        var item1pos2 = a.rect[pos2Name];\n        var item2pos1 = b.rect[pos1Name];\n        var item2pos2 = b.rect[pos2Name];\n\n        if (item1pos1 - item2pos1) {\n          return item1pos1 - item2pos1;\n        }\n\n        return item1pos2 - item2pos2;\n      });\n    }\n\n    return result;\n  };\n\n  return SquareLayout;\n}(_FrameLayout2[\"default\"]);\n\nvar _default = SquareLayout;\nexports[\"default\"] = _default;\nmodule.exports = exports[\"default\"];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/layouts/SquareLayout.js\n// module id = 17\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _BoxModel = _interopRequireDefault(require(\"./lib/BoxModel.js\"));\n\nvar _consts = require(\"../consts\");\n\nvar _utils = require(\"../utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction getCost(originLength, length) {\n  var cost = originLength / length;\n\n  if (cost < 1) {\n    cost = 1 / cost;\n  }\n\n  return cost - 1;\n}\n\nfunction fitArea(item, bestFitArea, itemFitSize, containerFitSize, layoutVertical) {\n  item.height = itemFitSize.height;\n  item.width = itemFitSize.width;\n  bestFitArea.height = containerFitSize.height;\n  bestFitArea.width = containerFitSize.width;\n\n  if (layoutVertical) {\n    item.top = bestFitArea.top + bestFitArea.height;\n    item.left = bestFitArea.left;\n  } else {\n    item.left = bestFitArea.left + bestFitArea.width;\n    item.top = bestFitArea.top;\n  }\n}\n/**\n * @classdesc The PackingLayout is a layout that shows the important cards bigger without sacrificing the weight of the cards. Rows and columns are separated so that cards are dynamically placed within the horizontal and vertical space rather than arranged in an orderly fashion.\n * @ko PackingLayout              .              .\n * @class eg.InfiniteGrid.PackingLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.PackingLayout module <ko>eg.InfiniteGrid.PackingLayout   </ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>  </ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>   (false: , true: )</ko>\n * @param {Boolean} [options.aspectRatio=1] The aspect ratio of the group <ko>     </ko>\n * @param {Boolean} [options.sizeWeight=1] The size weight when placing an image <ko>      </ko>\n * @param {Boolean} [options.ratioWeight=1] The ratio weight when placing an image <ko>      </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid(\"#grid\". {\n\thorizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.PackingLayout, {\n\tmargin: 10,\n\taspectRatio: 1,\n\tsizeWeight: 1,\n\tratioWeight: 2,\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.PackingLayout({\n\thorizontal: true,\n\tmargin: 10,\n\taspectRatio: 1,\n\tsizeWeight: 1,\n\tratioWeight: 2,\n});\n\n</script>\n```\n **/\n\n\nvar PackingLayout =\n/*#__PURE__*/\nfunction () {\n  function PackingLayout(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.options = (0, _utils.assignOptions)({\n      margin: 0,\n      horizontal: false,\n      aspectRatio: 1,\n      sizeWeight: 1,\n      ratioWeight: 1\n    }, options);\n    this._size = 0;\n    this._style = (0, _utils.getStyleNames)(this.options.horizontal);\n  }\n\n  var _proto = PackingLayout.prototype;\n\n  _proto._findBestFitArea = function _findBestFitArea(container, item) {\n    if (container.getRatio() === 0) {\n      //     \n      container.originWidth = item.width;\n      container.originHeight = item.height;\n      container.width = item.width;\n      container.height = item.height;\n      return;\n    }\n\n    var bestFitArea = null;\n    var minCost = 10000000;\n    var layoutVertical = false;\n    var itemFitSize = {\n      width: 0,\n      height: 0\n    };\n    var containerFitSize = {\n      width: 0,\n      height: 0\n    };\n    var _this$options = this.options,\n        sizeWeight = _this$options.sizeWeight,\n        ratioWeight = _this$options.ratioWeight;\n    container.items.forEach(function (v) {\n      var containerSizeCost = getCost(v.getOriginSize(), v.getSize()) * sizeWeight;\n      var containerRatioCost = getCost(v.getOriginRatio(), v.getRatio()) * ratioWeight;\n      var width = v.width;\n      var height = v.height;\n      var cost;\n\n      for (var i = 0; i < 2; ++i) {\n        var itemWidth = void 0;\n        var itemHeight = void 0;\n        var containerWidth = void 0;\n        var containerHeight = void 0;\n\n        if (i === 0) {\n          //   \n          itemWidth = width;\n          itemHeight = height * (item.height / (v.originHeight + item.height));\n          containerWidth = width;\n          containerHeight = height - itemHeight;\n        } else {\n          //   \n          itemHeight = height;\n          itemWidth = width * (item.width / (v.originWidth + item.width));\n          containerHeight = height;\n          containerWidth = width - itemWidth;\n        }\n\n        var itemSize = itemWidth * itemHeight;\n        var itemRatio = itemWidth / itemHeight;\n        var containerSize = containerWidth * containerHeight;\n        var containerRatio = containerHeight / containerHeight;\n        cost = getCost(item.getSize(), itemSize) * sizeWeight;\n        cost += getCost(item.getRatio(), itemRatio) * ratioWeight;\n        cost += getCost(v.getOriginSize(), containerSize) * sizeWeight - containerSizeCost;\n        cost += getCost(v.getOriginRatio(), containerRatio) * ratioWeight - containerRatioCost;\n\n        if (cost === Math.min(cost, minCost)) {\n          minCost = cost;\n          bestFitArea = v;\n          layoutVertical = i === 0;\n          itemFitSize.width = itemWidth;\n          itemFitSize.height = itemHeight;\n          containerFitSize.width = containerWidth;\n          containerFitSize.height = containerHeight;\n        }\n      }\n    });\n    fitArea(item, bestFitArea, itemFitSize, containerFitSize, layoutVertical);\n  };\n\n  _proto._layout = function _layout(items, outline, isAppend) {\n    var _this = this;\n\n    if (outline === void 0) {\n      outline = [];\n    }\n\n    var style = this._style;\n    var _this$options2 = this.options,\n        horizontal = _this$options2.horizontal,\n        aspectRatio = _this$options2.aspectRatio,\n        margin = _this$options2.margin;\n    var pos1Name = style.pos1;\n    var containerWidth = this._size * (horizontal ? aspectRatio : 1);\n    var containerHeight = this._size / (horizontal ? 1 : aspectRatio);\n    var containerSize1 = horizontal ? containerWidth : containerHeight;\n    var prevOutline = (0, _utils.toZeroArray)(outline);\n    var start = isAppend ? Math.max.apply(Math, prevOutline) : Math.min.apply(Math, prevOutline) - containerSize1 - margin;\n    var end = start + containerSize1 + margin;\n    var container = new _BoxModel[\"default\"]({});\n    items.forEach(function (item) {\n      var _item$orgSize = item.orgSize,\n          width = _item$orgSize.width,\n          height = _item$orgSize.height;\n      var model = new _BoxModel[\"default\"]({\n        width: width,\n        height: height,\n        originWidth: width,\n        originHeight: height\n      });\n\n      _this._findBestFitArea(container, model);\n\n      container.push(model);\n      container.scaleTo(containerWidth + margin, containerHeight + margin);\n    });\n    items.forEach(function (item, i) {\n      var boxItem = container.items[i];\n      var width = boxItem.width;\n      var height = boxItem.height;\n      var top = boxItem.top;\n      var left = boxItem.left;\n      item.rect = {\n        top: top,\n        left: left,\n        width: width - margin,\n        height: height - margin\n      };\n      item.rect[pos1Name] += start;\n    });\n    return {\n      start: [start],\n      end: [end]\n    };\n  };\n\n  _proto._insert = function _insert(items, outline, type, cache) {\n    if (items === void 0) {\n      items = [];\n    }\n\n    if (outline === void 0) {\n      outline = [];\n    }\n\n    // this only needs the size of the item.\n    var clone = cache ? items : (0, _utils.cloneItems)(items);\n    return {\n      items: clone,\n      outlines: this._layout(clone, outline, type)\n    };\n  };\n  /**\n   * Adds items at the bottom of a outline.\n   * @ko    .\n   * @method eg.InfiniteGrid.PackingLayout#append\n   * @param {Array} items Array of items to be layouted <ko>  </ko>\n   * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n   * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n   * @example\n   * layout.prepend(items, [100]);\n   */\n\n\n  _proto.append = function append(items, outline, cache) {\n    return this._insert(items, outline, _consts.APPEND, cache);\n  };\n  /**\n   * Adds items at the top of a outline.\n   * @ko    .\n   * @method eg.InfiniteGrid.PackingLayout#prepend\n   * @param {Array} items Array of items to be layouted <ko>  </ko>\n   * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n   * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n   * @example\n   * layout.prepend(items, [100]);\n   */\n\n\n  _proto.prepend = function prepend(items, outline, cache) {\n    return this._insert(items, outline, _consts.PREPEND, cache);\n  };\n  /**\n   * Adds items of groups at the bottom of a outline.\n   * @ko     .\n   * @method eg.InfiniteGrid.PackingLayout#layout\n   * @param {Array} groups Array of groups to be layouted <ko>  </ko>\n   * @param {Array} outline Array of outline points to be reference points <ko>    </ko>\n   * @return {eg.InfiniteGrid.PackingLayout} An instance of a module itself<ko>  </ko>\n   * @example\n   * layout.layout(groups, [100, 200, 300, 400]);\n   */\n\n\n  _proto.layout = function layout(groups, outline) {\n    if (groups === void 0) {\n      groups = [];\n    }\n\n    if (outline === void 0) {\n      outline = [];\n    }\n\n    var length = groups.length;\n    var point = outline;\n\n    for (var i = 0; i < length; ++i) {\n      var group = groups[i];\n      point = this._layout(group.items, point, _consts.APPEND);\n      group.outlines = point;\n      point = point.end;\n    }\n\n    return this;\n  };\n  /**\n   * Set the viewport size of the layout.\n   * @ko    .\n   * @method eg.InfiniteGrid.PackingLayout#setSize\n   * @param {Number} size The viewport size of container area where items are added to a layout <ko>      </ko>\n   * @return {eg.InfiniteGrid.PackingLayout} An instance of a module itself<ko>  </ko>\n   * @example\n   * layout.setSize(800);\n   */\n\n\n  _proto.setSize = function setSize(size) {\n    this._size = size;\n    return this;\n  };\n\n  return PackingLayout;\n}();\n\nvar _default = PackingLayout;\nexports[\"default\"] = _default;\nmodule.exports = exports[\"default\"];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/layouts/PackingLayout.js\n// module id = 18\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nvar BoxModel =\n/*#__PURE__*/\nfunction () {\n  function BoxModel(options) {\n    _extends(this, {\n      originWidth: 0,\n      originHeight: 0,\n      width: 0,\n      height: 0,\n      left: 0,\n      top: 0,\n      items: []\n    }, options);\n  }\n\n  var _proto = BoxModel.prototype;\n\n  _proto.scaleTo = function scaleTo(width, height) {\n    var scaleX = this.width ? width / this.width : 0;\n    var scaleY = this.height ? height / this.height : 0;\n    this.items.forEach(function (v) {\n      if (scaleX !== 0) {\n        v.left *= scaleX;\n        v.width *= scaleX;\n      }\n\n      if (scaleY !== 0) {\n        v.top *= scaleY;\n        v.height *= scaleY;\n      }\n    });\n    this.width = width;\n    this.height = height;\n  };\n\n  _proto.push = function push(item) {\n    this.items.push(item);\n  };\n\n  _proto.getOriginSize = function getOriginSize() {\n    return this.originWidth * this.originHeight;\n  };\n\n  _proto.getSize = function getSize() {\n    return this.width * this.height;\n  };\n\n  _proto.getOriginRatio = function getOriginRatio() {\n    return this.originHeight === 0 ? 0 : this.originWidth / this.originHeight;\n  };\n\n  _proto.getRatio = function getRatio() {\n    return this.height === 0 ? 0 : this.width / this.height;\n  };\n\n  return BoxModel;\n}();\n\nexports[\"default\"] = BoxModel;\nmodule.exports = exports[\"default\"];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/layouts/lib/BoxModel.js\n// module id = 19\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _dijkstra = _interopRequireDefault(require(\"./lib/dijkstra\"));\n\nvar _consts = require(\"../consts\");\n\nvar _utils = require(\"../utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/**\n * @classdesc 'justified' is a printing term with the meaning that 'it fits in one row wide'. JustifiedLayout is a layout that the card is filled up on the basis of a line given a size.\n * @ko 'justified' '1    '    .           .\n * @class eg.InfiniteGrid.JustifiedLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.JustifiedLayout module <ko>eg.InfiniteGrid.JustifiedLayout   </ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>  </ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>   (false: , true: )</ko>\n * @param {Number} [options.minSize=0] Minimum size of item to be resized <ko>     </ko>\n * @param {Number} [options.maxSize=0] Maximum size of item to be resized <ko>     </ko>\n * @param {Array|Number} [options.column=[1, 8]] The number of items in a line <ko>      </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid(\"#grid\". {\n\thorizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.JustifiedLayout, {\n\tmargin: 10,\n\tminSize: 100,\n\tmaxSize: 300,\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.JustifiedLayout({\n\tmargin: 10,\n\tminSize: 100,\n\tmaxSize: 300,\n\tcolumn: 5,\n\thorizontal: true,\n});\n\n</script>\n```\n **/\nvar JustifiedLayout =\n/*#__PURE__*/\nfunction () {\n  function JustifiedLayout(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.options = (0, _utils.assignOptions)({\n      margin: 0,\n      horizontal: false,\n      minSize: 0,\n      maxSize: 0,\n      column: [1, 8]\n    }, options);\n    this._style = (0, _utils.getStyleNames)(this.options.horizontal);\n    this._size = 0;\n  }\n\n  var _proto = JustifiedLayout.prototype;\n\n  _proto._layout = function _layout(items, outline, isAppend) {\n    var _this = this;\n\n    var style = this._style;\n    var size1Name = style.size1;\n    var size2Name = style.size2;\n    var startIndex = 0;\n    var endIndex = items.length;\n    var column = this.options.column;\n\n    if (typeof column !== \"object\") {\n      column = [column, column];\n    }\n\n    var graph = function graph(_start) {\n      var results = {};\n      var start = +_start.replace(/[^0-9]/g, \"\");\n      var length = endIndex + 1;\n\n      for (var i = Math.min(start + column[0], length - 1); i < length; ++i) {\n        if (i - start > column[1]) {\n          break;\n        }\n\n        var cost = _this._getCost(items, start, i, size1Name, size2Name);\n\n        if (cost === null) {\n          continue;\n        }\n\n        if (cost < 0 && i === length - 1) {\n          cost = 0;\n        }\n\n        results[\"\" + i] = Math.pow(cost, 2);\n      }\n\n      return results;\n    }; // shortest path for items' total height.\n\n\n    var path = _dijkstra[\"default\"].find_path(graph, \"\" + startIndex, \"\" + endIndex);\n\n    return this._setStyle(items, path, outline, isAppend);\n  };\n\n  _proto._getSize = function _getSize(items, size1Name, size2Name) {\n    var margin = this.options.margin;\n    var size = items.reduce(function (sum, item) {\n      return sum + item.orgSize[size2Name] / item.orgSize[size1Name];\n    }, 0);\n    return (this._size - margin * (items.length - 1)) / size;\n  };\n\n  _proto._getCost = function _getCost(items, i, j, size1Name, size2Name) {\n    var size = this._getSize(items.slice(i, j), size1Name, size2Name);\n\n    var min = this.options.minSize || 0;\n    var max = this.options.maxSize || Infinity;\n\n    if (isFinite(max)) {\n      // if this size is not in range, the cost increases sharply.\n      if (size < min) {\n        return Math.pow(size - min, 2) + Math.pow(max, 2);\n      } else if (size > max) {\n        return Math.pow(size - max, 2) + Math.pow(max, 2);\n      } else {\n        // if this size in range, the cost is negative or low.\n        return Math.min(size - max, min - size);\n      }\n    } // if max is infinite type, caculate cost only with \"min\".\n\n\n    if (size < min) {\n      return Math.max(Math.pow(min, 2), Math.pow(size, 2));\n    }\n\n    return size - min;\n  };\n\n  _proto._setStyle = function _setStyle(items, path, outline, isAppend) {\n    if (outline === void 0) {\n      outline = [];\n    }\n\n    var style = this._style; // if direction is vertical\n    // pos1 : top, pos11 : bottom\n    // size1 : height\n    // pos2 : left, pos22 : right\n    // size2 : width\n    // if direction is horizontal\n    // pos1 : left, pos11 : right\n    // size1 : width\n    // pos2 : top, pos22 : bottom\n    // size2 : height\n\n    var pos1Name = style.pos1;\n    var size1Name = style.size1;\n    var pos2Name = style.pos2;\n    var size2Name = style.size2;\n    var length = path.length;\n    var margin = this.options.margin;\n    var startPoint = outline[0] || 0;\n    var endPoint = startPoint;\n    var height = 0;\n\n    for (var i = 0; i < length - 1; ++i) {\n      var path1 = parseInt(path[i], 10);\n      var path2 = parseInt(path[i + 1], 10); // pathItems(path1 to path2) are in 1 line.\n\n      var pathItems = items.slice(path1, path2);\n      var pathItemsLength = pathItems.length;\n\n      var size1 = this._getSize(pathItems, size1Name, size2Name);\n\n      var pos1 = endPoint;\n\n      for (var j = 0; j < pathItemsLength; ++j) {\n        var _item$rect;\n\n        var item = pathItems[j];\n        var size2 = item.orgSize[size2Name] / item.orgSize[size1Name] * size1; // item has margin bottom and right.\n        // first item has not margin.\n\n        var prevItemRect = j === 0 ? 0 : pathItems[j - 1].rect;\n        var pos2 = prevItemRect ? prevItemRect[pos2Name] + prevItemRect[size2Name] + margin : 0;\n        item.rect = (_item$rect = {}, _item$rect[pos1Name] = pos1, _item$rect[pos2Name] = pos2, _item$rect[size1Name] = size1, _item$rect[size2Name] = size2, _item$rect);\n      }\n\n      height += margin + size1;\n      endPoint = startPoint + height;\n    }\n\n    var itemsLength = items.length;\n\n    if (isAppend) {\n      // previous group's end outline is current group's start outline\n      return {\n        start: [startPoint],\n        end: [endPoint]\n      };\n    } // for prepend, only substract height from position.\n    // always start is lower than end.\n\n\n    for (var _i = 0; _i < itemsLength; ++_i) {\n      var _item = items[_i]; // move items as long as height for prepend\n\n      _item.rect[pos1Name] -= height;\n    }\n\n    return {\n      start: [startPoint - height],\n      end: [startPoint] // endPoint - height = startPoint\n\n    };\n  };\n\n  _proto._insert = function _insert(items, outline, type, cache) {\n    if (items === void 0) {\n      items = [];\n    }\n\n    if (outline === void 0) {\n      outline = [];\n    }\n\n    // this only needs the size of the item.\n    var clone = cache ? items : (0, _utils.cloneItems)(items);\n    return {\n      items: clone,\n      outlines: this._layout(clone, outline, type)\n    };\n  };\n  /**\n   * Set the viewport size of the layout.\n   * @ko    .\n   * @method eg.InfiniteGrid.JustifiedLayout#setSize\n   * @param {Number} size The viewport size of container area where items are added to a layout <ko>      </ko>\n   * @return {eg.InfiniteGrid.JustifiedLayout} An instance of a module itself<ko>  </ko>\n   * @example\n   * layout.setSize(800);\n   */\n\n\n  _proto.setSize = function setSize(size) {\n    this._size = size;\n    return this;\n  };\n  /**\n   * Adds items at the bottom of a outline.\n   * @ko    .\n   * @method eg.InfiniteGrid.JustifiedLayout#append\n   * @param {Array} items Array of items to be layouted <ko>  </ko>\n   * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n   * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n   * @example\n   * layout.prepend(items, [100]);\n   */\n\n\n  _proto.append = function append(items, outline, cache) {\n    return this._insert(items, outline, _consts.APPEND, cache);\n  };\n  /**\n   * Adds items at the top of a outline.\n   * @ko    .\n   * @method eg.InfiniteGrid.JustifiedLayout#prepend\n   * @param {Array} items Array of items to be layouted <ko>  </ko>\n   * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n   * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n   * @example\n   * layout.prepend(items, [100]);\n   */\n\n\n  _proto.prepend = function prepend(items, outline, cache) {\n    return this._insert(items, outline, _consts.PREPEND, cache);\n  };\n  /**\n   * Adds items of groups at the bottom of a outline.\n   * @ko     .\n   * @method eg.InfiniteGrid.JustifiedLayout#layout\n   * @param {Array} groups Array of groups to be layouted <ko>  </ko>\n   * @param {Array} outline Array of outline points to be reference points <ko>    </ko>\n   * @return {eg.InfiniteGrid.JustifiedLayout} An instance of a module itself<ko>  </ko>\n   * @example\n   * layout.layout(groups, [100]);\n   */\n\n\n  _proto.layout = function layout(groups, outline) {\n    if (groups === void 0) {\n      groups = [];\n    }\n\n    if (outline === void 0) {\n      outline = [];\n    }\n\n    var length = groups.length;\n    var point = outline;\n\n    for (var i = 0; i < length; ++i) {\n      var group = groups[i];\n      point = this._layout(group.items, point, _consts.APPEND);\n      group.outlines = point;\n      point = point.end;\n    }\n\n    return this;\n  };\n\n  return JustifiedLayout;\n}();\n\nvar _default = JustifiedLayout;\nexports[\"default\"] = _default;\nmodule.exports = exports[\"default\"];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/layouts/JustifiedLayout.js\n// module id = 20\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\n/* eslint-disable */\n\n/******************************************************************************\n * Created 2008-08-19.\n *\n * Dijkstra path-finding functions. Adapted from the Dijkstar Python project.\n *\n * Copyright (C) 2008\n *   Wyatt Baldwin <self@wyattbaldwin.com>\n *   All rights reserved\n *\n * Licensed under the MIT license.\n *\n *   http://www.opensource.org/licenses/mit-license.php\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *****************************************************************************/\nvar dijkstra = {\n  single_source_shortest_paths: function single_source_shortest_paths(graph, s, d) {\n    // Predecessor map for each node that has been encountered.\n    // node ID => predecessor node ID\n    var predecessors = {}; // Costs of shortest paths from s to all nodes encountered.\n    // node ID => cost\n\n    var costs = {};\n    costs[s] = 0; // Costs of shortest paths from s to all nodes encountered; differs from\n    // `costs` in that it provides easy access to the node that currently has\n    // the known shortest path from s.\n    // XXX: Do we actually need both `costs` and `open`?\n\n    var open = new BinaryHeap(function (x) {\n      return x.cost;\n    });\n    open.push({\n      value: s,\n      cost: 0\n    });\n    var closest, u, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;\n\n    while (open.size()) {\n      // In the nodes remaining in graph that have a known cost from s,\n      // find the node, u, that currently has the shortest path from s.\n      closest = open.pop();\n      u = closest.value;\n      cost_of_s_to_u = closest.cost; // Get nodes adjacent to u...\n\n      adjacent_nodes = graph(u) || {}; // ...and explore the edges that connect u to those nodes, updating\n      // the cost of the shortest paths to any or all of those nodes as\n      // necessary. v is the node across the current edge from u.\n\n      for (var v in adjacent_nodes) {\n        // Get the cost of the edge running from u to v.\n        cost_of_e = adjacent_nodes[v]; // Cost of s to u plus the cost of u to v across e--this is *a*\n        // cost from s to v that may or may not be less than the current\n        // known cost to v.\n\n        cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e; // If we haven't visited v yet OR if the current known cost from s to\n        // v is greater than the new cost we just found (cost of s to u plus\n        // cost of u to v across e), update v's cost in the cost list and\n        // update v's predecessor in the predecessor list (it's now u).\n\n        cost_of_s_to_v = costs[v];\n        first_visit = typeof costs[v] === 'undefined';\n\n        if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {\n          costs[v] = cost_of_s_to_u_plus_cost_of_e;\n          open.push({\n            value: v,\n            cost: cost_of_s_to_u_plus_cost_of_e\n          });\n          predecessors[v] = u;\n        }\n      }\n    }\n\n    if (typeof costs[d] === 'undefined') {\n      var msg = ['Could not find a path from ', s, ' to ', d, '.'].join('');\n      throw new Error(msg);\n    }\n\n    return predecessors;\n  },\n  extract_shortest_path_from_predecessor_list: function extract_shortest_path_from_predecessor_list(predecessors, d) {\n    var nodes = [];\n    var u = d;\n    var predecessor;\n\n    while (u) {\n      nodes.push(u);\n      predecessor = predecessors[u];\n      u = predecessors[u];\n    }\n\n    nodes.reverse();\n    return nodes;\n  },\n  find_path: function find_path(graph, s, d) {\n    var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);\n    return dijkstra.extract_shortest_path_from_predecessor_list(predecessors, d);\n  }\n};\n\nvar BinaryHeap =\n/*#__PURE__*/\nfunction () {\n  function BinaryHeap(scoreFunction) {\n    this.content = [];\n    this.scoreFunction = scoreFunction;\n  }\n\n  var _proto = BinaryHeap.prototype;\n\n  _proto.push = function push(element) {\n    // Add the new element to the end of the array.\n    this.content.push(element); // Allow it to bubble up.\n\n    this.bubbleUp(this.content.length - 1);\n  };\n\n  _proto.pop = function pop() {\n    // Store the first element so we can return it later.\n    var result = this.content[0]; // Get the element at the end of the array.\n\n    var end = this.content.pop(); // If there are any elements left, put the end element at the\n    // start, and let it sink down.\n\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.sinkDown(0);\n    }\n\n    return result;\n  };\n\n  _proto.size = function size() {\n    return this.content.length;\n  };\n\n  _proto.bubbleUp = function bubbleUp(n) {\n    // Fetch the element that has to be moved.\n    var element = this.content[n]; // When at 0, an element can not go up any further.\n\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      var parentN = Math.floor((n + 1) / 2) - 1,\n          parent = this.content[parentN]; // Swap the elements if the parent is greater.\n\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n        this.content[parentN] = element;\n        this.content[n] = parent; // Update 'n' to continue at the new position.\n\n        n = parentN;\n      } // Found a parent that is less, no need to move it further.\n      else {\n          break;\n        }\n    }\n  };\n\n  _proto.sinkDown = function sinkDown(n) {\n    // Look up the target element and its score.\n    var length = this.content.length,\n        element = this.content[n],\n        elemScore = this.scoreFunction(element);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      var child2N = (n + 1) * 2,\n          child1N = child2N - 1; // This is used to store the new position of the element,\n      // if any.\n\n      var swap = null; // If the first child exists (is inside the array)...\n\n      if (child1N < length) {\n        // Look it up and compute its score.\n        var child1 = this.content[child1N],\n            child1Score = this.scoreFunction(child1); // If the score is less than our element's, we need to swap.\n\n        if (child1Score < elemScore) {\n          swap = child1N;\n        }\n      } // Do the same checks for the other child.\n\n\n      if (child2N < length) {\n        var child2 = this.content[child2N],\n            child2Score = this.scoreFunction(child2);\n\n        if (child2Score < (swap == null ? elemScore : child1Score)) {\n          swap = child2N;\n        }\n      } // If the element needs to be moved, swap it, and continue.\n\n\n      if (swap !== null) {\n        this.content[n] = this.content[swap];\n        this.content[swap] = element;\n        n = swap;\n      } // Otherwise, we are done.\n      else {\n          break;\n        }\n    }\n  };\n\n  return BinaryHeap;\n}();\n\nvar _default = dijkstra;\nexports[\"default\"] = _default;\nmodule.exports = exports[\"default\"];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/layouts/lib/dijkstra.js\n// module id = 21\n// module chunks = 0 1","\"use strict\";\n\n/**\n * Version info string\n * @ko  \n * @name VERSION\n * @static\n * @type {String}\n * @example\n * eg.InfiniteGrid.VERSION;  // ex) 3.3.3\n * @memberof eg.InfiniteGrid\n */\nmodule.exports = \"3.4.5\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/version.js\n// module id = 22\n// module chunks = 0 1"],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC5RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACzXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC3KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC9ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACh0CA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC/RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC/MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACxUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC7NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}